<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><META content="IE=5.0000" http-equiv="X-UA-Compatible">
<TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type>
<META name=“robots” content=“noindex,nofollow”><LINK rel=stylesheet 
type=text/css href="mhtml:prcmsvs2010_22_files/printable.css">
<META name=GENERATOR content="MSHTML 10.00.9200.16384"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="FONT-WEIGHT: bold; COLOR: #000000">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" align="rright"><A 
href="http://www.intuit.ru/">http://www.intuit.ru/</A></SPAN> 
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="Контрольная%20работа%20№%201_files/mht2289(1).tmp" width=1 
    height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="Контрольная%20работа%20№%201_files/mht2289(1).tmp" width=1 
    height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="Контрольная%20работа%20№%201_files/mht2289(1).tmp" width=1 
    height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG src="Контрольная%20работа%20№%201_files/mht2289(1).tmp" width=8 
      height=1></TD>
    <TD><!-- content -->
      <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
        <TBODY>
        <TR>
          <TD class=head>Программирование на языке C в Microsoft Visual Studio 
            2010</TD></TR>
        <TR>
          <TD height=4><IMG 
            src="Контрольная%20работа%20№%201_files/mht2289(1).tmp" width=1 
            height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="Контрольная%20работа%20№%201_files/mht2289(1).tmp" width=1 
            height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="Контрольная%20работа%20№%201_files/mht2289(1).tmp" width=1 
            height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>Дополнительные материалы: Контрольная работа 
            № 1: версия для печати и PDA</SPAN> </TD></TR>
        <TR>
          <TD height=8><IMG 
            src="Контрольная%20работа%20№%201_files/mht2289(1).tmp" width=1 
            height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="Контрольная%20работа%20№%201_files/mht2289(1).tmp" width=1 
            height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="Контрольная%20работа%20№%201_files/mht2289(1).tmp" width=1 
            height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3>Вычисление последовательности Фибоначчи с использованием больших 
            чисел</H3>
            <P id=id_1>В языке программирования <B>C</B> существует большое 
            количество разнообразных целочисленных типов данных, области 
            определения которых охватывают числа различных диапазонов. При 
            решении задачи программист должен выбрать правильные типы данных для 
            числовых переменных, исходя из природы соответствующих данных, а 
            также требований к занимаемой программой и ее данными памятью и 
            желаемым быстродействием. Тем не менее, диапазоны встроенных 
            целочисленных типов данных языка <B>C</B> ограничены, что не 
            позволяет выполнять вычисления над достаточно большими числами 
            (например, с разрядностью более 20 десятичных цифр). Такое 
            ограничение оказывается серьезным препятствием при решении задач, 
            природа которых требует выполнения операций над большими числами, 
            например задач, требующих вычисления элементов быстрорастущих 
            последовательностей. В частности, использование типа <SPAN 
            class=texample>int</SPAN> языка <B>C</B> для вычисления элементов 
            последовательности Фибоначчи позволяет получить только 46 первых 
            чисел, после его происходит целочисленное переполнение, и получение 
            следующих элементов становится невозможным.</P>
            <DIV id=mark_1 class=lecture_mark></DIV>
            <P id=id_3>Такая проблема ограниченности диапазонов целочисленных 
            типов данных решается при помощи так называемой "длинной 
            арифметики". Длинная арифметика – в вычислительной технике операции 
            над числами, разрядность которых превышает длину машинного слова 
            данной вычислительной машины.</P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <P id=id_4>На практике длинная арифметика применяется в следующих 
            случаях:</P>
            <DIV id=mark_4 class=lecture_mark></DIV>
            <UL id=id_5>
              <LI>На компьютеры с процессорами низкой разрядности и 
              микроконтроллерах. Например, на компьютерах и микроконтроллерах с 
              8-битными процессорами без использования длинной арифметики 
              невозможно выполнить никакие сколько-нибудь полезные вычисления;
              <LI>При решении задач криптографии;
              <LI>При создании математического и финансового программного 
              обеспечения, требования к точности вычислений в котором очень 
              высоки и критичны, а ошибки округления и переполнения недопустимы;
              <LI>Для "спортивных" вычислений знаменитых трансцендентных чисел ( 
              <IMG style="POSITION: relative; DISPLAY: inline; TOP: 3px" alt=\pi 
              src="Контрольная%20работа%20№%201_files/mht22BB(1).tmp" width=14 
              height=11>, e и т. д.) с высокой точностью;
              <LI>Для решения олимпиадных задач по программированию.</LI></UL>
            <DIV id=mark_5 class=lecture_mark></DIV>
            <P id=id_11>Рассмотрим, каким образом можно хранить длинные целые 
            числа в памяти компьютера и как выполнять над ними действия. Обычно 
            длинное число представляют в виде массива, элементы которого хранят 
            цифры длинного числа, и отдельно дополнительно сохранят длину числа, 
            то есть количество значимых цифр. При хранении длинного числа 
            удобнее перейти от десятичной системы счисления к системе счисления 
            с большим основанием, так как это позволит лучше использовать 
            пространство оперативной памяти, используемой под массив. Количество 
            значимых цифр будем хранить в первом элементе массива (элементе с 
            индексом 0). Цифры числа будем хранить в обратном порядке, то есть 
            младшая цифра будет храниться в элементе массива с меньшим 
            индексом.</P>
            <DIV id=mark_11 class=lecture_mark></DIV>
            <P id=id_12>Сделаем следующие объявления:</P>
            <DIV id=mark_12 class=lecture_mark></DIV>
            <DIV class=example><PRE>/// максимальная длина числа - 1000 знаков
#define NUMMAX		1000
/// основание системы счисления длинных чисел - 10^9
#define NUMBASE		1000000000
/// получениедлины числа
#define NUMLEN(n)	((n)[0])
/// определение типа длинных чисел
typedef int number_t[NUMMAX + 1];</PRE></DIV>
            <P id=id_14>Итак, мы определили тип данных длинных чисел – number_t. 
            С его помощью можно хранить и обрабатывать числа длиной до 9000 
            десятичных знаков. Основание системы счисления выбрано равным 
            10<SUP>9</SUP>, это позволяет хранить в одном элементе массива до 9 
            десятичных знаков. Рассмотрим пример хранения двух чисел: 1 и 
            1234567890.</P>
            <DIV id=mark_14 class=lecture_mark></DIV>
            <P id=id_15>Число 1 меньше выбранного основания системы счисления, 
            поэтому оно будет представлено одной значимой цифрой и для его 
            хранения будет достаточно 1 элемента массива. Схема вышеприведенного 
            описания может быть следующей:</P>
            <DIV id=mark_15 class=lecture_mark></DIV>
            <P id=id_16 align=left><A></A></P>
            <DIV><IMG alt="" 
            src="Контрольная%20работа%20№%201_files/mht22DD(1).tmp"></DIV><BR>
            <P></P>
            <DIV id=mark_16 class=lecture_mark></DIV>
            <P id=id_17>Число 1234567890 больше выбранного основания системы 
            счисления, поэтому оно будет представлено двумя значимыми цифрами и 
            для его хранения потребуется 2 элемента массива. Схема приведенного 
            описания может быть следующей:</P>
            <DIV id=mark_17 class=lecture_mark></DIV>
            <P id=id_18 align=left><A></A></P>
            <DIV><IMG alt="" 
            src="Контрольная%20работа%20№%201_files/mht22F0(1).tmp"></DIV><BR>
            <P></P>
            <DIV id=mark_18 class=lecture_mark></DIV>
            <P id=id_19>Создадим три вспомогательные функции, выполняющие 
            установку значения длинного числа. Функция <SPAN 
            class=texample>numzero()</SPAN> устанавливает длинное число равным 
            нулю. Программный код функции:</P>
            <DIV id=mark_19 class=lecture_mark></DIV>
            <DIV class=example><PRE>/// сброс длинного числа в ноль
void numzero (number_t lhs)
{
	lhs[0] = 1;
	lhs[1] = 0;
}</PRE></DIV>
            <P id=id_22>Функция <SPAN class=texample>numassgns()</SPAN> 
            присваивает длинному числу короткое значение из диапазона 
            0..2<SUP>32</SUP>–1. Программный код функции:</P>
            <DIV id=mark_22 class=lecture_mark></DIV>
            <DIV class=example><PRE>/// присваивание короткого числа длинному числу
void numassgns (number_t lhs, unsigned rhs)
{
	lhs[0] = 0;
	while (rhs)
	{
		lhs[++lhs[0]] = rhs % NUMBASE;
		rhs /= NUMBASE;
	}
}</PRE></DIV>
            <P id=id_25>Функция <SPAN class=texample>numassgn()</SPAN> 
            присваивает одному длинному числу значение другого длинного числа. 
            Программный код функции:</P>
            <DIV id=mark_25 class=lecture_mark></DIV>
            <DIV class=example><PRE>/// присваивание длинных чисел
void numassgn (number_t lhs, const number_t rhs)
{
	int i;

	// переписываем длину результирующего числа
	lhs[0] = rhs[0];
	// копируем цифры
	for (i = 1; i &lt;= NUMLEN (rhs); ++i)
		lhs[i] = rhs[i];
}</PRE></DIV>
            <P id=id_28>Для вывода длинного числа на экран создадим функцию 
            <SPAN class=texample>numprint()</SPAN>. Эта функция сначала 
            проверяет длину числа, и если она равна 0, то выводит число 0, в 
            противном случае она печатает цифры числа на экране проходя по 
            массиву в обратном направлении, от индексов с большими значениями до 
            индексов с меньшими значениями, так как цифры числа хранятся в 
            обратном порядке. Программный код функции:</P>
            <DIV id=mark_28 class=lecture_mark></DIV>
            <DIV class=example><PRE>/// печать длинного числа
void numprint (const number_t lhs)
{
	int i;
    
	printf ("%d", NUMLEN (lhs) ? lhs[NUMLEN (lhs)] : 0);
	for (i = NUMLEN(lhs) - 1; i &gt; 0; --i)
		printf ("%09d", lhs[i]);

}</PRE></DIV>
            <P id=id_31>Операция сложения длинных чисел реализует обычное 
            сложение чисел столбиком. Вспомним, как выполняется такая операция. 
            Пусть надо сложить два числа 12345 и 678. Записываем эти два числа в 
            столбик таким образом, чтобы младшие разряды числа оказались друг 
            под другом. После этого по таблице сложения складываем независимо 
            разряды друг с другом. Если результат превосходит 9, то запоминаем 
            1, переносим ее в старший разряд, а в текущем разряде записываем 
            младший разряд от результата сложения. И так продолжается до тех 
            пор, пока все разряды не будут учтены. Обратите внимание, что если 
            длина чисел разная, то в старших разрядах более длинного числа 
            сложение производится только с "запомненной" 1 переноса. Схема 
            вычислений может быть следующей:</P>
            <DIV id=mark_31 class=lecture_mark></DIV>
            <P id=id_32 align=left><A></A></P>
            <DIV><IMG alt="" 
            src="Контрольная%20работа%20№%201_files/mht2312(1).tmp"></DIV><BR>
            <P></P>
            <DIV id=mark_32 class=lecture_mark></DIV>
            <P id=id_33>Сложение чисел выполняется функцией <SPAN 
            class=texample>numadd()</SPAN>. Функция принимает два числа – 
            слагаемых и записывает результат в параметр с именем res. Функция 
            выбирает из двух слагаемых более короткое и сначала складывает 
            разряды двух чисел, затем, когда все разряды более короткого числа 
            будут учтены, добавляет оставшиеся разряды более длинного числа с 
            учетом переноса, признак которого хранится в переменной <B>c</B>. 
            Так как цифры числа хранятся в обратном порядке, то сложение 
            осуществляется в порядке возрастания индексов массива. Программный 
            код функции:</P>
            <DIV id=mark_33 class=lecture_mark></DIV>
            <DIV class=example><PRE>/// сложение длинных чисел
void numadd (number_t res, const number_t lhs, const number_t rhs)
{
	int i = 0;
	// флаг переноса
	int c = 0;
	// число с минимальной длинной
	const int *sn = NUMLEN (lhs) &lt; NUMLEN (rhs) ? lhs : rhs;
	// число с максимальной длиной
	const int *ln = sn == lhs ? rhs : lhs;
	
	// складываем два числа
	while (i &lt; NUMLEN (sn))
	{
		++i;
		res[i] = c + sn[i] + ln[i];
		c = res[i] &gt; NUMBASE ? 1 : 0;
		if (c) res[i] -= NUMBASE;
	}
	// добавляем остаток от более длинного числа и перенос
	while (i &lt; NUMLEN (ln))
	{
		++i;
		res[i] = c + ln[i];
		c = res[i] &gt; NUMBASE ? 1 : 0;
		if (c) res[i] -= NUMBASE;
	}
	// учитываем последний перенос
	if (c) res[++i] = c;
	// сохраняем длину числа
	res[0] = i;
}</PRE></DIV>
            <P id=id_36>Рассмотрим пример использования арифметики длинных 
            чисел. Функция <SPAN class=texample>main()</SPAN> создает три 
            переменные для хранения длинных чисел, инициализирует из значениями, 
            и выполняет операцию сложения, после чего печатает результат на 
            экране. Программный код главной функции:</P>
            <DIV id=mark_36 class=lecture_mark></DIV>
            <DIV class=example><PRE>int main (int argc, char* argv[])
{
	int i;

	number_t a, b, c;
	numassgns (a, 1234567890);
	numassgns (b, 1);
	numadd (c, a, b);
	numprint (c);

     printf("\n\n ... Press any key: ");
    _getch();

	return 0;
}</PRE></DIV>
            <P id=id_39><B>Задание</B>:</P>
            <DIV id=mark_39 class=lecture_mark></DIV>
            <OL id=id_40>
              <LI>Создайте функцию <SPAN class=texample>numtoa ()</SPAN>, 
              выполняющую преобразование длинного числа в строку. Функция должна 
              иметь следующий прототип:
              <DIV class=example><PRE>/// перевод длинного числа в строку
void numtoa (const number_t num, char *str);</PRE></DIV>
              <LI>Создайте функцию <SPAN class=texample>atonum ()</SPAN>, 
              выполняющую преобразование строки в длинное число. Функция должна 
              иметь следующий прототип:
              <DIV class=example><PRE>/// перевод строки в длинное число
void atonum (const char *str, number_t num);</PRE></DIV>
              <LI>Разработайте программу, выполняющую вычисление 500 первых 
              чисел последовательности Фибоначчи. Элементы последовательности 
              Фибоначчи вычисляются по следующему рекуррентному соотношению: 
              <IMG style="POSITION: relative; DISPLAY: inline; TOP: 5px" 
              alt="a_i = a_{i-1} + a_{i-2}, a_1 = 1, a_2 = 1" 
              src="Контрольная%20работа%20№%201_files/mht2325(1).tmp" width=249 
              height=20></LI></OL>
            <DIV id=mark_40 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="Контрольная%20работа%20№%201_files/mht2289(1).tmp" width=1 
            height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG src="Контрольная%20работа%20№%201_files/mht2289(1).tmp" width=8 
      height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG 
      src="Контрольная%20работа%20№%201_files/mht2289(1).tmp" width=1 
    height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript src="">
</SCRIPT>

<SCRIPT type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
