<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><META content="IE=5.0000" http-equiv="X-UA-Compatible">
<TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type>
<META name=“robots” content=“noindex,nofollow”><LINK rel=stylesheet 
type=text/css href="mhtml:prcmsvs2010_18_files/printable.css">
<META name=GENERATOR content="MSHTML 10.00.9200.16384"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="FONT-WEIGHT: bold; COLOR: #000000">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" align="rright"><A 
href="http://www.intuit.ru/">http://www.intuit.ru/</A></SPAN> 
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG src="Лекция_18_files/mhtA513(1).tmp" width=1 
      height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="Лекция_18_files/mhtA513(1).tmp" width=1 height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG src="Лекция_18_files/mhtA513(1).tmp" width=1 
      height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG src="Лекция_18_files/mhtA513(1).tmp" width=8 height=1></TD>
    <TD><!-- content -->
      <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
        <TBODY>
        <TR>
          <TD class=head>Программирование на языке C в Microsoft Visual Studio 
            2010</TD></TR>
        <TR>
          <TD height=4><IMG src="Лекция_18_files/mhtA513(1).tmp" width=1 
            height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG src="Лекция_18_files/mhtA513(1).tmp" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG src="Лекция_18_files/mhtA513(1).tmp" width=1 
            height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>18. Лекция: Рекурсивные алгоритмы и функции: 
            версия для печати и PDA</SPAN> <BR><SPAN class=rtxt>В лекции 
            ставится задача изучить различные виды рекурсии и применения 
            рекурсивных алгоритмов, получить навыки программирования на языке С 
            с использованием рекурсивных функций. </SPAN></TD></TR>
        <TR>
          <TD height=8><IMG src="Лекция_18_files/mhtA513(1).tmp" width=1 
            height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG src="Лекция_18_files/mhtA513(1).tmp" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG src="Лекция_18_files/mhtA513(1).tmp" width=1 
            height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3>Теоретическая часть</H3>
            <P id=id_1><SPAN class=xml_em_italic>Рекурсивные функции</SPAN> 
            (лат. <SPAN class=xml_em_italic>recursio</SPAN> – возвращение) – в 
            вычислительной математике – функции, определенные на множестве 
            натуральных чисел и принимающие значения того же множества [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#18" 
            target=_blank>18.1</A>].</P>
            <DIV id=mark_1 class=lecture_mark></DIV>
            <P id=id_2><SPAN class=xml_em_italic>Рекурсивный алгоритм</SPAN> – 
            это алгоритм, решающий задачу путем решения одного или нескольких 
            более узких вариантов той же задачи [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#19" 
            target=_blank>18.2</A>]. Функция называется рекурсивной, если в ее 
            определении содержится вызов этой же функции [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#20" 
            target=_blank>18.3</A>]. <SPAN class=xml_em_italic>Рекурсивная 
            функция</SPAN> может вызывать саму се6я или непосредственно, или 
            косвенно через другую функцию [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#1" 
            target=_blank>18.4</A>]. Рекурсии целесообразно применять в задачах, 
            которые можно разбить на множество меньших подобных задач [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#21" 
            target=_blank>18.5</A>]. Рекурсия в программировании может быть 
            определена как сведение задачи к такой же задаче, но манипулирующей 
            с боле простыми данными.</P>
            <DIV id=mark_2 class=lecture_mark></DIV>
            <P id=id_3>Рекурсивную программу всегда можно преобразовать в 
            итеративную программу, использующую циклы, которая выполняет те же 
            вычисления. И наоборот, используя рекурсию, можно реализовать, не 
            прибегая к циклам.</P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <P id=id_4>Рекурсивный подход обычно предпочитается итеративному 
            подходу в тех случаях, когда рекурсия более естественно отражает 
            математическую сторону задачи и приводит к программе, которая проще 
            для понимания и отладки. Другой причиной для выбора рекурсивного 
            решения является то, что итеративное решение может не быть очевидным 
            [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#1" 
            target=_blank>18.4</A>].</P>
            <DIV id=mark_4 class=lecture_mark></DIV>
            <P id=id_5>Наличие в задаче рекуррентного соотношения позволяет 
            использовать рекурсию. Например, арифметическая прогрессия – 
            последовательность чисел, в которой разность между последующими и 
            предыдущими членами остается неизменной и называется разностью 
            прогрессии [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#18" 
            target=_blank>18.1</A>]. То есть каждый следующий член прогрессии 
            равен предыдущему, увеличенному на разность прогрессии.</P>
            <DIV id=mark_5 class=lecture_mark></DIV>
            <P id=id_6>Различают прямую и косвенную рекурсию. <SPAN 
            class=xml_em_italic>Прямой (непосредственной) рекурсией</SPAN> 
            является вызов функции внутри тела этой функции. <SPAN 
            class=xml_em_italic>Косвенной рекурсией</SPAN> является рекурсия, 
            осуществляющая рекурсивный вызов функции посредством цепочки вызова 
            других функций [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#7" 
            target=_blank>18.6</A>]. Все функции, входящие в цепочку, тоже 
            считаются рекурсивными.</P>
            <DIV id=mark_6 class=lecture_mark></DIV>
            <P id=id_7>В рекурсии простейшей формы рекурсивный вызов расположен 
            в конце функции, непосредственно перед оператором возврата из 
            функции (или возвращаемого значения). Такая рекурсия называется 
            хвостовой или концевой. Хвостовая рекурсия является простейшей 
            формой рекурсии, поскольку она действует подобно циклу [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#15" 
            target=_blank>18.7</A>]. Если в программе имеется хвостовая 
            рекурсия, то ее лучше преобразовать к итерации.</P>
            <DIV id=mark_7 class=lecture_mark></DIV>
            <P id=id_8>Отметим особенности работы рекурсивных функций, 
            характерных для тех языков программирования, которые поддерживают 
            рекурсию. К этим языкам относится и язык <B>С</B>.</P>
            <DIV id=mark_8 class=lecture_mark></DIV>
            <P id=id_9>Когда функция вызывает сама себя (когда имеем дело с 
            рекурсивной функцией), новый набор локальных переменных и параметров 
            размещается в памяти в стеке, а код функции выполняется с самого 
            своего начала, причем используются именно эти новые переменные. При 
            рекурсивном вызове функции новая копия ее кода не создается. Новыми 
            являются только значения, которые использует данная функция. При 
            каждом возвращении из рекурсивного вызова старые локальные 
            переменные и параметры извлекаются из стека, и сразу за рекурсивным 
            вызовом возобновляется работа функции [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#5" 
            target=_blank>18.8</A>]. Выполнение функции возобновляется с 
            "внутренней" точки ее вызова.</P>
            <DIV id=mark_9 class=lecture_mark></DIV>
            <P id=id_10>Общая схема определения рекурсивной функции</P>
            <DIV id=mark_10 class=lecture_mark></DIV>
            <UL id=id_11>
              <LI>Существует условие, при котором функция выполняет свою задачу 
              с использованием рекурсивных вызовов, соответствующих одной или 
              нескольких "уменьшенным" версиям задачи.
              <LI>Существует также условие, которое будет удовлетворено и при 
              котором функция выполняет свою задачу без рекурсивных вызовов. Это 
              условие называется <SPAN class=xml_em_italic>базовым</SPAN> или 
              <SPAN class=xml_em_italic>условием останова</SPAN> [<A 
              href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#19" 
              target=_blank>18.2</A>,<A 
              href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#1" 
              target=_blank>18.4</A>-<A 
              href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#21" 
              target=_blank>18.5</A>-<A 
              href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#15" 
              target=_blank>18.6</A>].</LI></UL>
            <DIV id=mark_11 class=lecture_mark></DIV>
            <P id=id_14>Рассмотрим некоторые определения, относящиеся к 
            рекурсии. Максимальное число рекурсивных вызовов без возвратов, 
            которое происходит во время выполнения программы, называется <SPAN 
            class=xml_em_italic>глубиной рекурсии</SPAN>. Число рекурсивных 
            вызовов в каждый конкретный момент времени, называется текущим <SPAN 
            class=xml_em_italic>уровнем рекурсии</SPAN>. В практических 
            приложениях важно убедиться, что максимальная глубина рекурсий не 
            только конечна, но и достаточно мала [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#24" 
            target=_blank>18.11</A>].</P>
            <DIV id=mark_14 class=lecture_mark></DIV>
            <P id=id_15>Существует три разных формы рекурсивных программ:</P>
            <DIV id=mark_15 class=lecture_mark></DIV>
            <OL id=id_16>
              <LI>Форма с выполнением действий до рекурсивного вызова (с 
              выполнением действий на рекурсивном спуске).
              <LI>Фома с выполнением действий после рекурсивного вызова (с 
              выполнением действий на рекурсивном возврате).
              <LI>Форма с выполнением действий как до, так и после рекурсивного 
              вызова (с выполнением действий, как на рекурсивном спуске, так и 
              на рекурсивном возврате).</LI></OL>
            <DIV id=mark_16 class=lecture_mark></DIV>
            <P id=id_20>Понятие <SPAN class=xml_em_italic>рекурсии</SPAN> сходно 
            с понятием <SPAN class=xml_em_italic>математической индукции</SPAN>. 
            У рекурсии, как и у математической индукции, есть база – аргументы, 
            для которых значения функции определены (элементарные задачи), и 
            <SPAN class=xml_em_italic>шаг рекурсии</SPAN> – способ сведения 
            задачи к более простым задачам.</P>
            <DIV id=mark_20 class=lecture_mark></DIV>
            <P id=id_21>Рекурсия обладает своими преимуществами и недостатками. 
            Одно из преимуществ рекурсии состоит в том, что она предлагает 
            простейшее решение некоторых задач программирования. Один из 
            недостатков рекурсии заключается в том, что некоторые рекурсивные 
            алгоритмы могут довольно-таки быстро исчерпать ресурс памяти 
            компьютера. Наряду с этим рекурсию трудно документировать и 
            поддерживать [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#15" 
            target=_blank>18.7</A>].</P>
            <DIV id=mark_21 class=lecture_mark></DIV>
            <P id=id_22>Главное при оформлении рекурсивной функции – это 
            правильное задание условия выхода из рекурсивных вызовов. Если при 
            зацикливании программы при операторе цикла компьютер может выполнять 
            такой цикл, не реагируя на любые действия пользователя, то при 
            зацикливании из-за неправильного оформления рекурсивной функции 
            неизбежно происходит аварийный останов, когда будет исчерпан объем 
            оперативной памяти, которая выделяется при каждом рекурсивном 
            вызове. При этом следует всегда помнить, что даже при правильном 
            оформлении рекурсивной функции, необходимо учитывать объем 
            вычислительной работы. Например, расчет факториала целого 
            положительного числа – трудоемкая операция. В математической 
            постановке задачи нет ничего сложного, но в случае программирования 
            этого процесса для различных систем и компьютеров имеются свои 
            ограничения. Например, это касается рекурсивного вычисления 
            факториала.</P>
            <DIV id=mark_22 class=lecture_mark></DIV>
            <P id=id_23>В то же время для некоторых задач рекурсивные функции 
            вполне оправданы. В частности динамические информационные структуры 
            включают рекурсивность в само определение обрабатываемых данных. 
            Именно для таких данных применение рекурсивных алгоритмов не имеет 
            конкуренции со стороны итерационных методов [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#7" 
            target=_blank>18.6</A>].</P>
            <DIV id=mark_23 class=lecture_mark></DIV>
            <P id=id_24>Рекурсивная задача в общем случае разбивается на ряд 
            этапов. Для решения задачи вызывается рекурсивная функция. Эта 
            функция знает, как решать только простейшую часть задачи – так 
            называемую <SPAN class=xml_em_italic>базовую задачу</SPAN> (или 
            несколько таких задач). Если эта функция вызывается для решения 
            базовой задачи, она просто возвращает результат. Если функция 
            вызывается для решения более сложной задачи, она делит эту задачу на 
            две части: одну часть, которую функция умеет решать, и другую, 
            которую функция решать не умеет. Чтобы сделать рекурсию выполнимой, 
            последняя часть должна быть похожа на исходную задачу, но быть по 
            сравнению с ней несколько проще или несколько меньше. Поскольку эта 
            новая задача подобна исходной, функция вызывает новую копию самой 
            себя, чтобы начать работать над меньшей проблемой – это называется 
            <SPAN class=xml_em_italic>рекурсивным вызовом</SPAN>, или <SPAN 
            class=xml_em_italic>шагом рекурсии</SPAN>. Шаг рекурсии включает 
            ключевое слово <SPAN class=texample>return</SPAN>, так как в 
            дальнейшем его резул ьтат будет объединен с той частью задачи, 
            которую функция умеет решать, и сформируется конечный результат, 
            который будет передан обратно в исходное место вызова.</P>
            <DIV id=mark_24 class=lecture_mark></DIV>
            <P id=id_26>Рассмотрим пример вычисления факториала целого 
            положительного числа, когда есть, и нет хвостовой рекурсии. При этом 
            покажем возможность исключения рекурсии. Пусть определена следующая 
            рекурсивная функция:</P>
            <DIV id=mark_26 class=lecture_mark></DIV>
            <DIV class=example><PRE>int fact (int n) {
  if (n == 0)
    return 1;
    else
    return n * fact (n - 1);
}</PRE></DIV>
            <P id=id_28>Эта исходная функция <SPAN class=texample>fact()</SPAN> 
            не имеет хвостовой рекурсии т. к. выполняется перемножение после 
            рекурсивного вызова (умножение на <B>n</B> ). Для исключения 
            рекурсии сначала приведем <SPAN class=texample>fact ()</SPAN> к виду 
            с хвостовой рекурсией, например</P>
            <DIV id=mark_28 class=lecture_mark></DIV>
            <DIV class=example><PRE>int fact (int n) {
  return fact_w (1,n);
}</PRE></DIV>
            <P id=id_32>Вспомогательная функция <SPAN class=texample>fact_w 
            ()</SPAN> будет содержать хвостовую рекурсию. Ее программный 
код:</P>
            <DIV id=mark_32 class=lecture_mark></DIV>
            <DIV class=example><PRE>int fact_w (int r, int n) {
  if (n == 0)
    return r;
  else
    return fact(r*n,n-1);
}</PRE></DIV>
            <P id=id_35>В функции <SPAN class=texample>fact_w()</SPAN> хвостовая 
            рекурсия присутствует в силу рекурсивного обращения только к самой 
            функции в операторе return.</P>
            <DIV id=mark_35 class=lecture_mark></DIV>
            <P id=id_37>Обратимся к известному положению об исключении хвостовой 
            рекурсии: если функция f(x) содержит в конце рекурсивный вызов в 
            виде return f(y), то рекурсию можно исключить путем присваивания x = 
            y, и перехода goto на начало функции [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#25" 
            target=_blank>18.14</A>]. Программный код исключения хвостовой 
            рекурсии:</P>
            <DIV id=mark_37 class=lecture_mark></DIV>
            <DIV class=example><PRE>int fact_w (int r, int n) {
met:
  if (n == 0)
    return r;
  else {
    r = r*n;
    n = n-1;
    goto met;
  }
}</PRE></DIV>
            <P id=id_39>Использование оператора <SPAN class=texample>goto</SPAN> 
            нежелательно с точки зрения современных представлений и методов 
            структурного программирования, преобразуем конструкцию с <SPAN 
            class=texample>goto</SPAN> к циклу:</P>
            <DIV id=mark_39 class=lecture_mark></DIV>
            <DIV class=example><PRE>int fact_w (int r, int n) {
  while (n != 0) {
    r = r*n;
    n = n-1;
  }
  return r;
}</PRE></DIV>
            <P id=id_43>В качестве окончательной оптимизации можно исключить и 
            вспомогательную функцию <SPAN class=texample>fact_w ()</SPAN>, 
            выполнив подстановку тела функции в точку ее вызова (inlining). В 
            итоге получим следующий программный код функции, вычисляющей 
            факториал числа:</P>
            <DIV id=mark_43 class=lecture_mark></DIV>
            <DIV class=example><PRE>/*
* Оптимизация функции
* вычисления факториала числа
*/
int fact (int n)
 {
  int r = 1;
  while (n != 0) {
    r = r*n;
    n = n-1;
  }
  return r;
}</PRE></DIV>
            <P id=id_46>В приведенной функции нет ни рекурсивных вызовов, ни 
            оператора goto.</P>
            <DIV id=mark_46 class=lecture_mark></DIV>
            <P id=id_47>Однако во многих случаях использование рекурсивных 
            функций оправдано, хотя бы с точки зрения формирования особого 
            мышления, свойственного профессиональным программистам. И как было 
            отмечено, некоторые динамические информационные структуры легче 
            реализуются с помощью рекурсии.</P>
            <DIV id=mark_47 class=lecture_mark></DIV>
            <P id=id_48>Каждая функция в программе на языке <B>С</B> находится 
            на одном уровне с остальными функциями, составляющие программный 
            проект. Каждая из них может вызвать любую другую функцию или быть 
            вызванной другими функциями. По этой причине функция <SPAN 
            class=texample>main()</SPAN> может вызывать сама себя в рамках 
            некоторой рекурсии или быть вызванной из других функций, хотя 
            подобное встречается достаточно редко [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#15" 
            target=_blank>18.7</A>]. Следует только иметь в виду, что когда 
            программа составляется из нескольких функций, выполнение этой 
            программы начинается с первого оператора функции <SPAN 
            class=texample>main()</SPAN>.</P>
            <DIV id=mark_48 class=lecture_mark></DIV>
            <P id=id_51>В практической части данной лабораторной работы будут 
            рассмотрены примеры программ для решения типовых задач, позволяющих 
            использовать рекурсию.</P>
            <DIV id=mark_51 class=lecture_mark></DIV><A name=sect2></A>
            <H3>Практическая часть</H3>
            <P id=id_52><B>Пример 1</B>. Напишите рекурсивную функцию 
            определения наибольшего общего делителя двух целых чисел.</P>
            <DIV id=mark_52 class=lecture_mark></DIV>
            <P id=id_53>Программный код решения примера:</P>
            <DIV id=mark_53 class=lecture_mark></DIV>
            <DIV class=example><PRE>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;stdlib.h&gt;

// Прототип рекурсивной функции 
int gcd(int a, int b);

int main (void) {
	int a = 0, b = 0;
	int in;

// Проверка ввода двух целых чисел
		do {
printf("\n Enter the two different natural numbers, through the gap: ");
		in = scanf_s("%d%d", &amp;a, &amp;b);

		if (in != 2) {
		printf("\n Error input. Press any key to exit: ");
			_getch();
			exit(1);
		}

		if ( (a != b) &amp;&amp; (b != 0) )
			break;
		if (b == 0)
			a = b;

	} while ( (a == b) );

// Вывод результата на консоль 
	printf("\n a = %d, b = %d, GCD = %d; \n", a, b, gcd(a,b));
	
	printf("\n\n Press any key: ");
	_getch();
	return 0;
}

// Определение рекурсивной функции
int gcd(int a, int b) {
	if ( (a % b) == 0) 
		return b;
	else 
		return gcd(b, a % b);
}</PRE></DIV>
            <P id=id_55>Решение примера выполнено на основе простой хвостовой 
            рекурсии, поскольку значения вызовов функции самой себя <SPAN 
            class=texample>gcd(b, a%b)</SPAN> возвращаются оператором <SPAN 
            class=texample>return</SPAN>. В программе используется оператор 
            <SPAN class=texample>%</SPAN> – операция остатка от деления двух 
            целых чисел (целочисленное деление). Известно, что если даны два 
            числа <SPAN class=xml_em_italic>А</SPAN> и <SPAN 
            class=xml_em_italic>В</SPAN>, то максимальный остаток от деления 
            числа <SPAN class=xml_em_italic>А</SPAN> на число <SPAN 
            class=xml_em_italic>В</SPAN> будет на единицу меньше числа <SPAN 
            class=xml_em_italic>В</SPAN>. В определении рекурсивной функции 
            <SPAN class=texample>gcd()</SPAN> условием останова является то, что 
            остаток от деления двух данных чисел равен нулю. Рекурсивные вызовы 
            функции <SPAN class=texample>gcd()</SPAN> связаны с изменением 
            расположения первоначально заданных аргументов, когда аргумент, 
            стоящий на втором месте ( <B>b</B> ), определяется на первом месте, 
            а на втором месте определяется операция остатка от деления, т. е. 
            <SPAN class=texample>a%b </SPAN>. И это происходит до тех пор, пока 
            остаток от деления не станет равным нул ю, т. е. будет выполнено 
            условие останова (базовое условие).</P>
            <DIV id=mark_55 class=lecture_mark></DIV>
            <P id=id_62>Возможный результат выполнения программы приведен на <A 
            href="mhtml:file://D:\c_cpp\Лекции\5.Программирование на языке C №1\18. Лекция Рекурсивные алгоритмы и функции.mht#image.18.1">рис. 
            18.1</A>.</P>
            <DIV id=mark_62 class=lecture_mark></DIV>
            <P id=id_63 align=left><A name=image.18.1></A></P>
            <DIV><IMG alt="Наибольший общий делитель для чисел 123 и 45" 
            src="Лекция_18_files/mhtA564(1).tmp" width=620 
            height=113></DIV><BR><B>Рис. 18.1.</B>&nbsp; Наибольший общий 
            делитель для чисел 123 и 45
            <P></P>
            <DIV id=mark_63 class=lecture_mark></DIV>
            <P id=id_64><B>Задание 1</B></P>
            <DIV id=mark_64 class=lecture_mark></DIV>
            <OL id=id_65>
              <LI>В программе оператор <SPAN class=texample>if</SPAN> 
              используйте для рекурсивных вызовов, а оператор <SPAN 
              class=texample>else</SPAN> используйте как условие останова.
              <LI>B программу включите определение количества рекурсивных 
              вызовов.
              <LI>Видоизмените программу для случая ошибочного ввода чисел, 
              сделайте, чтобы было повторное приглашение на ввод чисел.
              <LI>Напишите функцию вычисления наибольшего общего делителя на 
              основе итерации (с использованием операторов цикла).</LI></OL>
            <DIV id=mark_65 class=lecture_mark></DIV>
            <P id=id_72><B>Пример 2</B>. Напишите рекурсивную функцию, которая 
            выводит на консоль двоичный эквивалент целого десятичного числа, 
            введенного пользователем с клавиатуры.</P>
            <DIV id=mark_72 class=lecture_mark></DIV>
            <P id=id_73>Для решения примера отметим, что в двоичной системе 
            счисления числа представлены в виде суммы степеней 2. Подобно тому, 
            как в десятичной системе счисления число 234 означает <IMG 
            style="POSITION: relative; DISPLAY: inline; TOP: 5px" 
            alt="2\times10^2 + 3\times10^1 + 4\times10^0" 
            src="Лекция_18_files/mhtA586(1).tmp" width=217 height=20>, число 101 
            в двоичной системе означает <IMG 
            style="POSITION: relative; DISPLAY: inline; TOP: 5px" 
            alt="1\times2^2 + 0\times2^1 + 1\times2^0" 
            src="Лекция_18_files/mhtA599(1).tmp" width=191 height=20> [7]. В 
            двоичных числах используются только цифры 0 и 1.</P>
            <DIV id=mark_73 class=lecture_mark></DIV>
            <P id=id_76>Очевидно, что за основу решения примера следует 
            использовать целочисленное деление. Если введено число n, то оно 
            может быть, либо четным, либо нечетным. Тогда остаток от деления на 
            2 будет равняться нулю для четных чисел и единице – для 
нечетных.</P>
            <DIV id=mark_76 class=lecture_mark></DIV>
            <P id=id_77>Программный код решения примера:</P>
            <DIV id=mark_77 class=lecture_mark></DIV>
            <DIV class=example><PRE>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;locale.h&gt;

// Прототип рекурсивной функции
void dec2bin(unsigned long int);

int main (void) {
	unsigned long int n;

	setlocale(LC_ALL, "Russian"); // для русских шрифтов

	printf("\n\t Введите целое десятичное число\n \
 (или не числовой символ для завершения программы): ");
	while (scanf_s("%ul", &amp;n) == 1)
	{
		printf("\n Двоичный эквивалент: ");
		dec2bin(n);

	printf("\n\n\t Введите целое десятичное число\n \
 (или не числовой символ для завершения программы): ");

	}

	return 0; // выход из программы
}

// Определение рекурсивной функции
void dec2bin(unsigned long int n) {
	int r;
	r = n % 2;

	if (n &gt;= 2 ) 
		dec2bin(n/2);

	printf("%d", r);
	
	return;
}</PRE></DIV>
            <P id=id_79>В программе шаги рекурсии осуществляются при условии, 
            что аргумент рекурсивной функции больше или равен двум. Как только 
            это условие нарушается, происходит распечатка результата и выход из 
            функции. Например, при <B>n = 10</B> остаток от целочисленного 
            деления <B>r = 10%2 = 0</B>. В то же время аргумент функции <SPAN 
            class=texample>dec2bin()</SPAN> будет равняться 5. Тогда остаток от 
            целочисленного деления <B>r = 5%2 = 1</B>. Далее аргумент функции 
            будет равняться 2 (5/2), так как аргумент функции определен через 
            целое число. Остаток от целочисленного деления <B>r = 2%2 = 0</B>. 
            Теперь аргумент рекурсивной функции будет равен 1, что прерывает 
            рекурсивные вызовы функции (нарушается условие проверки оператором 
            <SPAN class=texample>if</SPAN> ). Остаток от деления <B>r = 1%2 = 
            1</B>. Вывод результата на консоль будет осуществляться из стека по 
            дисциплине LIFO (Last Input First Output – последним вошел, первым 
            вышел).</P>
            <DIV id=mark_79 class=lecture_mark></DIV>
            <P id=id_82>Пример выполнения программы показан на <A 
            href="mhtml:file://D:\c_cpp\Лекции\5.Программирование на языке C №1\18. Лекция Рекурсивные алгоритмы и функции.mht#image.18.2">рис. 
            18.2</A>.</P>
            <DIV id=mark_82 class=lecture_mark></DIV>
            <P id=id_83 align=left><A name=image.18.2></A></P>
            <DIV><IMG 
            alt="Преобразование десятичных чисел в двоичные эквиваленты" 
            src="Лекция_18_files/mhtA5AB(1).tmp" width=620 
            height=401></DIV><BR><B>Рис. 18.2.</B>&nbsp; Преобразование 
            десятичных чисел в двоичные эквиваленты
            <P></P>
            <DIV id=mark_83 class=lecture_mark></DIV>
            <P id=id_84><B>Задание 2</B></P>
            <DIV id=mark_84 class=lecture_mark></DIV>
            <OL id=id_85>
              <LI>Какой тип рекурсии используется в приведенной программе?
              <LI>В программу включите защиту от ввода отрицательных целых 
чисел.
              <LI>Вывод результатов преобразования десятичных чисел в двоичные 
              эквиваленты осуществите в текстовый файл с именем compX.txt, где Х 
              – номер компьютера (1, 2, ...), на котором выполняется 
              лабораторная работа. В текстовый файл занести также и 
              преобразуемое десятичное число.
              <LI>В программе вместо функции <SPAN 
              class=texample>printf()</SPAN>, как функции вывода результата, 
              примените функцию <SPAN class=texample>putchar()</SPAN>.
              <LI>В программу внесите изменения для подсчета количества 
              рекурсивных вызовов.
              <LI>Напишите программу преобразования десятичного числа в свой 
              двоичный эквивалент на основе не рекурсивного подхода, а с помощью 
              операций с разрядами.
              <LI>Напишите программу с рекурсивной функцией вывода на консоль 
              десятичного числа для введенного пользователем его двоичного 
              эквивалента.</LI></OL>
            <DIV id=mark_85 class=lecture_mark></DIV>
            <P id=id_95><B>Пример 3</B>. С использованием косвенной рекурсии 
            напишите программу по решению следующей задачи. Строка состоит из 
            клеток, пронумерованных от 1 до n. Состояние клетки можно изменить – 
            если она пуста, поставить в нее шащку (занять ее), иначе убрать из 
            нее шашку (освободить ее). Вначале строка пуста. Нужно занять все 
            клетки, соблюдая следующее правило. Изменение клетки допустимо, если 
            она имеет номер 1 или расположена непосредственно после занятой 
            клетки, имеющей минимальный номер среди занятых клеток.</P>
            <DIV id=mark_95 class=lecture_mark></DIV>
            <P id=id_96>Вход. Целое n, <IMG 
            style="POSITION: relative; DISPLAY: inline; TOP: 5px" 
            alt="1\leqslant n \leqslant15" src="Лекция_18_files/mhtA5CD(1).tmp" 
            width=88 height=18>.</P>
            <DIV id=mark_96 class=lecture_mark></DIV>
            <P id=id_98>Выход. Последовательность элементов вида +i или –i, 
            обозначающих соответственно занять клетку i и освободить клетку i 
            [9].</P>
            <DIV id=mark_98 class=lecture_mark></DIV>
            <P id=id_99>Например, при n = 3 выход имеет вид +1+2–1+3+1.</P>
            <DIV id=mark_99 class=lecture_mark></DIV>
            <P id=id_100>В основу решения задачи положен программный код из 
            [9].</P>
            <DIV id=mark_100 class=lecture_mark></DIV>
            <P id=id_101>Программный код решения примера:</P>
            <DIV id=mark_101 class=lecture_mark></DIV>
            <DIV class=example><PRE>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;   // для getch();
#include &lt;stdlib.h&gt; // для exit();

// Прототипы функций
void fillOnly(int);
void free_n(int);
void fill_n(int);

int main (void)
 {
	int n = 1; // размер строки
	int in = 1; // контроль ввода n

	printf("\n Enter a length of string (naturel number): ");
	in = scanf_s("%i", &amp;n);

	if (in != 1 || n &lt; 1 || n &gt; 15)
     {
		printf("\n Error input. Press any key to exit: ");
		_getch();
		exit(0);
	}
	puts("\n\tResult:");

	fill_n(n);

	printf("\n\n Press any key to exit: ");
	_getch();
	return 0;
}
   // Объявления функций
   // 1-я функция
void fillOnly(int n) {
	if (n == 1)
		printf("\t%+3d\n", 1);
	else {
		fillOnly(n-1);
		printf("\t%+3d\n", n);
		free_n(n-1);
	}
}

// 2-я функция
void free_n(int n)
 {
	if (n == 1)
		printf("\t%+3d\n", -1);

	else {
		fillOnly(n-1);
		printf("\t%+3d\n", -n);
		free_n(n-1);
	}
}

//3-я функция
void fill_n(int n)
 {
	if (n == 1)
		printf("\t%+3d\n", 1);
	else {
		if (n == 2)
			printf("\t%+3d\n\t%+3d\n", 1, 2);
		else {
			fillOnly(n-1);
			printf("\t%+3d\n", n);
			fill_n(n-2);
		}
	}
}</PRE></DIV>
            <P id=id_103>В программе вывод результата на консоль выполнен в виде 
            столбца. Для этого используется эскейп-последовательность <SPAN 
            class=texample>\t</SPAN> в функциях <SPAN 
            class=texample>printf()</SPAN>. Форматный вывод значений в функциях 
            <SPAN class=texample>printf()</SPAN> выполнен с помощью спецификации 
            <SPAN class=texample>%+3d</SPAN>, что позволяет автоматически 
            устанавливать знаки чисел, под которые отводятся 3 позиции.</P>
            <DIV id=mark_103 class=lecture_mark></DIV>
            <P id=id_108>Как видно из приведенного программного кода, в каждой 
            из функций имеется вызов самой функции и других функций. Это 
            указывает на косвенное обращение к функциям.</P>
            <DIV id=mark_108 class=lecture_mark></DIV>
            <P id=id_109>Пример выполнения программы показан на <A 
            href="mhtml:file://D:\c_cpp\Лекции\5.Программирование на языке C №1\18. Лекция Рекурсивные алгоритмы и функции.mht#image.18.3">рис. 
            18.3</A>.</P>
            <DIV id=mark_109 class=lecture_mark></DIV>
            <P id=id_110 align=left><A name=image.18.3></A></P>
            <DIV><IMG alt="Пример заполнения и освобождения клеток" 
            src="Лекция_18_files/mhtA5E0(1).tmp" width=620 
            height=566></DIV><BR><B>Рис. 18.3.</B>&nbsp; Пример заполнения и 
            освобождения клеток
            <P></P>
            <DIV id=mark_110 class=lecture_mark></DIV>
            <P id=id_111><B>Задание 3</B></P>
            <DIV id=mark_111 class=lecture_mark></DIV>
            <OL id=id_112>
              <LI>В программе укажите рекурсивные функции. Объясните работу 
              рекурсивных функций.
              <LI>Проверьте работу программы при смене порядка объявлений 
              функций.
              <LI>Проверьте работу программы без использования прототипов 
              функций.
              <LI>Для случая, когда <IMG 
              style="POSITION: relative; DISPLAY: inline; TOP: 5px" 
              alt="n \leqslant 5" src="Лекция_18_files/mhtA602(1).tmp" width=47 
              height=18>, предусмотрите вывод результата в строку, а не в 
              столбец.
              <LI>В программу добавьте программный код для подсчета рекурсивных 
              вызовов, каждой из рекурсивных функций.
              <LI>остройте зависимость числа комбинаций заполнения и 
              освобождения клеток от введенного числа <B>n</B>.</LI></OL>
            <DIV id=mark_112 class=lecture_mark></DIV>
            <P id=id_120><B>Пример 4</B>. "Ханойская башня". Напишите программу 
            по решению следующей задачи. Имеется пирамида из n колец, лежащих на 
            основании А (на стержне, на столбе) одно на другом в порядке 
            убывания размеров. Кольца должны быть перемещены на основание В в 
            том же порядке, в котором они были на основании А, при использовании 
            "промежуточного" основания С. Единственными разрешенными 
            перемещениями являются такие, при которых кольцо, взятое с вершины 
            одной из пирамид, помещается на большее кольцо, либо на пустое 
            основание. Осуществить выдачу на печать (на консоль, в текстовый 
            файл) последовательности перемещений колец.</P>
            <DIV id=mark_120 class=lecture_mark></DIV>
            <P id=id_121>"Ханойская башня" – известная задача. Алгоритм решения 
            этой задачи достаточно подробно описан в [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#23" 
            target=_blank>18.10</A>].</P>
            <DIV id=mark_121 class=lecture_mark></DIV>
            <P id=id_122>Решение задачи "Ханойская башня"</P>
            <DIV id=mark_122 class=lecture_mark></DIV>
            <P id=id_123>Для рекурсивного решения этой задачи следует пройти три 
            этапа.</P>
            <DIV id=mark_123 class=lecture_mark></DIV>
            <P id=id_124>1-й этап – параметризация. В этой задаче естественным 
            параметром является n – число колец. В число параметров можно 
            включить также и три основания: А (исходное), В (конечное), С 
            (промежуточное).</P>
            <DIV id=mark_124 class=lecture_mark></DIV>
            <P id=id_125>2-й этап – поиск тривиальных случаев. Здесь тривиальным 
            случаем будет такой, при котором n = 0; в этом случае просто нечего 
            делать.</P>
            <DIV id=mark_125 class=lecture_mark></DIV>
            <P id=id_126>3-й этап – редукция общего случая к более простому. 
            Здесь надо отметить, что n колец могут быть перемещены с А на В 
            следующим путем:</P>
            <DIV id=mark_126 class=lecture_mark></DIV>
            <UL id=id_127>
              <LI>переноса (рекурсивно) n – 1 колец с вершины А (исходное 
              основание) на С ("промежуточное" основание) с учетом правил: 
              основание В (конечная цель) используется как промежуточное 
              основание;
              <LI>перемещения на В кольца (наибольшего диаметра), оставшегося на 
              А;
              <LI>переноса (рекурсивно) n – 1 других колец с С на В при 
              соблюдении правил с А в качестве промежуточного основания.</LI></UL>
            <DIV id=mark_127 class=lecture_mark></DIV>
            <P id=id_131>Алгоритм решения задачи запишем в следующем виде:</P>
            <DIV id=mark_131 class=lecture_mark></DIV>
            <DIV class=example><PRE>hanoi(n–1, A, C, B);
переместить (A, B);
hanoi(n–1, C, B, A);</PRE></DIV>
            <P id=id_133>где <SPAN class=texample>hanoi()</SPAN> – имя 
            рекурсивной функции [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#23" 
            target=_blank>18.10</A>].</P>
            <DIV id=mark_133 class=lecture_mark></DIV>
            <P id=id_135>Пример промежуточного положения Ханойской башни при n = 
            4 показан на <A 
            href="mhtml:file://D:\c_cpp\Лекции\5.Программирование на языке C №1\18. Лекция Рекурсивные алгоритмы и функции.mht#image.18.4">рис. 
            18.4</A>.</P>
            <DIV id=mark_135 class=lecture_mark></DIV>
            <P id=id_136 align=left><A name=image.18.4></A></P>
            <DIV><IMG alt="Промежуточное положение Ханойской башни при n = 4" 
            src="Лекция_18_files/mhtA615(1).tmp" width=454 
            height=126></DIV><BR><B>Рис. 18.4.</B>&nbsp; Промежуточное положение 
            Ханойской башни при n = 4
            <P></P>
            <DIV id=mark_136 class=lecture_mark></DIV>
            <P id=id_137>Число элементарных перемещений равно 2<SUP>n</SUP> – 1, 
            где n – количество исходных дисков [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#23" 
            target=_blank>18.10</A>]. С увеличением n число перемещений быстро 
            нарастает.</P>
            <DIV id=mark_137 class=lecture_mark></DIV>
            <P id=id_138>На <A 
            href="mhtml:file://D:\c_cpp\Лекции\5.Программирование на языке C №1\18. Лекция Рекурсивные алгоритмы и функции.mht#image.18.5">рис. 
            18.5</A> показана зависимость элементарных перемещений от числа 
            дисков.</P>
            <DIV id=mark_138 class=lecture_mark></DIV>
            <P id=id_139 align=left><A name=image.18.5></A></P>
            <DIV><IMG alt="Зависимость элементарных перемещений от числа дисков" 
            src="Лекция_18_files/mhtA637(1).tmp" width=572 
            height=430></DIV><BR><B>Рис. 18.5.</B>&nbsp; Зависимость 
            элементарных перемещений от числа дисков
            <P></P>
            <DIV id=mark_139 class=lecture_mark></DIV>
            <P id=id_140>С учетом того, что перемещение диска – это есть 
            рекурсивный вызов функции, то на каждый вызов требуется определенное 
            время. Практически с любым конечным малым временем обработки 
            рекурсивного вызова общее время работы рекурсивной функции для 
            большого количества дисков n становится не выполнимым на 
            существующих современных компьютерах. В соответствии с легендой 
            конец света наступит при перемещении 64 дисков [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#23" 
            target=_blank>18.10</A>].</P>
            <DIV id=mark_140 class=lecture_mark></DIV>
            <P id=id_141>В связи со степенным ростом числа рекурсивных вызовов в 
            программе ограничимся величиной n = 15.</P>
            <DIV id=mark_141 class=lecture_mark></DIV>
            <P id=id_142>Программный код решения примера:</P>
            <DIV id=mark_142 class=lecture_mark></DIV>
            <DIV class=example><PRE>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;math.h&gt;

// Пртотип рекурсивной функции
void hanoi(int n,char a, char b, char c);

int main(void) 
{
     char a = 'A'; // исходное основание
     char b = 'B'; // конечное основание
     char c = 'C'; // промежуточное основание

	double n; // число дисков
	char str[81] = "15"; // инициализация строки

puts("\n Hanoi Tower; A - starting; B - end; C - intermediate");

	while (0.01) {       // 0.01 - как истинное значение
 		printf("\n Enter the number of disks: ");
		scanf_s(" %s",str, 80);
		n = atof(str);
		
		if ( n &lt;= 0 || ceil(n) != n) {
			printf("\n Error input. Press any key: ");
			_getch();
			continue;
		}

		else if (n &gt; 15.0) {
			printf("\n Very large number. Press any key: ");
			_getch();
			continue;
		}
		
         else
			break;
	}
	
     puts("\n Elementary transferences:");
	hanoi((int)n, a, b, c);

  
  printf("\n\n Press any key: ");
  _getch();
  return 0;
}

// Определение рекурсивной функции
void hanoi(int num, char a, char b, char c)
{
  if(num &gt; 0) {

    hanoi(num-1,a,c,b);

    printf("\t%c --&gt; %c\n",a,b);

    hanoi(num-1,c,b,a);

  }
  
}</PRE></DIV>
            <P id=id_144>Результат выполнения программы при n = 5 показан на <A 
            href="mhtml:file://D:\c_cpp\Лекции\5.Программирование на языке C №1\18. Лекция Рекурсивные алгоритмы и функции.mht#image.18.6">рис. 
            18.6</A>.</P>
            <DIV id=mark_144 class=lecture_mark></DIV>
            <P id=id_145 align=left><A name=image.18.6></A></P>
            <DIV><IMG alt="Перемещения дисков в Ханойской башне при n = 5" 
            src="Лекция_18_files/mhtA64A(1).tmp" width=620 
            height=495></DIV><BR><B>Рис. 18.6.</B>&nbsp; Перемещения дисков в 
            Ханойской башне при n = 5
            <P></P>
            <DIV id=mark_145 class=lecture_mark></DIV>
            <P id=id_146><B>Задание 4</B></P>
            <DIV id=mark_146 class=lecture_mark></DIV>
            <OL id=id_147>
              <LI>Определите тип рекурсии, используемой в программе.
              <LI>Для случая, когда не все элементарные перемещения выводятся на 
              экран дисплея, предусмотрите вывод результата программы в 
              текстовый файл с именем compX.txt, где X – номер компьютера, на 
              котором выполняется лабораторная работа.
              <LI>Программным путем выполните подсчет общего количества 
              обращений к рекурсивной функции. Сделайте также вывод порядкового 
              номера перемещения на экран дисплея. Порядковый номер расположите 
              слева от элементарного перемещения. Построить (в MS Excel или в 
              MATLAB) зависимость количества обращений к рекурсивной функции от 
              заданного числа дисков.
              <LI>Измените аргументы рекурсивной функции: включить переменные 
              типа <SPAN class=texample>int</SPAN> для определения имени 
              (нумерации) основания.
              <LI>Измените условие задачи "Ханойская башня". Сначала исходным 
              основанием считать В, конечным С, промежуточным А. Затем принять 
              за исходное основание С, промежуточным В, конечным А.</LI></OL>
            <DIV id=mark_147 class=lecture_mark></DIV>
            <P id=id_154><B>Пример 5</B>. "Задача о рюкзаке". Есть 10 предметов, 
            о которых известны их веса и стоимости. Требуется поместить в рюкзак 
            предметы таким образом, чтобы они не превысили допустимый вес для 
            рюкзака при максимальной стоимости выбранных предметов. Исходные 
            параметры модели – характеристики предметов взяты из [11] и 
            приведены в <A 
            href="mhtml:file://D:\c_cpp\Лекции\5.Программирование на языке C №1\18. Лекция Рекурсивные алгоритмы и функции.mht#table.18.1">табл. 
            18.1</A>.</P>
            <DIV id=mark_154 class=lecture_mark></DIV>
            <DIV id=id_155 class=xml_table_env><A name=table.18.1></A>
            <TABLE class=xml_table cellSpacing=1 cellPadding=2 border=0>
              <CAPTION>Таблица 18.1. </CAPTION>
              <TBODY>
              <TR>
                <TD bgColor=#eaeaea vAlign=top colSpan=11>Характеристики 
                  предметов</TD></TR>
              <TR>
                <TD bgColor=#eaeaea vAlign=top>№ п/п</TD>
                <TD bgColor=#eaeaea vAlign=top>1</TD>
                <TD bgColor=#eaeaea vAlign=top>2</TD>
                <TD bgColor=#eaeaea vAlign=top>3</TD>
                <TD bgColor=#eaeaea vAlign=top>4</TD>
                <TD bgColor=#eaeaea vAlign=top>5</TD>
                <TD bgColor=#eaeaea vAlign=top>6</TD>
                <TD bgColor=#eaeaea vAlign=top>7</TD>
                <TD bgColor=#eaeaea vAlign=top>8</TD>
                <TD bgColor=#eaeaea vAlign=top>9</TD>
                <TD bgColor=#eaeaea vAlign=top>10</TD></TR>
              <TR>
                <TD bgColor=#eaeaea vAlign=top>Вес</TD>
                <TD bgColor=#eaeaea vAlign=top>10</TD>
                <TD bgColor=#eaeaea vAlign=top>11</TD>
                <TD bgColor=#eaeaea vAlign=top>12</TD>
                <TD bgColor=#eaeaea vAlign=top>13</TD>
                <TD bgColor=#eaeaea vAlign=top>14</TD>
                <TD bgColor=#eaeaea vAlign=top>15</TD>
                <TD bgColor=#eaeaea vAlign=top>16</TD>
                <TD bgColor=#eaeaea vAlign=top>17</TD>
                <TD bgColor=#eaeaea vAlign=top>18</TD>
                <TD bgColor=#eaeaea vAlign=top>19</TD></TR>
              <TR>
                <TD bgColor=#eaeaea vAlign=top>Стоимость</TD>
                <TD bgColor=#eaeaea vAlign=top>18</TD>
                <TD bgColor=#eaeaea vAlign=top>20</TD>
                <TD bgColor=#eaeaea vAlign=top>17</TD>
                <TD bgColor=#eaeaea vAlign=top>19</TD>
                <TD bgColor=#eaeaea vAlign=top>25</TD>
                <TD bgColor=#eaeaea vAlign=top>21</TD>
                <TD bgColor=#eaeaea vAlign=top>27</TD>
                <TD bgColor=#eaeaea vAlign=top>23</TD>
                <TD bgColor=#eaeaea vAlign=top>25</TD>
                <TD bgColor=#eaeaea vAlign=top>24</TD></TR></TBODY></TABLE></DIV>
            <DIV id=mark_155 class=lecture_mark></DIV>
            <P id=id_156>Данная задача широко известна [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#22" 
            target=_blank>18.9</A>-<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#23" 
            target=_blank>18.10</A>-<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#24" 
            target=_blank>18.11</A>], она еще называется задачей о ранце, или 
            вариант с английского – "knapsack problem". Предполагается, что один 
            и тот же предмет не может быть взят несколько раз.</P>
            <DIV id=mark_156 class=lecture_mark></DIV>
            <P id=id_157>Для решения поставленной задачи используем рекурсивный 
            алгоритм, описанный в [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#24" 
            target=_blank>18.11</A>], где также приводится фрагмент программы на 
            языке программирования MODULA – 2.</P>
            <DIV id=mark_157 class=lecture_mark></DIV>
            <P id=id_158>Программный код решения примера:</P>
            <DIV id=mark_158 class=lecture_mark></DIV>
            <DIV class=example><PRE>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;ocale.h&gt;

const int limW = 20; // предельный вес выбранных предметов
enum {N = 10}; // количество предметов

typedef struct {
	int weight; //// вес или размер предметов
	int value; //// стоимость или ценность предметов
} object;

// Формирование структурного типа с параметрами модели
object obj[] = {10,18, 11,20, 12,17, 13,19, 14,25, 15,21, 16,27, 17,23, 18,25, 19,24};

int maxv; // для инициализации стоимости предметов

// Рекурсивная функция
int TRY (int i, int tw, int av) {
	// Попытка включения предмета
	if (tw + obj[i].weight &lt;= limW) 
		if (i &lt; N-1) 
			TRY(i+1, tw + obj[i].weight, av );
		   
          else if (av &gt; maxv) 
			maxv = av;
		// Попытка исключения предмета
	if (av &gt; maxv + obj[i].value) 
		if (i &lt; N-1) 
			TRY(i+1, tw, av - obj[i].value);
		else 
			maxv = av - obj[i].value;
	return maxv;	
}

// Главная функция программы
int main (void) {
	int i, price;
	int sumw = 0;
	int sumv = 0;
	setlocale(LC_ALL, "rus");

	maxv = obj[0].value; // инициализации стоимости предметов
	puts("\n\t\t\tЗАДАЧА О РЮКЗАКЕ");
	puts("\t\t  Характеристика предметов");
	for (i = 0; i &lt; (4*N + 12); i++)
		printf("%s", "_");

	printf("\n\n %12s", "Вес:");
	for (i = 0; i &lt; N; i++) {
		sumw += obj[i].weight;
		printf(" %3d", obj[i].weight); }

	printf("\n %12s", "Стоимость:");
	for (i = 0; i &lt; N; i++) {
		sumv += obj[i].value;
		printf(" %3d", obj[i].value); }
	printf("\n ");
	for (i = 0; i &lt; (4*N + 12); i++)
		printf("%s", "_");

printf("\n\n %32s: %d\n", "Общий вес всех предметов", sumw);
printf(" %32s: %d\n", "Общая стоимость всех предметов", sumv);
	printf(" %32s: %d\n ", "Допустимый вес рюкзака", limW);
	     for (i = 0; i &lt; (4*N + 12); i++)
      printf("%s", "_");
	// Вызов рекурсивной функции с начальными параметрами
	price = TRY(0,0,sumv);
printf("\n\n  Стоимость выбранных предметов: %d\n ", price );
	for (i = 0; i &lt; (4*N + 12); i++)
		printf("%s", "_");

	printf("\n\n ... Нажмите любую клавишу: ");
	_getch();
	return 0;
}</PRE></DIV>
            <P id=id_160>Пример выполнения программы показан на <A 
            href="mhtml:file://D:\c_cpp\Лекции\5.Программирование на языке C №1\18. Лекция Рекурсивные алгоритмы и функции.mht#image.18.7">рис. 
            18.7</A>.</P>
            <DIV id=mark_160 class=lecture_mark></DIV>
            <P id=id_161 align=left><A name=image.18.7></A></P>
            <DIV><IMG alt="Пример выполнения программы решения задачи о рюкзаке" 
            src="Лекция_18_files/mhtA66C(1).tmp" width=620 
            height=256></DIV><BR><B>Рис. 18.7.</B>&nbsp; Пример выполнения 
            программы решения задачи о рюкзаке
            <P></P>
            <DIV id=mark_161 class=lecture_mark></DIV>
            <P id=id_162>Представленная программа основана на следующем 
            алгоритме [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#24" 
            target=_blank>18.11</A>]. В рекурсивной функции <SPAN 
            class=texample>TRY()</SPAN> определены две ситуации для выбора 
            предмета в рюкзак. Если речь идет о включении то объект (предмет со 
            своим весом и стоимостью) можно включить в выборку для укладки в 
            рюкзак, если он подходит по весовым ограничениям. Если он не 
            подходит, то попытки добавить еще один объект в текущую выборку 
            можно прекратить. Когда же речь идет об исключении, то критерием 
            приемлемости, т. е. возможности продолжения построения текущей 
            выборки, будет то, что после данного исключения общая ценность 
            (стоимость) будет не меньше полученного до этого момента оптимума. В 
            данной программе реализована схема с возвратами, использующая 
            некоторые ограничения для уменьшения роста потенциального дерева 
            поиска, называется алгоритмом ветвей и границ [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#24" 
            target=_blank>18.11</A>].</P>
            <DIV id=mark_162 class=lecture_mark></DIV>
            <P id=id_164><B>Задание 5</B></P>
            <DIV id=mark_164 class=lecture_mark></DIV>
            <OL id=id_165>
              <LI>Подсчитайте количество рекурсивных вызовов функции <SPAN 
              class=texample>TRY()</SPAN> в зависимости от величины допустимого 
              веса рюкзака, начиная от 10 до 120 с шагом в 10 условных единиц. 
              Постройте график полученной зависимости (в MS EXCEL или в MATLAB).
              <LI>Рекурсивную функцию <SPAN class=texample>TRY()</SPAN> 
              расположите в отдельном файле с именем compX.c, где Х – номер 
              компьютера, на котором выполняется лабораторная работа.
              <LI>Сформирйте массив данных о предметах по случайному 
              равномерному закону из интервала [10; 20*Х], где Х – номер 
              компьютера, на котором выполняется лабораторная работа. Размер 
              массива выберите случайно из следующего интервала натуральных 
              чисел: [10; 18].
              <LI>В программу внесите изменения, которые бы позволили определить 
              номера предметов, отобранные в рюкзак. Соответственно укажите вес 
              и стоимость каждого предмета.</LI></OL>
            <DIV id=mark_165 class=lecture_mark></DIV>
            <P id=id_172><B>Пример 6</B>. Напишите программу сортировки 
            одномерного массива целых чисел на основе рекурсивного алгоритма 
            быстрой сортировки Хоара.</P>
            <DIV id=mark_172 class=lecture_mark></DIV>
            <P id=id_173>Суть алгоритма быстрой сортировки заключается в 
            следующем. Выбираем наугад какой-либо элемент х исходного массива. 
            Будем просматривать слева наш массив до тех пор, пока не встретим 
            элемент a<SUB>i</SUB> &gt; x, затем будем просматривать массив 
            справа, пока не встретим <IMG 
            style="POSITION: relative; DISPLAY: inline; TOP: 5px" 
            alt="a_i \leqslant х" src="Лекция_18_files/mhtA68E(1).tmp" width=52 
            height=18>. Поменяем местами эти два элемента и продолжим процесс 
            просмотра и обмена до тех пор, пока оба просмотра не встретятся. В 
            результате исходный массив окажется разбитым на две части, левая 
            часть будет содержать элементы меньше или равные х, а правая часть – 
            элементы больше х. Применив эту процедуру разделения к левой и 
            правой частям массива от точки встречи, получим четыре части и т. 
            д., пока в каждой части окажется только один элемент [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#6" 
            target=_blank>18.12</A>]. В качестве граничного элемента х для 
            разделения обычно выбирают средний элемент массива.</P>
            <DIV id=mark_173 class=lecture_mark></DIV>
            <P id=id_175>Программный код решения примера:</P>
            <DIV id=mark_175 class=lecture_mark></DIV>
            <DIV class=example><PRE>/* Быстрая сортировка Хоара.
* Рекурсивный вариант.
*/

#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;

// Массив, подлежащий сортировке по возрастанию
int A[] = {1, 5, 7, -5, 0, 12, 8, 5, 4, -10, 3, 6, 18};

// Прототип рекурсивной функции
void Quick_Sort(int A[], int L, int R);

int main (void) {
	int i;
	int N;

	N = sizeof(A)/sizeof(A[0]);

	puts("\n\t\t QUICK SORT");
	printf("\n\t The original array of size %d:\n ", N);
	for (i = 0; i &lt; N; i++)
		printf(" %3d ", A[i]);
     
// Вызов рекурсивной функции сортировки
	Quick_Sort(A, 0, N-1);

	printf("\n\n\t The sorting array:\n ");
	for (i = 0; i &lt; N; i++)
		printf(" %3d ", A[i]);

	printf("\n\n ... Press any key: ");
	_getch();
	return 0;
}
// Определение рекурсивной функции
void Quick_Sort(int A[], int L, int R) {
	int i, j, k;
	int x; // граничный элемент для разделения массива
	i = L;
	j = R;
	x = A[(int)(L + R)/2];
	do { while (A[i] &lt; x)
		i++;
	while (x &lt; A[j])
		j--;
	if (i &lt;= j) {
		k = A[i]; A[i] = A[j]; A[j] = k;
		i++; j--;
	}
	} while (i &lt; j);

	if (L &lt; j)
		Quick_Sort(A, L, j);

	if (i &lt; R)
		Quick_Sort(A, i, R); 
}</PRE></DIV>
            <P id=id_177>Пример выполнения программы показан на <A 
            href="mhtml:file://D:\c_cpp\Лекции\5.Программирование на языке C №1\18. Лекция Рекурсивные алгоритмы и функции.mht#image.18.8">рис. 
            18.8</A>.</P>
            <DIV id=mark_177 class=lecture_mark></DIV>
            <P id=id_178 align=left><A name=image.18.8></A></P>
            <DIV><IMG alt="Пример быстрой сортировки одномерного массива" 
            src="Лекция_18_files/mhtA6B0(1).tmp" width=620 
            height=151></DIV><BR><B>Рис. 18.8.</B>&nbsp; Пример быстрой 
            сортировки одномерного массива
            <P></P>
            <DIV id=mark_178 class=lecture_mark></DIV>
            <P id=id_179><B>Задание 6</B></P>
            <DIV id=mark_179 class=lecture_mark></DIV>
            <OL id=id_180>
              <LI>В программу внесите изменения для сортировки вещественных 
              данных.
              <LI>В программу внесите изменения для сортировки массива по 
              убыванию.
              <LI>Рекурсивную функцию программы разместите во внешнем файле с 
              именем compX.c, где Х – номер компьютера, на котором выполняется 
              лабораторная работа.
              <LI>4Размерность массива, подлежащего сортировке, и данные массива 
              задайте случайно из интервалов [10; 100] и [10Х; 50Х], где Х – 
              номер компьютера, на котором выполняется лабораторная работа.
              <LI>Подсчитайте количество рекурсивных вызовов при сортировке 
              массивов, задаваемых случайным образом.</LI></OL>
            <DIV id=mark_180 class=lecture_mark></DIV>
            <P id=id_186><B>Пример 7</B>. Напишите программу сортировки 
            одномерного массива целых чисел на основе рекурсивного алгоритма 
            слиянием.</P>
            <DIV id=mark_186 class=lecture_mark></DIV>
            <P id=id_187>При алгоритме слиянием сортировку производят по частям, 
            а затем соединяют отдельные части в единое целое [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#21" 
            target=_blank>18.5</A>].</P>
            <DIV id=mark_187 class=lecture_mark></DIV>
            <P id=id_188>Выберем следующую схему разбиения данных. Будем 
            разрезать массив данных на две равные части, образуя два подмассива. 
            Затем сортировка слиянием рекурсивно вызывает себя для каждого из 
            двух подмассивов. Конечным шагом является слияние двух сортированных 
            подмассивов в один сортированный массив [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#13" 
            target=_blank>18.13</A>].</P>
            <DIV id=mark_188 class=lecture_mark></DIV>
            <P id=id_189>Особенностью алгоритма слиянием является то, что при 
            сортировке требуется временный массив для результата.</P>
            <DIV id=mark_189 class=lecture_mark></DIV>
            <P id=id_190>Алгоритм сортировки слиянием может быть использован при 
            сортировке внешних данных, например данных, записанных в отдельные 
            файлы [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#21" 
            target=_blank>18.5</A>].</P>
            <DIV id=mark_190 class=lecture_mark></DIV>
            <P id=id_191>Программный код решения примера:</P>
            <DIV id=mark_191 class=lecture_mark></DIV>
            <DIV class=example><PRE>#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;stdlib.h&gt;

// Заданный произвольный числовой массив
int A[] = {9, 3, 4, 5, 8, 1, 0, 3, 2, -3, 12, 10, -7, 8};

// Основная функция сортировки, merge - сливать, соединять
void merge (int arr[],int *temp,int start,int mid,int end)
 {
	int i = 0; // для временного массива
	int i_lower = start;
	int i_upper = mid + 1;
	int i_arr = start;

	// Пока ни один из подмассивов не пуст
	while ( (i_lower &lt;= mid) &amp;&amp; (i_upper &lt;= end) ) {
		if (arr[i_lower] &lt; arr[i_upper])
			temp[i++] = arr[i_lower++];
		else
			temp[i++] = arr[i_upper++];
	} // end while

	// Случай, когда в одном из подмассивов остались элементы
	   if (i_lower &lt;= mid) {
		// assert (i_upper &gt; end);
		for ( ; i_lower &lt;= mid; temp[i++] = arr[i_lower++]);
	}
	   else 
	for ( ; i_upper &lt;= end; temp[i++] = arr[i_upper++]) ;
	// Когда размер массива равен end - start + 1
		if (i == end - start + 1)
	for ( i = 0; i_arr &lt;= end;  arr[i_arr++] = temp[i++]) ;
} // end merge

// Рекурсивная сортировка подмассивов
void sub (int arr[], int *temp, int head, int tail ) {
	// head - голова
	// tail - хвост
	int mid;
	if (head &gt;= tail)
		return;
	if (tail &gt; head) {
		// Средняя точка массива
		mid = (head + tail) / 2;
		// assert ( (mid &gt;= head) &amp;&amp; (mid &lt;= tail) );
		if (mid &gt;= head &amp;&amp; mid &lt;= tail) {
			// Сортировка подмассивов
			sub (arr, temp, head, mid);
			sub (arr, temp, mid+1, tail);
			// Объединение результатов
			merge (arr, temp, head, mid, tail);
		}
	}
} // end sub

// Функция как интерфейс, для удобства вызова программы
void merge_sort (int arr[], int size)  {
	int head = 0;
	int tail = size - 1;
	int *temp;
	temp = (int *) malloc (size*sizeof(int)); 
	sub (arr, temp, head, tail);
	free(temp);
} 

int main (void) {
	int i;
	int N;

	N = sizeof(A)/sizeof(A[0]);
	// Вывод на консоль исходного массива
	printf("\n\t The original array of size %d:\n ", N);
	for (i = 0; i &lt; N; i++)
		printf(" %2d", A[i]);

	// Вызов функции для сортировки массива
	merge_sort (A, N);
	// Вывод на консоль отсортированного массива
	printf("\n\n\t After sorting:\n ");
	for (i = 0; i &lt; N; i++)
		printf(" %2d", A[i]);

	printf("\n\n ... Press any key: ");
	_getch();
	return 0;
}</PRE></DIV>
            <P id=id_193>Пример выполнения программы показан на <A 
            href="mhtml:file://D:\c_cpp\Лекции\5.Программирование на языке C №1\18. Лекция Рекурсивные алгоритмы и функции.mht#image.18.9">рис. 
            18.9</A>.</P>
            <DIV id=mark_193 class=lecture_mark></DIV>
            <P id=id_194 align=left><A name=image.18.9></A></P>
            <DIV><IMG alt="Пример сортировки слиянием одномерного массива" 
            src="Лекция_18_files/mhtA6C3(1).tmp" width=620 
            height=116></DIV><BR><B>Рис. 18.9.</B>&nbsp; Пример сортировки 
            слиянием одномерного массива
            <P></P>
            <DIV id=mark_194 class=lecture_mark></DIV>
            <P id=id_195>В алгоритме сортировки слиянием можно выделить три 
            этапа.</P>
            <DIV id=mark_195 class=lecture_mark></DIV>
            <OL id=id_196>
              <LI>Сортируемый массив разбивается на две половины примерно 
              одинакового размера.
              <LI>Каждая из получившихся половин сортируется отдельно 
              (каким-либо известным алгоритмом, в том числе и с помощью 
              алгоритма слиянием ).
              <LI>Два упорядоченных массива половинного размера соединяются в 
              один. Рекурсивное разбиение заданного массива происходит до тех 
              пор, пока размер массива не достигнет единицы. Далее решается 
              задача – нетривиальная задача – соединение двух упорядоченных 
              массивов в один.</LI></OL>
            <DIV id=mark_196 class=lecture_mark></DIV>
            <P id=id_200>Алгоритм сортировки слиянием был изобретен Джоном фон 
            Нейманом в 1945 г.</P>
            <DIV id=mark_200 class=lecture_mark></DIV>
            <P id=id_201>Сортировка слиянием считается предпочтительной в 
            случае, когда требуется застраховаться от наихудшего случая, 
            возможного при использовании быстрой сортировки [<A 
            href="http://www.intuit.ru/department/pl/prcmsvs2010/popup.lit.html#6" 
            target=_blank>18.12</A>].</P>
            <DIV id=mark_201 class=lecture_mark></DIV>
            <P id=id_202><B>Задание 7</B></P>
            <DIV id=mark_202 class=lecture_mark></DIV>
            <OL id=id_203>
              <LI>Все вспомогательные функции программы разместите во внешние 
              файлы с именами compX_1.c, compX_2.c и т. д., где Х – номер 
              компьютера, на котором выполняется лабораторная работа (1, 2, 
              ...). Протестируйте программу на контрольном примере. Подсчитайте 
              количество рекурсивных вызовов.
              <LI>Подготовьте два не отсортированных массива и произведите их 
              слияние в один отсортированный массив. Данные массивов задаются 
              случайно по равномерному закону из интервалов [–5Х; 5Х] и [0; 
              10Х], где Х – номер компьютера, на котором выполняется 
              лабораторная работа (1, 2,...). Размерности массивов должны 
              задаваться с клавиатуры из интервала [10; 20].
              <LI>Напишите программу по сортировке слиянием двух массивов, 
              расположенных в текстовых файлах (внешняя сортировка слиянием). 
              Результат сортировки разместите также в текстовый файл с именем 
              compX.txt, где Х – номер компьютера, на котором выполняется 
              лабораторная работа.</LI></OL>
            <DIV id=mark_203 class=lecture_mark></DIV><A name=sect3></A>
            <H3>Контрольные вопросы</H3>
            <OL id=id_207>
              <LI>Когда следует применять рекурсивные алгоритмы?
              <LI>Какие известны методы и приемы устранения "хвостовой" 
рекурсии?
              <LI>Какие проблемы могут возникать при реализации рекурсивных 
              алгоритмов на электронных вычислительных машинах?
              <LI>В чем отличие глубины рекурсии от рекурсивного вызова?
              <LI>Какие задачи в программировании можно назвать, где применение 
              рекурсии оправдано?</LI></OL>
            <DIV id=mark_207 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG src="Лекция_18_files/mhtA513(1).tmp" width=1 
            height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG src="Лекция_18_files/mhtA513(1).tmp" width=8 
  height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG src="Лекция_18_files/mhtA513(1).tmp" width=1 
      height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript src="">
</SCRIPT>

<SCRIPT 
type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
