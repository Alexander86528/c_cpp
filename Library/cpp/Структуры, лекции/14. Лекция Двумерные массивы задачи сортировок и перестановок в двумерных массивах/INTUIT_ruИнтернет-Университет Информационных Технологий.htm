<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0071)http://www.intuit.ru/department/algorithms/staldata/14/staldata_14.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/printable.css">
<META name=GENERATOR content="MSHTML 9.00.8080.16413"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="COLOR: #000000; FONT-WEIGHT: bold">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD>
    <TD><!-- content -->
      <TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD class=head>Структуры и алгоритмы компьютерной обработки 
        данных</TD></TR>
        <TR>
          <TD height=4><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>14. Лекция: Двумерные массивы: задачи 
            сортировок и перестановок в двумерных массивах: версия для печати и 
            PDA</SPAN> <BR><SPAN class=rtxt>В лекции рассматриваются типовые 
            задачи на обработку двумерных массивов, приводятся примеры 
            алгоритмизации задач сортировок и перестановок в двумерных массивах. 
            </SPAN></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3></H3>
            <P id=id_1><B>Цель лекции:</B> изучить особенности применения 
            алгоритмов сортировок и перестановок в двумерных массивах, научиться 
            решать задачи сортировок и перестановок в двумерных массивах на 
            языке C++.</P>
            <DIV id=mark_1 class=lecture_mark></DIV>
            <P id=id_2>В виде двумерных массивов удобно представлять объекты, 
            элементы которых принадлежат одному типу и расположены в виде 
            таблицы. Например, матрицы коэффициентов систем линейных уравнений, 
            функциональные зависимости, линейные операторы, матрицу системы 
            ограничений в задачах минимизации или максимизации, 
            экспериментальные данные и т.д. При решении прикладных задач над 
            элементами двумерных массивов бывает необходимо выполнить однотипные 
            действия. Например, при решении систем линейных уравнений методом 
            Гаусса требуется производить многократные перестановки строк. Для 
            выполнения поиска в двумерных массивах данные бывает удобно 
            упорядочить по определенному ключу, что также предполагает 
            перестановки.</P>
            <DIV id=mark_2 class=lecture_mark></DIV>
            <P id=id_3>Однако, по сравнению с одномерными массивами, в матрицах 
            перестановки и сортировки имеют немного другой смысл и алгоритм 
            выполнения.</P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <P id=id_4>В силу особенности представления двумерных массивов в 
            виде таблиц смысл сортировки такого массива сводится к 
            упорядочиванию элементов, объединенных в столбцы или строки. 
            Например, сортировка по убыванию элементов столбцов означает, что 
            элементы следует расположить по убыванию сверху вниз в каждом 
            столбце отдельно. При этом, рассматривая строку или столбец как 
            одномерный массив, к ним применяют алгоритмы сортировок одномерных 
            массивов.</P>
            <DIV id=mark_4 class=lecture_mark></DIV>
            <P id=id_5><SPAN class=xml_em_italic>Пример 1</SPAN>. Сортировка в 
            двумерном целочисленном массиве элементов k-той строки по 
            невозрастанию.</P>
            <DIV id=mark_5 class=lecture_mark></DIV>
            <DIV class=example><PRE>void sort_dn(int k,int slb,  int m[max][max]) {  
  int i,j,buf; 
  for (i=0;i&lt;slb;i++)
    for (j=slb-1;j&gt;i;j--)
      if (m[k][j]&gt;m[k][j-1]){
      //фиксированная строка с номером k 
           buf= m[k][j];
           m[k][j]= m[k][j-1];
           m[k][j-1]=buf; 
           } 
}
</PRE></DIV>
            <P id=id_7>Для поиска максимальных (минимальных) элементов с целью 
            их дальнейшего упорядочивания удобно выделять отдельно одномерный 
            массив, в котором хранить не значения элементов, а номера столбцов 
            или строк, в которых они располагаются. Например, чтобы найти 
            минимальные элементы в каждом столбце массива <SPAN class=texample>n 
            &#215; m</SPAN> отдельно, удобно выделить одномерный массив <SPAN 
            class=texample>min[m]</SPAN>, в котором число элементов равно числу 
            столбцов. Значениями элементов такого массива будут номера строк, в 
            которых располагаются минимальные элементы каждого столбца. Если же 
            минимальных элементов в столбце несколько, то будет найден первый 
            (или последний) минимальный, что не скажется на значении.</P>
            <DIV id=mark_7 class=lecture_mark></DIV>
            <P id=id_10><SPAN class=xml_em_italic>Пример 2</SPAN>. Поиск номеров 
            минимальных элементов в каждом столбце двумерного массива.</P>
            <DIV id=mark_10 class=lecture_mark></DIV>
            <DIV class=example><PRE>void minimum(int str,int slb, int m[max][max],int min[max]){
  int i,j; 
  for (j=0;j&lt;slb;j++){//фиксируем номер столбца
    min[j]=0;
    for (i=1;i&lt;str;i++)
    //пробег по столбцу, меняется номер строки
      if (m[i][j]&lt;m[min[j]][j])  min[j]=i;  
  }
}
</PRE></DIV>
            <P id=id_12>В данном примере <SPAN class=texample>min[max_y]</SPAN> 
            – это массив, значениями которого будут <SPAN 
            class=xml_em_italic>номера</SPAN> строк, в которых располагается 
            первый минимальный элемент столбца. Так для <SPAN 
            class=texample>min[j]</SPAN> начальное значение инициализируется как 
            0, то есть предполагается, что минимальный элемент расположен в 
            строке с номером 0. Обращение <SPAN 
            class=texample>m[min[j]][j]</SPAN> понимается так: элемент массива 
            <SPAN class=texample>m</SPAN>, расположенный в строке с номером 
            <SPAN class=texample>min[j]</SPAN> и столбце с номером <SPAN 
            class=texample>j</SPAN>. Но в строке <SPAN 
            class=texample>min[j]</SPAN> для столбца <SPAN 
            class=texample>j</SPAN> как раз и находится минимальный элемент.</P>
            <DIV id=mark_12 class=lecture_mark></DIV>
            <P id=id_21>В задачах на перестановку отдельных элементов массива, 
            столбцов или строк используется алгоритм обмена значениями двух 
            переменных через третью переменную (возможны и другие способы обмена 
            значениями двух переменных).</P>
            <DIV id=mark_21 class=lecture_mark></DIV>
            <P id=id_22><SPAN class=xml_em_italic>Пример 3</SPAN>. Обмен 
            значениями элементов диагоналей квадратной матрицы, расположенных в 
            одной строке.</P>
            <DIV id=mark_22 class=lecture_mark></DIV>
            <DIV class=example><PRE>void obmen(int strslb, int m[max][max]) {  
  int i,buf,t; 
  for (i=0;i&lt;strslb;i++){       
  //номера строки и столбца элемента главной диагонали равны
    buf= m[i][i];
    //t-номер столбца соответствующего элемента побочной диагонали
    t= abs(strslb-i-1);
    m[i][i]= m[i][t];
    m[i][t]=buf; 
  }
}
</PRE></DIV>
            <P id=id_24><SPAN class=xml_em_italic>Пример 4</SPAN>. Дана 
            квадратная матрица размера <SPAN class=texample>n &#215; n</SPAN>, 
            заполненная с клавиатуры целыми числами так, что в каждой строке и 
            каждом столбце ровно по одному нулевому элементу. Переставьте строки 
            матрицы так, чтобы нулевые элементы были расположены вдоль главной 
            диагонали. Выведите массив на экран в виде таблицы дважды – до и 
            после перестановки. Оформите генерацию, вывод массива и перестановку 
            строк с помощью функций.</P>
            <DIV id=mark_24 class=lecture_mark></DIV>
            <DIV class=example><PRE>#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
#define max 10

void gen (int k,int x[max][max]);
void out (int k,int x[max][max]);
void change (int k,int x[max][max]);

int _tmain(int argc, _TCHAR* argv[]) {
  int a[max][max];
  int n; 
  do {
    printf("\nВведите количество элементов массива n (n&lt;=%d):",
            max);
    scanf ("%d",&amp;n);
  }
  while (n&gt;max);
  gen(n,a);
  out(n,a);
  change(n,a);
  out(n,a);
  system("pause");
  return 0;
}

void gen (int k,int x[max][max]){
  int i,j;
  for (i=0;i&lt;k;i++){
     printf("\nВведите значения элементов %d-й строки 
             массива: \n",i); 
    for (j=0;j&lt;k;j++){
      printf("x[%d][%d]= ",i,j);
      scanf("%d",&amp;x[i][j]);
     }
   }  
}

void out (int k,int x[max][max]){
  int i,j;
  printf("\nВывод значений %d элементов массива в строку: \n",k); 
  for (i=0;i&lt;k;i++) {
     for (j=0;j&lt;k;j++)
       printf("\t%d",x[i][j]);
     printf("\n");
   }
}

void change (int k,int x[max][max]){
 int i,j,buf; 
 int zero[max]; //массив номеров столбцов нулевых элементов
 for (i=0;i&lt;k;i++) //инициализация массива
    zero[i] = -1;
 for (i=0;i&lt;k;i++) 
   for (j=0;j&lt;k;j++)
   /*генерация массива номерами столбцов, в которых 
     расположены нулевые элементы*/
    if (x[i][j]==0) {
      zero[i]=j;
      j=k;
    }
  for (i=0;i&lt;k;i++) 
   for (j=0;j&lt;k;j++){
   /*обмен значениями элементов текущей строки с 
     соответствующей, чтобы нулевой элемент занял место на 
     главной диагонали*/
      buf=x[i][j];
      x[i][j]=x[zero[i]][j];
      x[zero[i]][j]=buf; 
   /*после перестановки строк изменяется номер столбца  
     нулевого элемента*/
      zero[zero[i]]=zero[i];
    }
}
</PRE></DIV>
            <P id=id_27>В данном примере <SPAN class=texample>zero[max]</SPAN> – 
            это массив, значениями которого будут номера столбцов, в которых 
            располагается нулевой каждой строки (по условию задачи, такой 
            элемент в каждом столбце и каждой строке единственный). Обращение 
            <SPAN class=texample>x[zero[i]][j]</SPAN> понимается так: элемент 
            массива <SPAN class=texample>x</SPAN>, расположенный в строке с 
            номером <SPAN class=texample>zero[i]</SPAN> и столбце с номером 
            <SPAN class=texample>j</SPAN>. Но для строки с номером <SPAN 
            class=texample>i</SPAN> нулевой элемент располагается в столбце с 
            номером <SPAN class=texample>zero[i]</SPAN>. Для каждого элемента 
            главной диагонали индексы строки и столбца равны, поэтому нулевой 
            элемент из столбца <SPAN class=texample>zero[i]</SPAN> должен быть 
            перемещен в строку с аналогичным номером (вместе со всеми элементами 
            этой же строки). Обращение <SPAN class=texample>zero[zero[i]]</SPAN> 
            означает, что после перестановки строк с номерами <SPAN 
            class=texample>i</SPAN> и <SPAN class=texample>zero[i]</SPAN> 
            нулевой элемент строки <SPAN class=texample>zero[i]</SPAN> будет 
            находиться в столбце с номером <SPAN 
            class=texample>zero[zero[i]]</SPAN>.</P>
            <DIV id=mark_27 class=lecture_mark></DIV>
            <P id=id_41>В языке С++ могут объявляться и использоваться в 
            программах массивы, измерение которых больше двух. Такие массивы 
            называют <SPAN class=xml_em_italic>многомерными</SPAN>. Ограничения 
            на число измерений массива зависит от реализации. Индексация 
            многомерных массивов производится по каждому измерению в 
            отдельности. Например, объявление трехмерного вещественного массива 
            оформляется так:</P>
            <DIV id=mark_41 class=lecture_mark></DIV>
            <DIV class=example><PRE>float mass[max_x][max_y][max_z];
</PRE></DIV>
            <P id=id_43>При объявлении многомерного массива формируется массив 
            указателей на массивы, измерение которых на единицу меньше. Такое 
            объявление рекурсивно сводится к массивам указателей на одномерные 
            массивы. </P>
            <DIV id=mark_43 class=lecture_mark></DIV>
            <P id=id_44>Инициализация многомерных массивов во многом аналогична 
            инициализации двумерных массивов и производится с учетом всех 
            измерений. Обращение к элементам таких массивов возможна также через 
            индексированное имя или с помощью адресной арифметики с 
            указателями.</P>
            <DIV id=mark_44 class=lecture_mark></DIV>
            <P id=id_45>При обходе многомерных массивов в программах 
            используются кратные циклы, каждый из которых пробегает по своему 
            индексу. При организации обхода следует учитывать, что индекс 
            внешнего цикла меняется медленнее остальных индексов кратных циклов. 
            </P>
            <DIV id=mark_45 class=lecture_mark></DIV>
            <P id=id_46>Массивы слишком больших измерений неудобны в 
            использовании, так как громоздки в объявлении и обращении, их 
            индексация требует дополнительных затрат памяти, что увеличивает 
            время выполнения программы.</P>
            <DIV id=mark_46 class=lecture_mark></DIV><A name=sect2></A>
            <H3>Ключевые термины</H3>
            <P id=id_47><B>Задачи перестановок в двумерных массивах</B> – это 
            тип задач, предполагающий обмен значениями элементов массива в 
            зависимости от условия.</P>
            <DIV id=mark_47 class=lecture_mark></DIV>
            <P id=id_48><B>Задачи сортировок в двумерных массивах</B> – это тип 
            задач, предполагающий упорядочивание по указанному ключу одномерных 
            массивов, из которых построен двумерный массив.</P>
            <DIV id=mark_48 class=lecture_mark></DIV>
            <P id=id_49><B>Многомерные массивы</B> – это массивы с измерением 
            больше единицы.</P>
            <DIV id=mark_49 class=lecture_mark></DIV><A name=sect3></A>
            <H3>Краткие итоги</H3>
            <OL id=id_50>
              <LI>Задачи обработки двумерных массивов имеют широкое прикладное 
              значение.
              <LI>Задачи на использование массивов можно классифицировать в 
              зависимости от вида обработки его элементов.
              <LI>Задачи перестановок предполагают перемещение элементов в 
              массиве на заданные позиции. При этом сами значения элементов не 
              изменяются.
              <LI>В задачах сортировок двумерных массивов упорядочиваются по 
              указанному ключу одномерные массивы, из которых построены матрицы.
              <LI>При обходе двумерных массивов используют кратные циклы, каждый 
              из которых пробегает по конкретному измерению. 
              <LI>В С++ предусмотрено использование многомерных массивов.
              <LI>Массивы слишком больших измерений неудобны в использовании в 
              программах.</LI></OL>
            <DIV id=mark_50 class=lecture_mark></DIV><A name=sect4></A>
            <H3>Лабораторная работа 14. Двумерные массивы: задачи сортировок и 
            перестановок в двумерных массивах</H3>
            <P id=id_58><B>Цель работы:</B> изучить особенности применения 
            алгоритмов сортировок и перестановок в двумерных массивах, научиться 
            решать задачи сортировок и перестановок в двумерных массивах на 
            языке C++.</P>
            <DIV id=mark_58 class=lecture_mark></DIV>
            <P id=id_59>При выполнении лабораторной работы для каждого задания 
            требуется написать программу на языке С++, которая получает на входе 
            числовые данные (в зависимости от постановки задачи), выполняет 
            генерацию и вывод двумерного массива указанного типа. В каждой 
            задаче необходимо выполнить обработку двумерного массива. Для этого 
            необходимо разработать алгоритм (сортировок или перестановок в 
            двумерных массивах) и реализовать его в виде отдельной функции. Ввод 
            данных осуществляется с клавиатуры с учетом требований к входным 
            данным, содержащихся в постановке задачи. Ограничениями на входные 
            данные является диапазон используемого числового типа данных в языке 
            С++ и максимально допустимый размер объявляемого двумерного 
            массива.</P>
            <DIV id=mark_59 class=lecture_mark></DIV>
            <P id=id_60><B>Теоретические сведения.</B></P>
            <DIV id=mark_60 class=lecture_mark></DIV>
            <P id=id_61>Ознакомьтесь с материалом лекции 14.</P>
            <DIV id=mark_61 class=lecture_mark></DIV>
            <P id=id_62><B>Задания к лабораторной работе.</B></P>
            <DIV id=mark_62 class=lecture_mark></DIV>
            <OL id=id_63>
              <LI>Объявите двумерный вещественный массив, в котором <SPAN 
              class=texample>n &#215; m</SPAN> элементов. Заполните его числами, 
              полученными по закономерности: <IMG 
              style="POSITION: relative; DISPLAY: inline; TOP: 12px" 
              alt=a_{ij}=\sum\limits_{n=0}^i\frac{(i+1)(j+5)}{i+j+1} 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/a2d2d8c9914cc540708e42017e45b007.png" 
              width=152 height=45>. Отсортируйте каждую строку массива по 
              убыванию. Распечатайте его в виде таблицы с точностью до 3 знаков 
              после запятой дважды – до и после сортировки. Оформите генерацию, 
              вывод массива и сортировку строк с помощью функций.
              <LI>Объявите двумерный целочисленный массив, в котором <SPAN 
              class=texample>n</SPAN> строк по <SPAN class=texample>m</SPAN> 
              элементов. Выполните генерацию массива случайными целыми числами 
              из промежутка <SPAN class=texample>[a; b)</SPAN>. Переставьте 
              столбцы массива так, чтобы их максимальные элементы образовали 
              возрастающую последовательность. Выведите массив на экран в виде 
              таблицы дважды – до и после перестановки. Оформите генерацию, 
              вывод массива и перестановку столбцов с помощью функций.
              <LI>Объявите двумерный вещественный массив, в котором <SPAN 
              class=texample>n &#215; m</SPAN> элементов. Выполните генерацию массива 
              случайными вещественными числами из промежутка <SPAN 
              class=texample>[a; b)</SPAN>. Отсортируйте каждый столбец массива 
              по возрастанию. Распечатайте его в виде таблицы с точностью до 2 
              знаков после запятой дважды – до и после сортировки. Оформите 
              генерацию, вывод массива и сортировку столбцов с помощью функций.
              <LI>Дана квадратная матрица размера <SPAN class=texample>2n &#215; 
              2n</SPAN>. Получите новую матрицу, переставляя ее блоки размера 
              <SPAN class=texample>n &#215; n</SPAN> в соответствии с рисунком. 
              <P id=id_77 align=left><A></A>
              <DIV><IMG alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/14_00.png"></DIV><BR>
              <P></P>
              <DIV id=mark_77 class=lecture_mark></DIV>
              <LI>Приведите квадратную целочисленную матрицу <SPAN 
              class=texample>n &#215; n</SPAN> к треугольному виду. Способ генерации 
              матрицы выберите самостоятельно.</LI></OL>
            <DIV id=mark_63 class=lecture_mark></DIV>
            <P id=id_80><B>Указания к выполнению работы.</B></P>
            <DIV id=mark_80 class=lecture_mark></DIV>
            <P id=id_81>Каждое задание необходимо решить в соответствии с 
            изученными методами объявления, генерации и вывода двумерных 
            массивов в языке С++. Обработку данных необходимо выполнить, 
            используя алгоритмы сортировок или перестановок данных в двумерных 
            массивах. При разработке программного кода требуется использовать 
            метод процедурной абстракции и комментировать фрагменты кода.</P>
            <DIV id=mark_81 class=lecture_mark></DIV>
            <P id=id_82>Следует реализовать каждое задание в соответствии с 
            приведенными этапами:</P>
            <DIV id=mark_82 class=lecture_mark></DIV>
            <UL id=id_83>
              <LI>изучить словесную постановку задачи, выделив при этом все виды 
              данных;
              <LI>сформулировать математическую постановку задачи;
              <LI>выбрать метод решения задачи, если это необходимо;
              <LI>разработать графическую схему алгоритма;
              <LI>записать разработанный алгоритм на языке С++;
              <LI>разработать контрольный тест к программе;
              <LI>отладить программу;
              <LI>представить отчет по работе.</LI></UL>
            <DIV id=mark_83 class=lecture_mark></DIV>
            <P id=id_92><B>Требования к отчету.</B></P>
            <DIV id=mark_92 class=lecture_mark></DIV>
            <P id=id_93>Отчет по лабораторной работе должен соответствовать 
            следующей структуре.</P>
            <DIV id=mark_93 class=lecture_mark></DIV>
            <UL id=id_94>
              <LI>Титульный лист.
              <LI>Словесная постановка задачи. В этом подразделе проводится 
              полное описание задачи. Описывается суть задачи, анализ входящих в 
              нее физических величин, область их допустимых значений, единицы их 
              измерения, возможные ограничения, анализ условий при которых 
              задача имеет решение (не имеет решения), анализ ожидаемых 
              результатов.
              <LI>Математическая модель. В этом подразделе вводятся 
              математические описания физических величин и математическое 
              описание их взаимодействий. Цель подраздела – представить решаемую 
              задачу в математической формулировке.
              <LI>Алгоритм решения задачи. В подразделе описывается разработка 
              структуры алгоритма, обосновывается абстракция данных, задача 
              разбивается на подзадачи. Схема алгоритма выполняется по ЕСПД 
              (ГОСТ 19.003-80 и ГОСТ 19.002-80).
              <LI>Листинг программы. Подраздел должен содержать текст программы 
              на языке программирования С++, реализованный в среде MS Visual 
              Studio 2010.
              <LI>Контрольный тест. Подраздел содержит наборы исходных данных и 
              полученные в ходе выполнения программы результаты.
              <LI>Выводы по лабораторной работе. 
              <LI>Ответы на контрольные вопросы.</LI></UL>
            <DIV id=mark_94 class=lecture_mark></DIV>
            <P id=id_103><B>Контрольные вопросы</B></P>
            <DIV id=mark_103 class=lecture_mark></DIV>
            <OL id=id_104>
              <LI>В чем принципиальное отличие задач сортировок двумерных и 
              одномерных массивов?
              <LI>Каким образом оформляется прототип функции, чтобы изменения, 
              выполненные с элементами массива, были сохранены после завершения 
              работы функции?
              <LI>Приведите возможные обращения к элементу трехмерного массива, 
              аналогичные обращению <SPAN class=texample>mas[i][j][k]</SPAN>.
              <LI>В чем причина неудобства использования массивов слишком 
              больших измерений в программах?
              <LI>При решении каких прикладных задач используются многомерные 
              массивы? Отдельно приведите примеры для массивов с измерением два 
              и более.</LI></OL>
            <DIV id=mark_104 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript 
src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/urchin.js">
</SCRIPT>

<SCRIPT 
type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
