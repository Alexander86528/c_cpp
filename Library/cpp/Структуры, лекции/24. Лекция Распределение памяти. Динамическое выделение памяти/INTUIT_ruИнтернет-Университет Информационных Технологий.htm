<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0071)http://www.intuit.ru/department/algorithms/staldata/24/staldata_24.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/printable.css">
<META name=GENERATOR content="MSHTML 9.00.8080.16413"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="COLOR: #000000; FONT-WEIGHT: bold">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD>
    <TD><!-- content -->
      <TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD class=head>Структуры и алгоритмы компьютерной обработки 
        данных</TD></TR>
        <TR>
          <TD height=4><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>24. Лекция: Распределение памяти. 
            Динамическое выделение памяти: версия для печати и PDA</SPAN> 
            <BR><SPAN class=rtxt>В лекции рассматриваются определения, 
            распределение, способы выделения и освобождения динамической памяти, 
            взаимодействие указателей и участков динамической памяти. 
        </SPAN></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3></H3>
            <P id=id_1><B>Цель лекции:</B> изучить способы выделения памяти, 
            динамического выделения памяти, связи указателей и динамического 
            распределения памяти, научиться решать задачи с использованием 
            динамического выделения памяти в языке C++.</P>
            <DIV id=mark_1 class=lecture_mark></DIV>
            <P id=id_2>Существует два основных способа хранения информации в 
            оперативной памяти. Первый заключается в использовании глобальных и 
            локальных переменных. В случае глобальных переменных выделяемые под 
            них поля памяти остаются неизменными на все время выполнения 
            программы. Под локальные переменные программа отводит память из 
            стекового пространства. Однако локальные переменные требуют 
            предварительного определения объема памяти, выделяемой для каждой 
            ситуации. Хотя С++ эффективно реализует такие переменные, они 
            требуют от программиста заранее знать, какое количество памяти 
            необходимо для каждой ситуации.</P>
            <DIV id=mark_2 class=lecture_mark></DIV>
            <P id=id_3>Второй способ, которым С++ может хранить информацию, 
            заключается в использовании системы динамического распределения. При 
            этом способе память распределяется для информации из свободной 
            области памяти по мере необходимости. Область свободной памяти 
            находится между кодом программы с ее постоянной областью памяти и 
            стеком (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/24/staldata_24.html#image.24.1">рис. 
            24.1</A>). Динамическое размещение удобно, когда неизвестно, сколько 
            элементов данных будет обрабатываться.</P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <P id=id_4 align=left><A name=image.24.1></A>
            <DIV><IMG alt="Распределение оперативной памяти для программ на С++" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/24_01.png" 
            width=535 height=150></DIV><BR><B>Рис. 24.1.</B>&nbsp; Распределение 
            оперативной памяти для программ на С++
            <P></P>
            <DIV id=mark_4 class=lecture_mark></DIV>
            <P id=id_5>По мере использования программой стековая область 
            увеличивается вниз, то есть программа сама определяет объем стековой 
            памяти. Например, программа с большим числом рекурсивных функций 
            займет больше стековой памяти, чем программа, не имеющая рекурсивных 
            функций, так как локальные переменные и возвращаемые адреса хранятся 
            в стеках. Память под саму программу и глобальные переменные 
            выделяется на все время выполнения программы и является постоянной 
            для конкретной среды.</P>
            <DIV id=mark_5 class=lecture_mark></DIV>
            <P id=id_6>Память, выделяемая в процессе выполнения программы, 
            называется динамической. После выделения <SPAN 
            class=xml_em_italic>динамической</SPAN> памяти она сохраняется до ее 
            явного освобождения, что может быть выполнено только с помощью 
            специальной операции или библиотечной функции.</P>
            <DIV id=mark_6 class=lecture_mark></DIV>
            <P id=id_7>Если динамическая память не освобождена до окончания 
            программы, то она освобождается автоматически при завершении 
            программы. Тем не менее, явное освобождение ставшей ненужной памяти 
            является признаком хорошего стиля программирования.</P>
            <DIV id=mark_7 class=lecture_mark></DIV>
            <P id=id_8>В процессе выполнения программы участок динамической 
            памяти доступен везде, где доступен указатель, адресующий этот 
            участок. Таким образом, возможны следующие <SPAN 
            class=xml_em_italic>три варианта работы с динамической 
            памятью</SPAN>, выделяемой в некотором блоке (например, в теле 
            неглавной функции).</P>
            <DIV id=mark_8 class=lecture_mark></DIV>
            <UL id=id_9>
              <LI>Указатель (на участок динамической памяти) определен как 
              локальный объект автоматической памяти. В этом случае выделенная 
              память будет недоступна при выходе за пределы блока локализации 
              указателя, и ее нужно освободить перед выходом из блока.
              <LI>Указатель определен как локальный объект статической памяти. 
              Динамическая память, выделенная однократно в блоке, доступна через 
              указатель при каждом повторном входе в блок. Память нужно 
              освободить только по окончании ее использования.
              <LI>Указатель является глобальным объектом по отношению к блоку. 
              Динамическая память доступна во всех блоках, где "виден" 
              указатель. Память нужно освободить только по окончании ее 
              использования.</LI></UL>
            <DIV id=mark_9 class=lecture_mark></DIV>
            <P id=id_13>Все переменные, объявленные в программе размещаются в 
            одной непрерывной области памяти, которую называют <SPAN 
            class=xml_em_italic>сегментом данных</SPAN>. Такие переменные не 
            меняют своего размера в ходе выполнения программы и называются <SPAN 
            class=xml_em_italic>статическими</SPAN>. Размера сегмента данных 
            может быть недостаточно для размещения больших объемов информации. 
            Выходом из этой ситуации является использование динамической памяти. 
            <B>Динамическая память</B> – это память, выделяемая программе для ее 
            работы за вычетом сегмента данных, стека, в котором размещаются 
            локальные переменные подпрограмм и собственно тела программы.</P>
            <DIV id=mark_13 class=lecture_mark></DIV>
            <P id=id_14>Для работы с динамической памятью используют указатели. 
            С их помощью осуществляется доступ к участкам динамической памяти, 
            которые называются <B>динамическими переменными</B>. Для хранения 
            динамических переменных выделяется специальная область памяти, 
            называемая "кучей".</P>
            <DIV id=mark_14 class=lecture_mark></DIV>
            <P id=id_15>Динамические переменные создаются с помощью специальных 
            функций и операций. Они существуют либо до конца работы программы, 
            либо до тех пор, пока не будет освобождена выделенная под них память 
            с помощью специальных функций или операций. То есть время жизни 
            динамических переменных – от точки создания до конца программы или 
            до явного освобождения памяти.</P>
            <DIV id=mark_15 class=lecture_mark></DIV>
            <P id=id_16>В С++ используется два способа работы с динамической 
            памятью:</P>
            <DIV id=mark_16 class=lecture_mark></DIV>
            <OL id=id_17>
              <LI>использование операций <SPAN class=texample>new</SPAN> и <SPAN 
              class=texample>delete</SPAN>;
              <LI>использование семейства функций <SPAN 
              class=texample>mal1ос</SPAN> (<SPAN class=texample>calloc</SPAN>) 
              (унаследовано из С).</LI></OL>
            <DIV id=mark_17 class=lecture_mark></DIV><A name=sect2></A>
            <H3>Работа с динамической памятью с помощью операций new и 
            delete</H3>
            <P id=id_24>В языке программирования С++ для динамического 
            распределения памяти существуют операции <SPAN 
            class=texample>new</SPAN> и <SPAN class=texample>delete</SPAN>. Эти 
            операции используются для выделения и освобождения блоков памяти. 
            Область памяти, в которой размещаются эти блоки, называется <SPAN 
            class=xml_em_italic>свободной памятью</SPAN>.</P>
            <DIV id=mark_24 class=lecture_mark></DIV>
            <P id=id_27>Операция <SPAN class=texample>new</SPAN> позволяет 
            выделить и сделать доступным свободный участок в основной памяти, 
            размеры которого соответствуют типу данных, определяемому именем 
            типа.</P>
            <DIV id=mark_27 class=lecture_mark></DIV>
            <P id=id_29>Синтаксис:</P>
            <DIV id=mark_29 class=lecture_mark></DIV>
            <DIV class=example><PRE>new ИмяТипа;
</PRE></DIV>
            <P id=id_31>или</P>
            <DIV id=mark_31 class=lecture_mark></DIV>
            <DIV class=example><PRE>new ИмяТипа [Инициализатор];
</PRE></DIV>
            <P id=id_33>В выделенный участок заносится значение, определяемое 
            инициализатором, который не является обязательным элементом. В 
            случае успешного выполнения <SPAN class=texample>new</SPAN> 
            возвращает адрес начала выделенного участка памяти. Если участок 
            нужных размеров не может быть выделен (нет памяти), то операция 
            <SPAN class=texample>new</SPAN> возвращает нулевое значение адреса 
            (<SPAN class=texample>NULL</SPAN>). </P>
            <DIV id=mark_33 class=lecture_mark></DIV>
            <P id=id_37>Синтаксис применения операции:</P>
            <DIV id=mark_37 class=lecture_mark></DIV>
            <DIV class=example><PRE>Указатель = new ИмяТипа [Инициализатор];
</PRE></DIV>
            <P id=id_39>Операция <SPAN class=texample>new float</SPAN> выделяет 
            участок памяти размером 4 байта. Операция <SPAN class=texample>new 
            int(15)</SPAN> выделяет участок памяти 4 байта и инициализирует этот 
            участок целым значением 15. Синтаксис использования операций <SPAN 
            class=texample>new</SPAN> и <SPAN class=texample>delete</SPAN> 
            предполагает применение указателей. Предварительно каждый указатель 
            должен быть объявлен:</P>
            <DIV id=mark_39 class=lecture_mark></DIV>
            <DIV class=example><PRE>тип *ИмяУказателя;
</PRE></DIV>
            <P id=id_45>Например:</P>
            <DIV id=mark_45 class=lecture_mark></DIV>
            <DIV class=example><PRE>float *pi;   //Объявление переменной pi
pi=new float; //Выделение памяти для переменной pi
* pi = 2.25; //Присваивание значения
</PRE></DIV>
            <P id=id_47>В качестве типа можно использовать, например, 
            стандартные типы <SPAN class=texample>int, long, float, double, 
            char</SPAN>.</P>
            <DIV id=mark_47 class=lecture_mark></DIV>
            <P id=id_49>Оператор <SPAN class=texample>new</SPAN> чаще всего 
            используется для размещения в памяти данных определенных 
            пользователем типов, например, структур:</P>
            <DIV id=mark_49 class=lecture_mark></DIV>
            <DIV class=example><PRE>struct Node {
             char *Name;
             int Value;
             Node *Next
            };

Node *PNode; //объявляется указатель

PNode = new Node; //выделяется память

PNode-&gt;Name = "Ata"; //присваиваются значения
PNode-&gt;Value = 1;
PNode-&gt;Next = NULL;
</PRE></DIV>
            <P id=id_52>В качестве имени типа в операции new может быть 
            использован массив:</P>
            <DIV id=mark_52 class=lecture_mark></DIV>
            <DIV class=example><PRE>new ТипМассива 
</PRE></DIV>
            <P id=id_54>При выделении динамической памяти для массива его 
            размеры должны быть полностью определены. Например:</P>
            <DIV id=mark_54 class=lecture_mark></DIV>
            <DIV class=example><PRE>ptr = new int [10];//10 элементов типа int или 40 байт
ptr = new int [ ];//неверно, т.к. не определен размер 
</PRE></DIV>
            <P id=id_56>Такая операция позволяет выделить в динамической памяти 
            участок для размещения массива соответствующего типа, но не 
            позволяет его инициализировать. В результате выполнения операция 
            <SPAN class=texample>new</SPAN> возвратит указатель, значением 
            которого служит адрес первого элемента массива. Например:</P>
            <DIV id=mark_56 class=lecture_mark></DIV>
            <DIV class=example><PRE>int *n = new int; 
</PRE></DIV>
            <P id=id_59>Операция <SPAN class=texample>new</SPAN> выполняет 
            выделение достаточного для размещения величины типа <SPAN 
            class=texample>int</SPAN> участка динамической памяти и записывает 
            адрес начала этого участка в переменную <SPAN 
            class=texample>n</SPAN>. Память под саму переменную <SPAN 
            class=texample>n</SPAN> (размера, достаточного для размещения 
            указателя) выделяется на этапе компиляции.</P>
            <DIV id=mark_59 class=lecture_mark></DIV>
            <DIV class=example><PRE>int *b = new int (10);
</PRE></DIV>
            <P id=id_65>В данном операторе, кроме описанных выше действий, 
            производится инициализация выделенной динамической памяти значением 
            10.</P>
            <DIV id=mark_65 class=lecture_mark></DIV>
            <DIV class=example><PRE>int *q = new int [10]; 
</PRE></DIV>
            <P id=id_67>В этом случае операция <SPAN class=texample>new</SPAN> 
            выполняет выделение памяти под 10 величин типа <SPAN 
            class=texample>int</SPAN> (массива из 10 элементов) и записывает 
            адрес начала этого участка в переменную <SPAN 
            class=texample>q</SPAN>, которая может трактоваться как имя массива. 
            Через имя можно обращаться к любому элементу массива.</P>
            <DIV id=mark_67 class=lecture_mark></DIV>
            <P id=id_71>Есть ряд преимуществ использования <SPAN 
            class=texample>new</SPAN>. Во-первых, операция <SPAN 
            class=texample>new</SPAN> автоматически вычисляет размер необходимой 
            памяти. Нет необходимости в использовании операции <SPAN 
            class=texample>sizeof()</SPAN>. Более важно то, что она 
            предотвращает случайное выделение неправильного количества памяти. 
            Во-вторых, операции <SPAN class=texample>new</SPAN> автоматически 
            возвращает указатель требуемого типа.</P>
            <DIV id=mark_71 class=lecture_mark></DIV>
            <P id=id_76>Для освобождения выделенного операцией <SPAN 
            class=texample>new</SPAN> участка памяти используется операции:</P>
            <DIV id=mark_76 class=lecture_mark></DIV>
            <DIV class=example><PRE>delete указатель; 
</PRE></DIV>
            <P id=id_79>Указатель адресует освобождаемый участок памяти, ранее 
            выделенный с помощью операции <SPAN class=texample>new</SPAN>. 
            Например:</P>
            <DIV id=mark_79 class=lecture_mark></DIV>
            <DIV class=example><PRE>delete x;
</PRE></DIV>
            <P id=id_82>Для освобождения памяти, выделенной для массива, 
            используется следующая модификация той же операции:</P>
            <DIV id=mark_82 class=lecture_mark></DIV>
            <DIV class=example><PRE>delete [ ] указатель;
</PRE></DIV>
            <P id=id_84>Операцию <SPAN class=texample>delete</SPAN> следует 
            использовать только для указателей на память, выделенную с помощью 
            операции <SPAN class=texample>new</SPAN>. Использование <SPAN 
            class=texample>delete</SPAN> с другими типами адресов может породить 
            серьезные проблемы.</P>
            <DIV id=mark_84 class=lecture_mark></DIV>
            <P id=id_88><SPAN class=xml_em_italic>Пример 1</SPAN>. Демонстрация 
            выполнения операций с динамической памятью.</P>
            <DIV id=mark_88 class=lecture_mark></DIV>
            <DIV class=example><PRE>#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
int _tmain(int argc, _TCHAR* argv[]){
  int *pa, *pb; 
  pa = new int; 
  *pa = 21; 
  pb = pa; 
  cout &lt;&lt; *pa &lt;&lt; "  " &lt;&lt; *pb &lt;&lt; "\n";
  pb = new int; 
  *pb = 28; 
  cout &lt;&lt; *pa &lt;&lt; "  " &lt;&lt; *pb &lt;&lt; "\n";
  delete pa;
  pa = pb; 
  cout &lt;&lt; *pa &lt;&lt; "  " &lt;&lt; *pb &lt;&lt; "\n";
  delete pa; 
  system("pause");
  return 0;
}
</PRE></DIV>
            <P id=id_90>Результат выполнения программы:</P>
            <DIV id=mark_90 class=lecture_mark></DIV>
            <DIV class=example><PRE>21  21
21  28
28  28
</PRE></DIV><A name=sect3></A>
            <H3>Работа с динамической памятью с помощью библиотечных функций 
            malloc (calloc) и free</H3>
            <P id=id_92>Средства для динамического выделения и освобождения 
            памяти описаны в заголовочных файлах <SPAN 
            class=texample>malloc.h</SPAN> и <SPAN 
            class=texample>stdlib.h</SPAN> стандартной библиотеки (файл <SPAN 
            class=texample>malloc.h</SPAN>).</P>
            <DIV id=mark_92 class=lecture_mark></DIV>
            <DIV id=id_96 class=xml_table_env><A></A>
            <TABLE class=xml_table border=0 cellSpacing=1 cellPadding=2>
              <CAPTION>Функции выделения и освобождения памяти</CAPTION>
              <TBODY>
              <TR>
                <TH bgColor=#d8d8d8>Функция</TH>
                <TH bgColor=#d8d8d8>Прототип и краткое описание</TH></TR>
              <TR>
                <TD bgColor=#eaeaea vAlign=top><SPAN 
                  class=texample>malloc</SPAN></TD>
                <TD bgColor=#eaeaea vAlign=top><SPAN class=texample>void * 
                  malloc (unsigned s);</SPAN> возвращает указатель на начало 
                  области (блока) динамической памяти длинной в <SPAN 
                  class=texample>s</SPAN> байт. При неудачном завершении 
                  возвращает значение <SPAN class=texample>NULL</SPAN>.</TD></TR>
              <TR>
                <TD bgColor=#eaeaea vAlign=top><SPAN 
                  class=texample>calloc</SPAN></TD>
                <TD bgColor=#eaeaea vAlign=top><SPAN class=texample>void * 
                  calloc (unsigned n, unsigned m);</SPAN> возвращает указатель 
                  на начало области (блока) обнуленной динамической памяти, 
                  выделенной для размещения <SPAN class=texample>n</SPAN> 
                  элементов по <SPAN class=texample>m</SPAN> байт каждый. При 
                  неудачном завершении возвращает значение <SPAN 
                  class=texample>NULL</SPAN>.</TD></TR>
              <TR>
                <TD bgColor=#eaeaea vAlign=top><SPAN 
                  class=texample>realloc</SPAN></TD>
                <TD bgColor=#eaeaea vAlign=top><SPAN class=texample>void * 
                  realloc (void * bl, unsigned ns);</SPAN> изменяет размер блока 
                  ранее выделенной динамической памяти до размера <SPAN 
                  class=texample>ns</SPAN> байт, <SPAN class=texample>bl</SPAN> 
                  – адрес начала изменяемого блока. Если <SPAN 
                  class=texample>bl</SPAN> равен <SPAN 
                  class=texample>NULL</SPAN> (память не выделялась), то функция 
                  выполняется как <SPAN class=texample>malloc</SPAN>.</TD></TR>
              <TR>
                <TD bgColor=#eaeaea vAlign=top><SPAN 
                class=texample>free</SPAN></TD>
                <TD bgColor=#eaeaea vAlign=top><SPAN class=texample>void * 
                  free (void * bl);</SPAN> освобождает ранее выделенный участок 
                  (блок) динамической памяти, адрес первого байта которого равен 
                  значению <SPAN 
            class=texample>bl</SPAN>.</TD></TR></TBODY></TABLE></DIV>
            <DIV id=mark_96 class=lecture_mark></DIV>
            <P id=id_116>Функции <SPAN class=texample>malloc()</SPAN>, <SPAN 
            class=texample>calloc()</SPAN> и <SPAN 
            class=texample>realloc()</SPAN> динамически выделяют память в 
            соответствии со значениями параметров и возвращают адрес начала 
            выделенного участка памяти. Для универсальности тип возвращаемого 
            значения каждой из этих функций есть <SPAN class=texample>void 
            *</SPAN>. Этот указатель можно преобразовать к указателю любого типа 
            с помощью операции явного приведения типа (<SPAN class=texample>тип 
            *</SPAN>).</P>
            <DIV id=mark_116 class=lecture_mark></DIV>
            <P id=id_122>Функция <SPAN class=texample>free()</SPAN> освобождает 
            память, выделенную перед этим с помощью одной из трех функций <SPAN 
            class=texample>malloc()</SPAN>, <SPAN class=texample>calloc()</SPAN> 
            или <SPAN class=texample>realloc()</SPAN>. Сведения об участке 
            памяти передаются в функцию <SPAN class=texample>free()</SPAN> с 
            помощью указателя – параметра типа <SPAN class=texample>void 
            *</SPAN>. Преобразование указателя любого типа к типу <SPAN 
            class=texample>void *</SPAN> выполняется автоматически, поэтому 
            вместо формального параметра <SPAN class=texample>void *bl</SPAN> 
            можно подставить в качестве фактического параметра указатель любого 
            типа без операции явного приведения типов.</P>
            <DIV id=mark_122 class=lecture_mark></DIV>
            <P id=id_131><SPAN class=xml_em_italic>Пример 2</SPAN>. Ввести и 
            напечатать в обратном порядке набор вещественных чисел, количество 
            которых заранее не фиксировано, а вводится до начала ввода самих 
            числовых значений.</P>
            <DIV id=mark_131 class=lecture_mark></DIV>
            <DIV class=example><PRE>#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
int _tmain(int argc, _TCHAR* argv[]){
  float* t; //Указатель для выделяемого блока памяти 
  int i,n;
  printf("n=");//n - число элементов
  scanf("%d", &amp;n);
  t=(float *)malloc(n*sizeof(float));
  for (i=0; i&lt;n; i++){ //цикл ввода чисел
    printf("x[%d]=",i);
    scanf("%f", &amp;t[i]);
  }
  //цикл печати результатов
  for (i=n-1; i&gt;=0; i--){
    printf("\nx[%d]=%f",i,t[i]);
  }
  free(t); //освобождает память
  system("pause");
  return 0;
}
</PRE></DIV>
            <P id=id_133>В программе <SPAN class=texample>int n</SPAN> – 
            количество вводимых чисел типа <SPAN class=texample>float, float* 
            t</SPAN> – указатель на начало области, выделяемой для размещения 
            <SPAN class=texample>n</SPAN> вводимых чисел. Указатель <SPAN 
            class=texample>t</SPAN> принимает значение адреса области, 
            выделяемой для n значений типа <SPAN class=texample>float</SPAN>. 
            Доступ к участкам памяти выделенной области выполняется с помощью 
            операции индексирования: <SPAN class=texample>t[i]</SPAN> и <SPAN 
            class=texample>t[i-1]</SPAN>. Оператор <SPAN 
            class=texample>free(t);</SPAN> содержит вызов функции, освобождающей 
            выделяемую ранее динамическую память и связанной с указателем <SPAN 
            class=texample>t</SPAN>.</P>
            <DIV id=mark_133 class=lecture_mark></DIV><A name=sect4></A>
            <H3>Ключевые термины</H3>
            <P id=id_143><B>Динамическая память</B> – это память, выделяемая 
            программе для ее работы за вычетом сегмента данных, стека, в котором 
            размещаются локальные переменные подпрограмм и собственно тела 
            программы.</P>
            <DIV id=mark_143 class=lecture_mark></DIV>
            <P id=id_144><B>Динамические переменные</B> – это переменные, 
            определенные в области динамической памяти. </P>
            <DIV id=mark_144 class=lecture_mark></DIV>
            <P id=id_145><B>Операция выделения динамической памяти</B> – это 
            выделение достаточного для размещения величины участка динамической 
            памяти.</P>
            <DIV id=mark_145 class=lecture_mark></DIV>
            <P id=id_146><B>Операция освобождения динамической памяти</B> – это 
            освобождение участка динамической памяти, выделенного ранее.</P>
            <DIV id=mark_146 class=lecture_mark></DIV>
            <P id=id_147><B>Сегмент данных</B> – это непрерывная область памяти, 
            в которой размещаются объявленные в программе переменные.</P>
            <DIV id=mark_147 class=lecture_mark></DIV>
            <P id=id_148><B>Функция выделения динамической памяти</B> – это 
            функция выделения памяти в соответствии со значениями параметров, 
            возвращающая адрес начала выделенного участка памяти.</P>
            <DIV id=mark_148 class=lecture_mark></DIV>
            <P id=id_149><B>Функция освобождения динамической памяти</B> – это 
            функция освобождения динамической памяти, выделенной ранее.</P>
            <DIV id=mark_149 class=lecture_mark></DIV><A name=sect5></A>
            <H3>Краткие итоги</H3>
            <OL id=id_150>
              <LI>В ходе выполнения программ выделяются статическая и 
              динамическая области памяти.
              <LI>Возможны три варианта работы с динамической памятью: указатель 
              определяется как локальный объект автоматической или статической 
              памяти, указатель является глобальным объектом для блока памяти.
              <LI>Доступ к участкам динамической памяти осуществляется через 
              динамические переменные.
              <LI>Работа с динамической памятью начинается с выделения участка 
              памяти, а завершается освобождением ранее выделенного участка.
              <LI>Выделение и освобождение динамической памяти выполняется с 
              помощью операций или функций для работы с динамической 
              памятью.</LI></OL>
            <DIV id=mark_150 class=lecture_mark></DIV><A name=sect6></A>
            <H3>Лабораторная работа 24. Распределение памяти. Динамическое 
            выделение памяти</H3>
            <P id=id_156><B>Цель работы:</B> изучить способы выделения памяти, 
            динамического выделения памяти, связи указателей и динамического 
            распределения памяти, научиться решать задачи с использованием 
            динамического выделения памяти в языке C++.</P>
            <DIV id=mark_156 class=lecture_mark></DIV>
            <P id=id_157>При выполнении лабораторной работы для каждого задания 
            требуется написать программу на языке С++, которая получает на входе 
            данные в соответствии с указанном в задании типом и осуществляет их 
            обработку, используя для хранения оговоренных в условии 
            последовательностей ресурсы динамической памяти. Ввод данных 
            осуществляется с клавиатуры с учетом содержащихся в постановке 
            задачи признака конца входной последовательности данных и требований 
            к ним. Ограничениями на входные данные является максимальный размер 
            строковых данных, допустимый диапазон числовых типов в языке С++ и 
            максимально допустимый размер динамической памяти.</P>
            <DIV id=mark_157 class=lecture_mark></DIV>
            <P id=id_158><B>Теоретические сведения.</B></P>
            <DIV id=mark_158 class=lecture_mark></DIV>
            <P id=id_159>Ознакомьтесь с материалом лекции 24.</P>
            <DIV id=mark_159 class=lecture_mark></DIV>
            <P id=id_160><B>Задания к лабораторной работе.</B></P>
            <DIV id=mark_160 class=lecture_mark></DIV>
            <P id=id_161>Выполните приведенные ниже задания.</P>
            <DIV id=mark_161 class=lecture_mark></DIV>
            <OL id=id_162>
              <LI>Составьте программу нахождения действительных корней 
              квадратного уравнения, расположив его коэффициенты в динамической 
              памяти.
              <LI>Дана последовательность целых чисел, количество которых 
              заранее не определено. Считать концом последовательности ввод 
              нулевого значения. Ввести и напечатать на разных строках четные и 
              нечетные числа данной последовательности. Реализуйте данную 
              программу двумя способами: 1) с помощью операций <SPAN 
              class=texample>new</SPAN> и <SPAN class=texample>delete</SPAN>; 2) 
              с помощью библиотечных функций <SPAN class=texample>malloc 
              (calloc)</SPAN> и <SPAN class=texample>free</SPAN>.
              <LI>Дана последовательность целых чисел, количество которых 
              заранее не определено. Считать концом последовательности ввод 
              нулевого значения. Вывести на печать числа по закономерности, пока 
              образуется пустая строка. 
              <DIV class=example><PRE>a<SUB>n</SUB>      a<SUB>n-1</SUB>   ...   a<SUB>3</SUB>      a<SUB>2</SUB>      a<SUB>1</SUB>
a<SUB>n-1</SUB>    a<SUB>n-2</SUB>   ...   a<SUB>2</SUB>
..................
</PRE></DIV>
              <LI>Дана последовательность символов латинского алфавита, 
              количество которых заранее не определено. Считать концом 
              последовательности символ пробела. Вывести на печать гласные буквы 
              из данной последовательности.</LI></OL>
            <DIV id=mark_162 class=lecture_mark></DIV>
            <P id=id_172><B>Указания к выполнению работы.</B></P>
            <DIV id=mark_172 class=lecture_mark></DIV>
            <P id=id_173>Каждое задание необходимо решить в соответствии с 
            изученными методами работы с динамической памятью и алгоритмами 
            обработки данных в языке С++. В задачах 2, 3 и 4 количество входных 
            данных заранее не определено, однако, при реализации следует 
            считать, что их размер не превышает максимально допустимого объема 
            динамической памяти. Вывод результатов обработки данных следует 
            осуществить на экран. Программу для решения каждого задания 
            необходимо разработать методом процедурной абстракции, оформив 
            комментарии к коду.</P>
            <DIV id=mark_173 class=lecture_mark></DIV>
            <P id=id_174>Следует реализовать каждое задание в соответствии с 
            приведенными этапами:</P>
            <DIV id=mark_174 class=lecture_mark></DIV>
            <UL id=id_175>
              <LI>изучить словесную постановку задачи, выделив при этом все виды 
              данных;
              <LI>сформулировать математическую постановку задачи;
              <LI>выбрать метод решения задачи, если это необходимо;
              <LI>разработать графическую схему алгоритма;
              <LI>записать разработанный алгоритм на языке С++;
              <LI>разработать контрольный тест к программе;
              <LI>отладить программу;
              <LI>представить отчет по работе.</LI></UL>
            <DIV id=mark_175 class=lecture_mark></DIV>
            <P id=id_184><B>Требования к отчету.</B></P>
            <DIV id=mark_184 class=lecture_mark></DIV>
            <P id=id_185>Отчет по лабораторной работе должен соответствовать 
            следующей структуре.</P>
            <DIV id=mark_185 class=lecture_mark></DIV>
            <UL id=id_186>
              <LI>Титульный лист.
              <LI>Словесная постановка задачи. В этом подразделе проводится 
              полное описание задачи. Описывается суть задачи, анализ входящих в 
              нее физических величин, область их допустимых значений, единицы их 
              измерения, возможные ограничения, анализ условий при которых 
              задача имеет решение (не имеет решения), анализ ожидаемых 
              результатов.
              <LI>Математическая модель. В этом подразделе вводятся 
              математические описания физических величин и математическое 
              описание их взаимодействий. Цель подраздела – представить решаемую 
              задачу в математической формулировке.
              <LI>Алгоритм решения задачи. В подразделе описывается разработка 
              структуры алгоритма, обосновывается абстракция данных, задача 
              разбивается на подзадачи. Схема алгоритма выполняется по ЕСПД 
              (ГОСТ 19.003-80 и ГОСТ 19.002-80).
              <LI>Листинг программы. Подраздел должен содержать текст программы 
              на языке программирования С++, реализованный в среде MS Visual 
              Studio 2010.
              <LI>Контрольный тест. Подраздел содержит наборы исходных данных и 
              полученные в ходе выполнения программы результаты.
              <LI>Выводы по лабораторной работе. 
              <LI>Ответы на контрольные вопросы.</LI></UL>
            <DIV id=mark_186 class=lecture_mark></DIV>
            <P id=id_195><B>Контрольные вопросы</B></P>
            <DIV id=mark_195 class=lecture_mark></DIV>
            <OL id=id_196>
              <LI>Для чего используется динамическая память в программировании?
              <LI>Какая область памяти выделяется под размещение динамических 
              данных?
              <LI>Как долго хранятся данные в динамической памяти?
              <LI>Какие возможны варианты доступа к динамической памяти?
              <LI>Что возвращает операция выделения динамической памяти в случае 
              успешного выполнения? 
              <LI>Что возвращает операция выделения динамической памяти, если 
              участок требуемого размера не может быть выделен?
              <LI>Почему тип функций выделения динамической памяти определен как 
              *void?
              <LI>Почему при завершении работы с динамической памятью ее 
              необходимо освободить? Какие могут быть последствия для работы 
              программы, если не освобождать динамическую память?
              <LI>Существуют ли ограничения на данные при применении к ним 
              операции или функции освобождения динамической памяти?</LI></OL>
            <DIV id=mark_196 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript 
src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/urchin.js">
</SCRIPT>

<SCRIPT 
type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
