<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0071)http://www.intuit.ru/department/algorithms/staldata/45/staldata_45.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/printable.css">
<META name=GENERATOR content="MSHTML 9.00.8080.16413"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="COLOR: #000000; FONT-WEIGHT: bold">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD>
    <TD><!-- content -->
      <TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD class=head>Структуры и алгоритмы компьютерной обработки 
        данных</TD></TR>
        <TR>
          <TD height=4><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>45. Лекция: Алгоритмы на графах. Алгоритмы 
            нахождения кратчайшего пути: версия для печати и PDA</SPAN> 
            <BR><SPAN class=rtxt>В лекции рассматриваются постановка задачи и 
            описание алгоритмов нахождения кратчайшего пути в графах, приводятся 
            программные реализации алгоритмов Дейкстры, Флойда и переборного 
            алгоритма. </SPAN></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3></H3>
            <P id=id_1><B>Цель лекции:</B> изучить основные алгоритмы поиска 
            кратчайшего пути и научиться решать задачи поиска кратчайшего пути 
            на основе алгоритмов Дейкстры, Флойда и переборных алгоритмов.</P>
            <DIV id=mark_1 class=lecture_mark></DIV>
            <P id=id_2>Нахождение кратчайшего пути на сегодняшний день является 
            жизненно необходимой задачей и используется практически везде, 
            начиная от нахождения оптимального маршрута между двумя объектами на 
            местности (например, кратчайший путь от дома до университета), в 
            системах автопилота, для нахождения оптимального маршрута при 
            перевозках, коммутации информационного пакета в сетях и т.п.</P>
            <DIV id=mark_2 class=lecture_mark></DIV>
            <P id=id_3>Кратчайший путь рассматривается при помощи некоторого 
            математического объекта, называемого графом. Поиск кратчайшего пути 
            ведется между двумя заданными вершинами в графе. Результатом 
            является путь, то есть последовательность вершин и ребер, 
            инцидентных двум соседним вершинам, и его длина.</P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <P id=id_4>Рассмотрим три наиболее эффективных алгоритма нахождения 
            кратчайшего пути:</P>
            <DIV id=mark_4 class=lecture_mark></DIV>
            <UL id=id_5>
              <LI>алгоритм Дейкстры;
              <LI>алгоритм Флойда;
              <LI>переборные алгоритмы.</LI></UL>
            <DIV id=mark_5 class=lecture_mark></DIV>
            <P id=id_9>Указанные алгоритмы легко выполняются при малом 
            количестве вершин в графе. При увеличении их количества задача 
            поиска кратчайшего пути усложняется.</P>
            <DIV id=mark_9 class=lecture_mark></DIV><A name=sect2></A>
            <H3>Алгоритм Дейкстры</H3>
            <P id=id_10>Данный алгоритм является алгоритмом на графах, который 
            изобретен нидерландским ученым Э. Дейкстрой в 1959 году. Алгоритм 
            находит кратчайшее расстояние от одной из вершин графа до всех 
            остальных и работает только для графов без ребер отрицательного 
            веса.</P>
            <DIV id=mark_10 class=lecture_mark></DIV>
            <P id=id_11>Каждой вершине приписывается вес – это вес пути от 
            начальной вершины до данной. Также каждая вершина может быть 
            выделена. Если вершина выделена, то путь от нее до начальной вершины 
            кратчайший, если нет – то временный. Обходя граф, алгоритм считает 
            для каждой вершины маршрут, и, если он оказывается кратчайшим, 
            выделяет вершину. Весом данной вершины становится вес пути. Для всех 
            соседей данной вершины алгоритм также рассчитывает вес, при этом ни 
            при каких условиях не выделяя их. Алгоритм заканчивает свою работу, 
            дойдя до конечной вершины, и весом кратчайшего пути становится вес 
            конечной вершины.</P>
            <DIV id=mark_11 class=lecture_mark></DIV>
            <P id=id_12><SPAN class=xml_em_italic>Алгоритм Дейкстры</SPAN></P>
            <DIV id=mark_12 class=lecture_mark></DIV>
            <P id=id_13>Шаг 1. Всем вершинам, за исключением первой, 
            присваивается вес равный бесконечности, а первой вершине – 0.</P>
            <DIV id=mark_13 class=lecture_mark></DIV>
            <P id=id_14>Шаг 2. Все вершины не выделены.</P>
            <DIV id=mark_14 class=lecture_mark></DIV>
            <P id=id_15>Шаг 3. Первая вершина объявляется текущей.</P>
            <DIV id=mark_15 class=lecture_mark></DIV>
            <P id=id_16>Шаг 4. Вес всех невыделенных вершин пересчитывается по 
            формуле: вес невыделенной вершины есть минимальное число из старого 
            веса данной вершины, суммы веса текущей вершины и веса ребра, 
            соединяющего текущую вершину с невыделенной.</P>
            <DIV id=mark_16 class=lecture_mark></DIV>
            <P id=id_17>Шаг 5. Среди невыделенных вершин ищется вершина с 
            минимальным весом. Если таковая не найдена, то есть вес всех вершин 
            равен бесконечности, то маршрут не существует. Следовательно, выход. 
            Иначе, текущей становится найденная вершина. Она же выделяется.</P>
            <DIV id=mark_17 class=lecture_mark></DIV>
            <P id=id_18>Шаг 6. Если текущей вершиной оказывается конечная, то 
            путь найден, и его вес есть вес конечной вершины.</P>
            <DIV id=mark_18 class=lecture_mark></DIV>
            <P id=id_19>Шаг 7. Переход на шаг 4. </P>
            <DIV id=mark_19 class=lecture_mark></DIV>
            <P id=id_20>В программной реализации алгоритма Дейкстры построим 
            множество <SPAN class=texample>S</SPAN> вершин, для которых 
            кратчайшие пути от начальной вершины уже известны. На каждом шаге к 
            множеству <SPAN class=texample>S</SPAN> добавляется та из оставшихся 
            вершин, расстояние до которой от начальной вершины меньше, чем для 
            других оставшихся вершин. При этом будем использовать массив <SPAN 
            class=texample>D</SPAN>, в который записываются длины кратчайших 
            путей для каждой вершины. Когда множество <SPAN 
            class=texample>S</SPAN> будет содержать все вершины графа, тогда 
            массив <SPAN class=texample>D</SPAN> будет содержать длины 
            кратчайших путей от начальной вершины к каждой вершине.</P>
            <DIV id=mark_20 class=lecture_mark></DIV>
            <P id=id_26>Помимо указанных массивов будем использовать матрицу 
            длин <SPAN class=texample>C</SPAN>, где элемент <SPAN 
            class=texample>C[i,j]</SPAN> –длина ребра <SPAN 
            class=texample>(i,j)</SPAN>, если ребра нет, то ее длина полагается 
            равной бесконечности, то есть больше любой фактической длины ребер. 
            Фактически матрица <SPAN class=texample>C</SPAN> представляет собой 
            матрицу смежности, в которой все нулевые элементы заменены на 
            бесконечность.</P>
            <DIV id=mark_26 class=lecture_mark></DIV>
            <P id=id_31>Для определения самого кратчайшего пути введем массив 
            <SPAN class=texample>P</SPAN> вершин, где <SPAN 
            class=texample>P[v]</SPAN> будет содержать вершину, непосредственно 
            предшествующую вершине <SPAN class=texample>v</SPAN> в кратчайшем 
            пути (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/45/staldata_45.html#image.45.1">рис. 
            45.1</A>).</P>
            <DIV id=mark_31 class=lecture_mark></DIV>
            <P id=id_35 align=left><A name=image.45.1></A>
            <DIV><IMG alt="Демонстрация алгоритма Дейкстры" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/45_01.png" 
            width=562 height=195></DIV><BR><B>Рис. 45.1.</B>&nbsp; Демонстрация 
            алгоритма Дейкстры
            <P></P>
            <DIV id=mark_35 class=lecture_mark></DIV>
            <DIV class=example><PRE>//Описание функции алгоритма Дейкстры
void Dijkstra(int n, int **Graph, int Node){
  bool *S = new bool[n];
  int *D = new int[n];
  int *P = new int[n];
  int i, j;
  int Max_Sum = 0;
  for (i = 0 ; i &lt; n ; i++)
    for (j = 0 ; j &lt; n ; j++)
      Max_Sum += Graph[i][j];
  for (i = 0 ; i &lt; n ; i++)
    for (j = 0 ; j &lt; n ; j++)
      if (Graph[i][j] == 0) 
        Graph[i][j] = Max_Sum;
  for (i = 0 ; i &lt; n ; i++){
    S[i] = false;
    P[i] = Node;
    D[i] = Graph[Node][i];
  }
  S[Node] = true;
  P[Node] = -1;
  for ( i = 0 ; i &lt; n - 1 ; i++ ){
    int w = 0;
    for ( j = 1 ; j &lt; n ; j++ ){
      if (!S[w]){
        if (!S[j] &amp;&amp; D[j] &lt;= D[w])
          w = j;
      }
      else w++;
    }
    S[w] = true;
    for ( j = 1 ; j &lt; n ; j++ )
      if (!S[j])
        if (D[w] + Graph[w][j] &lt; D[j]){
          D[j] = D[w] + Graph[w][j];
          P[j] = w;
        }
  }
  for ( i = 0 ; i &lt; n ; i++ )
    printf("%5d",D[i]);
  cout &lt;&lt; endl;
  for ( i = 0 ; i &lt; n ; i++ )
    printf("%5d",P[i]+1);
  cout &lt;&lt; endl;
  delete [] P;
  delete [] D;
  delete [] S;
}
</PRE></DIV>
            <P id=id_37>Сложность алгоритма Дейкстры зависит от способа 
            нахождения вершины, а также способа хранения множества непосещенных 
            вершин и способа обновления длин.</P>
            <DIV id=mark_37 class=lecture_mark></DIV>
            <P id=id_38>Если для представления графа использовать матрицу 
            смежности, то время выполнения этого алгоритма имеет порядок <SPAN 
            class=texample>O(n<SUP>2</SUP>)</SPAN>, где <SPAN 
            class=texample>n</SPAN> – количество вершин графа.</P>
            <DIV id=mark_38 class=lecture_mark></DIV><A name=sect3></A>
            <H3>Алгоритм Флойда</H3>
            <P id=id_41>Рассматриваемый алгоритм иногда называют алгоритмом 
            Флойда-Уоршелла. Алгоритм Флойда-Уоршелла является алгоритмом на 
            графах, который разработан в 1962 году Робертом Флойдом и Стивеном 
            Уоршеллом. Он служит для нахождения кратчайших путей между всеми 
            парами вершин графа.</P>
            <DIV id=mark_41 class=lecture_mark></DIV>
            <P id=id_42>Метод Флойда непосредственно основывается на том факте, 
            что в графе с положительными весами ребер всякий неэлементарный 
            (содержащий более 1 ребра) кратчайший путь состоит из других 
            кратчайших путей.</P>
            <DIV id=mark_42 class=lecture_mark></DIV>
            <P id=id_43>Этот алгоритм более общий по сравнению с алгоритмом 
            Дейкстры, так как он находит кратчайшие пути между любыми двумя 
            вершинами графа.</P>
            <DIV id=mark_43 class=lecture_mark></DIV>
            <P id=id_44>В алгоритме Флойда используется матрица <SPAN 
            class=texample>A</SPAN> размером <SPAN class=texample>n&#215;n</SPAN>, в 
            которой вычисляются длины кратчайших путей. Элемент <SPAN 
            class=texample>A[i,j]</SPAN> равен расстоянию от вершины <SPAN 
            class=texample>i</SPAN> к вершине <SPAN class=texample>j</SPAN>, 
            которое имеет конечное значение, если существует ребро <SPAN 
            class=texample>(i,j)</SPAN>, и равен бесконечности в противном 
            случае.</P>
            <DIV id=mark_44 class=lecture_mark></DIV>
            <P id=id_51><SPAN class=xml_em_italic>Алгоритм Флойда</SPAN></P>
            <DIV id=mark_51 class=lecture_mark></DIV>
            <P id=id_52>Основная идея алгоритма. Пусть есть три вершины <SPAN 
            class=texample>i, j, k</SPAN> и заданы расстояния между ними. Если 
            выполняется неравенство <SPAN 
            class=texample>A[i,k]+A[k,j]&lt;A[i,j]</SPAN>, то целесообразно 
            заменить путь <SPAN class=texample>i<IMG 
            style="POSITION: relative; TOP: 2px" border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/srarr.gif" 
            width=15 height=18>j</SPAN> путем <SPAN class=texample>i<IMG 
            style="POSITION: relative; TOP: 2px" border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/srarr.gif" 
            width=15 height=18>k<IMG style="POSITION: relative; TOP: 2px" 
            border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/srarr.gif" 
            width=15 height=18>j</SPAN>. Такая замена выполняется систематически 
            в процессе выполнения данного алгоритма.</P>
            <DIV id=mark_52 class=lecture_mark></DIV>
            <P id=id_57>Шаг 0. Определяем начальную матрицу расстояния <SPAN 
            class=texample>A<SUB>0</SUB></SPAN> и матрицу последовательности 
            вершин <SPAN class=texample>S<SUB>0</SUB></SPAN>. Каждый 
            диагональный элемент обеих матриц равен 0, таким образом, показывая, 
            что эти элементы в вычислениях не участвуют. Полагаем <SPAN 
            class=texample>k = 1</SPAN>.</P>
            <DIV id=mark_57 class=lecture_mark></DIV>
            <P id=id_61>Основной шаг <SPAN class=texample>k</SPAN>. Задаем 
            строку <SPAN class=texample>k</SPAN> и столбец <SPAN 
            class=texample>k</SPAN> как ведущую строку и ведущий столбец. 
            Рассматриваем возможность применения замены описанной выше, ко всем 
            элементам <SPAN class=texample>A[i,j]</SPAN> матрицы <SPAN 
            class=texample>A<SUB>k-1</SUB></SPAN>. Если выполняется неравенство 
            <SPAN class=texample>A[i,k]+A[k,j]&lt;A[i,j], (i<IMG 
            style="POSITION: relative; TOP: 2px" border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/ne.gif" 
            width=8 height=18>k, j<IMG style="POSITION: relative; TOP: 2px" 
            border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/ne.gif" 
            width=8 height=18>k, i<IMG style="POSITION: relative; TOP: 2px" 
            border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/ne.gif" 
            width=8 height=18>j)</SPAN>, тогда выполняем следующие действия:</P>
            <DIV id=mark_61 class=lecture_mark></DIV>
            <OL id=id_68>
              <LI>создаем матрицу <SPAN class=texample>A<SUB>k</SUB></SPAN> 
              путем замены в матрице <SPAN class=texample>A<SUB>k-1</SUB></SPAN> 
              элемента <SPAN class=texample>A[i,j]</SPAN> на сумму <SPAN 
              class=texample>A[i,k]+A[k,j]</SPAN>;
              <LI>создаем матрицу <SPAN class=texample>S<SUB>k</SUB></SPAN> 
              путем замены в матрице <SPAN class=texample>S<SUB>k-1</SUB></SPAN> 
              элемента <SPAN class=texample>S[i,j]</SPAN> на <SPAN 
              class=texample>k</SPAN>. Полагаем <SPAN class=texample>k = k + 
              1</SPAN> и повторяем шаг <SPAN class=texample>k</SPAN>.</LI></OL>
            <DIV id=mark_68 class=lecture_mark></DIV>
            <P id=id_81>Таким образом, алгоритм Флойда делает <SPAN 
            class=texample>n</SPAN> итераций, после <SPAN 
            class=texample>i</SPAN>-й итерации матрица <SPAN 
            class=texample>А</SPAN> будет содержать длины кратчайших путей между 
            любыми двумя парами вершин при условии, что эти пути проходят через 
            вершины от первой до <SPAN class=texample>i</SPAN>-й. На каждой 
            итерации перебираются все пары вершин и путь между ними сокращается 
            при помощи <SPAN class=texample>i</SPAN>-й вершины (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/45/staldata_45.html#image.45.2">рис. 
            45.2</A>).</P>
            <DIV id=mark_81 class=lecture_mark></DIV>
            <P id=id_87 align=left><A name=image.45.2></A>
            <DIV><IMG alt="Демонстрация алгоритма Флойда" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/45_02.png" 
            width=495 height=225></DIV><BR><B>Рис. 45.2.</B>&nbsp; Демонстрация 
            алгоритма Флойда
            <P></P>
            <DIV id=mark_87 class=lecture_mark></DIV>
            <DIV class=example><PRE>//Описание функции алгоритма Флойда
void Floyd(int n, int **Graph, int **ShortestPath){
  int i, j, k;
  int Max_Sum = 0;
  for ( i = 0 ; i &lt; n ; i++ )
    for ( j = 0 ; j &lt; n ; j++ )
      Max_Sum += ShortestPath[i][j];
  for ( i = 0 ; i &lt; n ; i++ )
    for ( j = 0 ; j &lt; n ; j++ )
      if ( ShortestPath[i][j] == 0 &amp;&amp; i != j ) 
        ShortestPath[i][j] = Max_Sum;
  for ( k = 0 ; k &lt; n; k++ )
    for ( i = 0 ; i &lt; n; i++ )
      for ( j = 0 ; j &lt; n ; j++ )
        if ((ShortestPath[i][k] + ShortestPath[k][j]) &lt; 
             ShortestPath[i][j])
          ShortestPath[i][j] = ShortestPath[i][k] + 
            ShortestPath[k][j];
}
</PRE></DIV>
            <P id=id_89>Заметим, что если граф неориентированный, то все 
            матрицы, получаемые в результате преобразований симметричны и, 
            следовательно, достаточно вычислять только элементы, расположенные 
            выше главной диагонали.</P>
            <DIV id=mark_89 class=lecture_mark></DIV>
            <P id=id_90>Если граф представлен матрицей смежности, то время 
            выполнения этого алгоритма имеет порядок <SPAN 
            class=texample>O(n<SUP>3</SUP>)</SPAN>, поскольку в нем присутствуют 
            вложенные друг в друга три цикла.</P>
            <DIV id=mark_90 class=lecture_mark></DIV><A name=sect4></A>
            <H3>Переборные алгоритмы</H3>
            <P id=id_92>Переборные алгоритмы по сути своей являются алгоритмами 
            поиска, как правило, поиска оптимального решения. При этом решение 
            конструируется постепенно. В этом случае обычно говорят о переборе 
            вершин дерева вариантов. Вершинами такого графа будут промежуточные 
            или конечные варианты, а ребра будут указывать пути конструирования 
            вариантов.</P>
            <DIV id=mark_92 class=lecture_mark></DIV>
            <P id=id_93>Рассмотрим переборные алгоритмы, основанные на методах 
            поиска в графе, на примере задачи нахождения кратчайшего пути в 
            лабиринте.</P>
            <DIV id=mark_93 class=lecture_mark></DIV>
            <P id=id_94><SPAN class=xml_em_italic>Постановка задачи.</SPAN></P>
            <DIV id=mark_94 class=lecture_mark></DIV>
            <P id=id_95>Лабиринт, состоящий из проходимых и непроходимых клеток, 
            задан матрицей <SPAN class=texample>A</SPAN> размером <SPAN 
            class=texample>m&#215;n</SPAN>. Элемент матрицы <SPAN 
            class=texample>A[i,j]=0</SPAN>, если клетка <SPAN 
            class=texample>(i,j)</SPAN> проходима. В противном случае <SPAN 
            class=texample>A[i,j]=&#8734;</SPAN>.</P>
            <DIV id=mark_95 class=lecture_mark></DIV>
            <P id=id_101>Требуется найти длину кратчайшего пути из клетки <SPAN 
            class=texample>(1, 1)</SPAN> в клетку <SPAN class=texample>(m, 
            n)</SPAN>.</P>
            <DIV id=mark_101 class=lecture_mark></DIV>
            <P id=id_104>Фактически дана матрица смежности (только в ней нули 
            заменены бесконечностями, а единицы – нулями). Лабиринт представляет 
            собой граф.</P>
            <DIV id=mark_104 class=lecture_mark></DIV>
            <P id=id_105>Вершинами дерева вариантов в данной задаче являются 
            пути, начинающиеся в клетке <SPAN class=texample>(1, 1)</SPAN>. 
            Ребра – показывают ход конструирования этих путей и соединяют два 
            пути длины <SPAN class=texample>k</SPAN> и <SPAN 
            class=texample>k+1</SPAN>, где второй путь получается из первого 
            добавлением к пути еще одного хода.</P>
            <DIV id=mark_105 class=lecture_mark></DIV>
            <P id=id_109><SPAN class=xml_em_italic>Перебор с 
возвратом</SPAN></P>
            <DIV id=mark_109 class=lecture_mark></DIV>
            <P id=id_110>Данный метод основан на методе поиска в глубину. 
            Перебор с возвратом считают методом проб и ошибок ("попробуем 
            сходить в эту сторону: не получится – вернемся и попробуем в 
            другую"). Так как перебор вариантов осуществляется методом поиска в 
            глубину, то целесообразно во время работы алгоритма хранить текущий 
            путь в дереве. Этот путь представляет собой стек Way.</P>
            <DIV id=mark_110 class=lecture_mark></DIV>
            <P id=id_111>Также необходим массив <SPAN 
            class=texample>Dist</SPAN>, размерность которого соответствует 
            количеству вершин графа, хранящий для каждой вершины расстояние от 
            нее до исходной вершины.</P>
            <DIV id=mark_111 class=lecture_mark></DIV>
            <P id=id_113>Пусть текущей является некоторая клетка (в начале 
            работы алгоритма – клетка <SPAN class=texample>(1, 1)</SPAN>). Если 
            для текущей клетки есть клетка-сосед <SPAN 
            class=texample>Neighbor</SPAN>, отсутствующая в <SPAN 
            class=texample>Way</SPAN>, в которую на этом пути еще не ходили, то 
            добавляем <SPAN class=texample>Neighbor</SPAN> в <SPAN 
            class=texample>Way</SPAN> и текущей клетке присваиваем <SPAN 
            class=texample>Neighbor</SPAN>, иначе извлечь из <SPAN 
            class=texample>Way</SPAN>.</P>
            <DIV id=mark_113 class=lecture_mark></DIV>
            <P id=id_121>Приведенное выше описание дает четко понять, почему 
            этот метод называется перебором с возвратом. Возврату здесь 
            соответствует операция "извлечь из <SPAN class=texample>Way</SPAN>", 
            которая уменьшает длину <SPAN class=texample>Way</SPAN> на 1. </P>
            <DIV id=mark_121 class=lecture_mark></DIV>
            <P id=id_124>Перебор заканчивается, когда Way пуст и делается 
            попытка возврата назад. В этой ситуации возвращаться уже некуда (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/45/staldata_45.html#image.45.3">рис. 
            45.3</A>).</P>
            <DIV id=mark_124 class=lecture_mark></DIV>
            <P id=id_125><SPAN class=texample>Way</SPAN> является текущим путем, 
            но в процессе работы необходимо хранить и оптимальный путь <SPAN 
            class=texample>OptimalWay</SPAN>.</P>
            <DIV id=mark_125 class=lecture_mark></DIV>
            <P id=id_128>Усовершенствование алгоритма можно произвести следующим 
            образом: не позволять, чтобы длина <SPAN class=texample>Way</SPAN> 
            была больше или равна длине <SPAN class=texample>OptimalWay</SPAN>. 
            В этом случае, если и будет найден какой-то вариант, он заведомо не 
            будет оптимальным. Такое усовершенствование в общем случае означает, 
            что как только текущий путь станет заведомо неоптимальным, надо 
            вернуться назад. Данное улучшение алгоритма позволяет во многих 
            случаях сильно сократить перебор.</P>
            <DIV id=mark_128 class=lecture_mark></DIV>
            <P id=id_131 align=left><A name=image.45.3></A>
            <DIV><IMG alt="Демонстрация алгоритма перебора с возвратом" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/45_03.png" 
            width=550 height=328></DIV><BR><B>Рис. 45.3.</B>&nbsp; Демонстрация 
            алгоритма перебора с возвратом
            <P></P>
            <DIV id=mark_131 class=lecture_mark></DIV><A></A>
            <DIV class=example><PRE>/*Описание функции переборного алгоритма методом поиска в глубину */
void Backtracking(int n, int m, int **Maze){
  int Begin, End, Current;
  Begin = (n - 1) * m;
  End = m - 1;
  int *Way, *OptimalWay;
  int LengthWay, LengthOptimalWay;
  Way = new int[n*m];
  OptimalWay = new int[n*m];
  LengthWay = 0;
  LengthOptimalWay = m*n;
  for (int i = 0 ; i &lt; n*m ; i++ )
    Way[i] = OptimalWay[i] = -1;
  int *Dist;
  Dist = new int[n*m];
  for (int i = 0 ; i &lt; n ; i++ )
    for (int j = 0 ; j &lt; m ; j++ )
      Dist[i * m + j] = ( Maze[i][j] == 0 ? 0 : -1 );
  Way[LengthWay++] = Current = Begin;
  while ( LengthWay &gt; 0 ){
    if(Current == End){
      if (LengthWay &lt; LengthOptimalWay){
        for (int i = 0 ; i &lt; LengthWay ; i++ )
          OptimalWay[i] = Way[i];
        LengthOptimalWay = LengthWay;
      }
      if (LengthWay &gt; 0) Way[--LengthWay] = -1;
      Current = Way[LengthWay-1];
    }
    else{
      int Neighbor = -1;
      if ((Current/m - 1) &gt;= 0 &amp;&amp; !Insert(Way, Current - m) &amp;&amp;
        (Dist[Current - m] == 0 || Dist[Current - m] &gt; LengthWay)
        &amp;&amp; Dist[Current] &lt; LengthOptimalWay)
          Neighbor = Current - m;
      else 
        if ((Current%m - 1) &gt;= 0 &amp;&amp; !Insert(Way,Current - 1)&amp;&amp;
          (Dist[Current - 1]== 0 || Dist[Current - 1] &gt; LengthWay)
          &amp;&amp; Dist[Current] &lt; LengthOptimalWay )
            Neighbor = Current - 1;
        else 
          if ((Current%m + 1) &lt; m &amp;&amp; !Insert(Way,Current + 1) &amp;&amp;
           (Dist[Current + 1]== 0 || Dist[Current + 1] &gt; LengthWay)
          &amp;&amp; Dist[Current] &lt; LengthOptimalWay )
            Neighbor = Current + 1;
         else 
           if ((Current/m + 1) &lt; n &amp;&amp; !Insert(Way,Current + m) &amp;&amp;
            (Dist[Current + m]== 0 || Dist[Current + m] &gt; LengthWay)
           &amp;&amp; Dist[Current] &lt; LengthOptimalWay )
             Neighbor = Current + m;
      if ( Neighbor != -1 ){
        Way[LengthWay++] = Neighbor;
        Dist[Neighbor] = Dist[Current] + 1;
        Current = Neighbor;
      }
      else {
        if (LengthWay &gt; 0) Way[--LengthWay] = -1;
        Current = Way[LengthWay-1];
      }
    }
  }
  if ( LengthOptimalWay &lt; n*m ) 
    cout &lt;&lt; endl &lt;&lt; "Yes. Length way=" &lt;&lt; LengthOptimalWay&lt;&lt; endl;
  else cout &lt;&lt; endl &lt;&lt; "No" &lt;&lt; endl;
}
</PRE><SPAN class=objectName>Листинг . </SPAN></DIV>
            <P id=id_133><SPAN class=xml_em_italic>Волновой алгоритм</SPAN></P>
            <DIV id=mark_133 class=lecture_mark></DIV>
            <P id=id_134>Этот переборный алгоритм, который основан на поиске в 
            ширину, состоит из двух этапов:</P>
            <DIV id=mark_134 class=lecture_mark></DIV>
            <OL id=id_135>
              <LI>распространение волны;
              <LI>обратный ход.</LI></OL>
            <DIV id=mark_135 class=lecture_mark></DIV>
            <P id=id_138>Распространение волны и есть собственно поиск в ширину, 
            при котором клетки помечаются номером шага метода, на котором клетка 
            посещается. При обратном ходе, начиная с конечной вершины, идет 
            восстановление пути, по которому в нее попали путем включения в него 
            клеток с минимальной пометкой (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/45/staldata_45.html#image.45.4">рис. 
            45.4</A>). Важной особенностью является то, что восстановление 
            начинается с конца (с начала оно зачастую невозможно).</P>
            <DIV id=mark_138 class=lecture_mark></DIV>
            <P id=id_139 align=left><A name=image.45.4></A>
            <DIV><IMG alt="Демонстрация волнового алгоритма" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/45_04.png" 
            width=550 height=316></DIV><BR><B>Рис. 45.4.</B>&nbsp; Демонстрация 
            волнового алгоритма
            <P></P>
            <DIV id=mark_139 class=lecture_mark></DIV>
            <P id=id_140>Заметим, что перебор методом поиска в ширину по 
            сравнению с перебором с возвратом, как правило, требует больше 
            вспомогательной памяти, которая необходима для хранения информации, 
            чтобы построить путь при обратном ходе и пометить посещенные 
            вершины. Однако он работает быстрее, так как совершенно исключается 
            посещение одной и той же клетки более чем один раз.</P>
            <DIV id=mark_140 class=lecture_mark></DIV><A name=sect5></A>
            <H3>Ключевые термины</H3>
            <P id=id_141><B>Алгоритм Дейкстры</B> – это алгоритм нахождения 
            кратчайшего пути от одной из вершин графа до всех остальных, который 
            работает только для графов без ребер отрицательного веса.</P>
            <DIV id=mark_141 class=lecture_mark></DIV>
            <P id=id_142><B>Алгоритм Флойда</B> – это алгоритм поиска 
            кратчайшего пути между любыми двумя вершинами графа.</P>
            <DIV id=mark_142 class=lecture_mark></DIV>
            <P id=id_143><B>Волновой алгоритм</B> – это переборный алгоритм, 
            который основан на поиске в ширину и состоит из двух этапов: 
            распространение волны и обратный ход.</P>
            <DIV id=mark_143 class=lecture_mark></DIV>
            <P id=id_144><B>Кратчайший путь</B> – это путь в графе, то есть 
            последовательность вершин и ребер, инцидентных двум соседним 
            вершинам, и его длина.</P>
            <DIV id=mark_144 class=lecture_mark></DIV>
            <P id=id_145><B>Переборный алгоритм</B> – это алгоритм обхода графа, 
            основанный на последовательном переборе возможных путей.</P>
            <DIV id=mark_145 class=lecture_mark></DIV><A name=sect6></A>
            <H3>Краткие итоги</H3>
            <OL id=id_146>
              <LI>Нахождение кратчайшего пути на сегодняшний день является 
              актуальной задачей
              <LI>К наиболее эффективным алгоритмам нахождения кратчайшего пути 
              в графах относятся алгоритм Дейкстры, алгоритм Флойда и переборные 
              алгоритмы. Эти алгоритмы эффективны при достаточно небольших 
              количествах вершин.
              <LI>В реализации алгоритма Дейкстры строится множество вершин, для 
              которых кратчайшие пути от начальной вершины уже известны. 
              Следующие шаги основаны на добавлении к имеющемуся множеству по 
              одной вершине с сохранением длин оптимальных путей.
              <LI>Сложность алгоритма Дейкстры зависит от способа нахождения 
              вершины, а также способа хранения множества непосещенных вершин и 
              способа обновления длин.
              <LI>Метод Флойда основывается на факте, что в графе с 
              положительными весами ребер всякий неэлементарный кратчайший путь 
              состоит из других кратчайших путей. 
              <LI>Если граф представлен матрицей смежности, то время выполнения 
              алгоритма Флойда имеет порядок <SPAN 
              class=texample>O(n<SUP>3</SUP>)</SPAN>.
              <LI>Переборные алгоритмы являются алгоритмами поиска оптимального 
              решения.
              <LI>Волновой алгоритм является переборным алгоритмом, который 
              основан на поиске в ширину и состоит из двух этапов: 
              распространение волны и обратный ход.
              <LI>Перебор методом поиска в ширину, по сравнению с перебором с 
              возвратом, требует больше вспомогательной памяти для хранения 
              информации, однако, он работает быстрее, так как исключается 
              посещение одной и той же вершины более чем один раз.</LI></OL>
            <DIV id=mark_146 class=lecture_mark></DIV><A name=sect7></A>
            <H3>Лабораторная работа 45. Алгоритмы на графах. Алгоритмы 
            нахождения кратчайшего пути</H3>
            <P id=id_157><B>Цель работы:</B> изучить основные алгоритмы поиска 
            кратчайшего пути и научиться решать задачи поиска кратчайшего пути 
            на основе алгоритмов Дейкстры, Флойда и переборных алгоритмов.</P>
            <DIV id=mark_157 class=lecture_mark></DIV>
            <P id=id_158>При выполнении лабораторной работы для каждого задания 
            требуется написать программу на языке С++, которая получает на входе 
            числовые данные, выполняет их обработку в соответствии с 
            требованиями задания и выводит результат на экран. Для обработки 
            данных необходимо реализовать алгоритмы поиска кратчайшего пути на 
            графе на основе алгоритмов Дейкстры, Флойда и переборных алгоритмов 
            в соответствии с постановкой задачи. Ввод данных осуществляется из 
            файла с учетом требований к входным данным, содержащихся в 
            постановке задачи. Ограничениями на входные данные является 
            допустимый диапазон значений используемых числовых типов в языке 
            С++.</P>
            <DIV id=mark_158 class=lecture_mark></DIV>
            <P id=id_159><B>Теоретические сведения.</B></P>
            <DIV id=mark_159 class=lecture_mark></DIV>
            <P id=id_160>Ознакомьтесь с материалом лекции 45.</P>
            <DIV id=mark_160 class=lecture_mark></DIV>
            <P id=id_161><B>Задания к лабораторной работе.</B></P>
            <DIV id=mark_161 class=lecture_mark></DIV>
            <P id=id_162>Выполните приведенные ниже задания.</P>
            <DIV id=mark_162 class=lecture_mark></DIV>
            <OL id=id_163>
              <LI>На основании приведенной в лекции 45 функций реализуйте 
              программы, в которых выполняются алгоритм Дейкстры и алгоритм 
              Флойда.
              <LI>На основании приведенной в лекции функции реализуйте 
              программу, в которой выполняется переборный алгоритм методом 
              поиска в ширину.
              <LI>Оля (A), Маша (B), Витя (C), Дима (D), Ваня (E) и Катя (F) 
              живут в разных городах. Стоимость билетов из разных городов 
              известна (рис.). Добраться до городов можно разными способами. 
              Определить наименьшую сумму, которую нужно потратить, чтобы Оля 
              могла навестить каждого из своих друзей. 
              <P id=id_167 align=left><A></A>
              <DIV><IMG alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/45_001.png"></DIV><BR>
              <P></P>
              <DIV id=mark_167 class=lecture_mark></DIV>
              <LI>Квадратное озеро задается матрицей <SPAN 
              class=texample>M&#215;N</SPAN> и покрыто мелкими островками. В левом 
              верхнем углу находится плот размером <SPAN 
              class=texample>m&#215;m</SPAN>. За один шаг плот может передвигаться на 
              одну клетку по вертикали или горизонтали. Требуется определить 
              кратчайший путь плота до правого нижнего угла.
              <LI>Напишите алгоритм, находящий строку длиной 100 символов, 
              состоящую только из букв "A", "B", "C", такую, что в ней никакие 
              две соседние подстроки не равны друг другу. Воспользуйтесь 
              перебором с возвратом.</LI></OL>
            <DIV id=mark_163 class=lecture_mark></DIV>
            <P id=id_172>Указания к выполнению работы.</P>
            <DIV id=mark_172 class=lecture_mark></DIV>
            <P id=id_173>Каждое задание необходимо решить в соответствии с 
            изученными алгоритмами поиска кратчайшего пути на графе на основе 
            алгоритмов Дейкстры, Флойда и переборных алгоритмов, реализовав 
            программный код на языке С++. Рекомендуется воспользоваться 
            материалами лекции 45, где подробно рассматриваются описания 
            алгоритмов поиска кратчайшего пути на графе, примеры разработки 
            функций, реализующих алгоритмы поиска на графе, на языке С++. 
            Программу для решения каждого задания необходимо разработать методом 
            процедурной абстракции, используя функции. Этапы решения сопроводить 
            комментариями в коде. В отчете следует отразить разработку и 
            обоснование математической модели решения задачи, представить 
            результаты тестирования программ.</P>
            <DIV id=mark_173 class=lecture_mark></DIV>
            <P id=id_174>Следует реализовать каждое задание в соответствии с 
            приведенными этапами:</P>
            <DIV id=mark_174 class=lecture_mark></DIV>
            <UL id=id_175>
              <LI>изучить словесную постановку задачи, выделив при этом все виды 
              данных;
              <LI>сформулировать математическую постановку задачи;
              <LI>выбрать метод решения задачи, если это необходимо;
              <LI>разработать графическую схему алгоритма;
              <LI>записать разработанный алгоритм на языке С++;
              <LI>разработать контрольный тест к программе;
              <LI>отладить программу;
              <LI>представить отчет по работе.</LI></UL>
            <DIV id=mark_175 class=lecture_mark></DIV>
            <P id=id_184><B>Требования к отчету.</B></P>
            <DIV id=mark_184 class=lecture_mark></DIV>
            <P id=id_185>Отчет по лабораторной работе должен соответствовать 
            следующей структуре.</P>
            <DIV id=mark_185 class=lecture_mark></DIV>
            <UL id=id_186>
              <LI>Титульный лист.
              <LI>Словесная постановка задачи. В этом подразделе проводится 
              полное описание задачи. Описывается суть задачи, анализ входящих в 
              нее физических величин, область их допустимых значений, единицы их 
              измерения, возможные ограничения, анализ условий при которых 
              задача имеет решение (не имеет решения), анализ ожидаемых 
              результатов.
              <LI>Математическая модель. В этом подразделе вводятся 
              математические описания физических величин и математическое 
              описание их взаимодействий. Цель подраздела – представить решаемую 
              задачу в математической формулировке.
              <LI>Алгоритм решения задачи. В подразделе описывается разработка 
              структуры алгоритма, обосновывается абстракция данных, задача 
              разбивается на подзадачи. Схема алгоритма выполняется по ЕСПД 
              (ГОСТ 19.003-80 и ГОСТ 19.002-80).
              <LI>Листинг программы. Подраздел должен содержать текст программы 
              на языке программирования С++, реализованный в среде MS Visual 
              Studio 2010.
              <LI>Контрольный тест. Подраздел содержит наборы исходных данных и 
              полученные в ходе выполнения программы результаты.
              <LI>Выводы по лабораторной работе. 
              <LI>Ответы на контрольные вопросы.</LI></UL>
            <DIV id=mark_186 class=lecture_mark></DIV>
            <P id=id_195><B>Контрольные вопросы</B></P>
            <DIV id=mark_195 class=lecture_mark></DIV>
            <OL id=id_196>
              <LI>С какими видами графов работают алгоритмы Дейкстры, Флойда и 
              переборные алгоритмы?
              <LI>Как от представления графа зависит эффективность алгоритма его 
              обхода?
              <LI>За счет чего поиск в ширину является достаточно ресурсоемким 
              алгоритмом?
              <LI>В чем преимущества алгоритмов обхода графа в ширину?
              <LI>Каким образом в алгоритме перебора с возвратом при обходе 
              графа обрабатывается посещение тупиковых вершин?
              <LI>Поясните на примере обхода графа этап обратного хода в 
              волновом алгоритме. Почему его удобно выполнять с конца?
              <LI>При программной реализации алгоритмов обхода графа с помощью 
              рекурсии что выделяется в качестве базы и как организована 
              декомпозиция? </LI></OL>
            <DIV id=mark_196 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript 
src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/urchin.js">
</SCRIPT>

<SCRIPT 
type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
