<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0071)http://www.intuit.ru/department/algorithms/staldata/43/staldata_43.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/printable.css">
<META name=GENERATOR content="MSHTML 9.00.8080.16413"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="COLOR: #000000; FONT-WEIGHT: bold">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD>
    <TD><!-- content -->
      <TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD class=head>Структуры и алгоритмы компьютерной обработки 
        данных</TD></TR>
        <TR>
          <TD height=4><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>43. Лекция: Алгоритмы сортировки массивов. 
            Внешняя сортировка: версия для печати и PDA</SPAN> <BR><SPAN 
            class=rtxt>В лекции рассматриваются определение и классификация 
            алгоритмов внешних сортировок, понятия фаз и путей в алгоритмах 
            внешних сортировок, приводятся описания и реализации алгоритмов 
            внешней сортировки слиянием и естественной сортировки. </SPAN></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3></H3>
            <P id=id_1><B>Цель лекции:</B> изучить основные алгоритмы внешних 
            сортировок, научиться решать задачи сортировок массивов различными 
            методами и выполнять оценку эффективности алгоритмов внешней 
            сортировки.</P>
            <DIV id=mark_1 class=lecture_mark></DIV>
            <P id=id_2>Внешние сортировки применяются к данным, которые хранятся 
            во внешней памяти. При выполнении таких сортировок требуется 
            работать с данными, расположенными на внешних устройствах 
            последовательного доступа. Для файлов, расположенных на таких 
            устройствах в каждый момент времени доступен только один компонент 
            последовательности данных, что является существенным ограничением по 
            сравнению с сортировкой массивов, где всегда доступен каждый 
            элемент.</P>
            <DIV id=mark_2 class=lecture_mark></DIV>
            <P id=id_3><B>Внешняя сортировка</B> – это сортировка данных, 
            которые расположены на внешних устройствах и не вмещающихся в 
            оперативную память. </P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <P id=id_4>Данные, хранящиеся на внешних устройствах, имеют большой 
            объем, что не позволяет их целиком переместить в оперативную память, 
            отсортировать с использованием одного из алгоритмов внутренней 
            сортировки, а затем вернуть их на внешнее устройство. В этом случае 
            осуществлялось бы минимальное количество проходов через файл, то 
            есть было бы однократное чтение и однократная запись данных. Однако 
            на практике приходится осуществлять чтение, обработку и запись 
            данных в файл по блокам, размер которых зависит от операционной 
            системы и имеющегося объема оперативной памяти, что приводит к 
            увеличению числа проходов через файл и заметному снижению скорости 
            сортировки.</P>
            <DIV id=mark_4 class=lecture_mark></DIV>
            <P id=id_5>К наиболее известным алгоритмам внешних сортировок 
            относятся:</P>
            <DIV id=mark_5 class=lecture_mark></DIV>
            <UL id=id_6>
              <LI>сортировки слиянием (простое слияние и естественное слияние);
              <LI>улучшенные сортировки (многофазная сортировка и каскадная 
              сортировка).</LI></UL>
            <DIV id=mark_6 class=lecture_mark></DIV>
            <P id=id_9>Из представленных внешних сортировок наиболее важным 
            является метод сортировки с помощью слияния. Прежде чем описывать 
            алгоритм сортировки слиянием введем несколько определений.</P>
            <DIV id=mark_9 class=lecture_mark></DIV>
            <P id=id_10>Основным понятием при использовании внешней сортировки 
            является понятие серии. <B>Серия (упорядоченный отрезок)</B> – это 
            последовательность элементов, которая упорядочена по ключу.</P>
            <DIV id=mark_10 class=lecture_mark></DIV>
            <P id=id_11>Количество элементов в серии называется <B>длиной 
            серии</B>. Серия, состоящая из одного элемента, упорядочена всегда. 
            Последняя серия может иметь длину меньшую, чем остальные серии 
            файлов. Максимальное количество серий в файле <SPAN 
            class=texample>N</SPAN> (все элементы не упорядочены). Минимальное 
            количество серий одна (все элементы упорядочены).</P>
            <DIV id=mark_11 class=lecture_mark></DIV>
            <P id=id_13>В основе большинства методов внешних сортировок лежит 
            <SPAN class=xml_em_italic>процедура слияния</SPAN> и <SPAN 
            class=xml_em_italic>процедура распределения</SPAN>. <B>Слияние</B> – 
            это процесс объединения двух (или более) упорядоченных серий в одну 
            упорядоченную последовательность при помощи циклического выбора 
            элементов доступных в данный момент. <B>Распределение</B> – это 
            процесс разделения упорядоченных серий на два и несколько 
            вспомогательных файла.</P>
            <DIV id=mark_13 class=lecture_mark></DIV>
            <P id=id_14><B>Фаза</B> – это действия по однократной обработке всей 
            последовательности элементов. <B>Двухфазная сортировка</B> – это 
            сортировка, в которой отдельно реализуется две фазы: распределение и 
            слияние. <B>Однофазная сортировка</B> – это сортировка, в которой 
            объединены фазы распределения и слияния в одну. </P>
            <DIV id=mark_14 class=lecture_mark></DIV>
            <P id=id_15><B>Двухпутевым слиянием</B> называется сортировка, в 
            которой данные распределяются на два вспомогательных файла. 
            <B>Многопутевым слиянием</B> называется сортировка, в которой данные 
            распределяются на <SPAN class=texample>N (N &gt; 2)</SPAN> 
            вспомогательных файлов.</P>
            <DIV id=mark_15 class=lecture_mark></DIV>
            <P id=id_17><SPAN class=xml_em_italic>Общий алгоритм сортировки 
            слиянием</SPAN></P>
            <DIV id=mark_17 class=lecture_mark></DIV>
            <P id=id_18>Сначала серии распределяются на два или более 
            вспомогательных файлов. Данное распределение идет поочередно: первая 
            серия записывается в первый вспомогательный файл, вторая – во второй 
            и так далее до последнего вспомогательного файла. Затем опять запись 
            серии начинается в первый вспомогательный файл. После распределения 
            всех серий, они объединяются в более длинные упорядоченные отрезки, 
            то есть из каждого вспомогательного файла берется по одной серии, 
            которые сливаются. Если в каком-то файле серия заканчивается, то 
            переход к следующей серии не осуществляется. В зависимости от вида 
            сортировки сформированная более длинная упорядоченная серия 
            записывается либо в исходный файл, либо в один из вспомогательных 
            файлов. После того как все серии из всех вспомогательных файлов 
            объединены в новые серии, потом опять начинается их распределение. И 
            так до тех пор, пока все данные не будут отсортированы.</P>
            <DIV id=mark_18 class=lecture_mark></DIV>
            <P id=id_19>Выделим основные <SPAN 
            class=xml_em_italic>характеристики сортировки слиянием</SPAN>:</P>
            <DIV id=mark_19 class=lecture_mark></DIV>
            <UL id=id_20>
              <LI>количество фаз в реализации сортировки;
              <LI>количество вспомогательных файлов, на которые распределяются 
              серии.</LI></UL>
            <DIV id=mark_20 class=lecture_mark></DIV>
            <P id=id_23>Рассмотрим основные и наиболее важные алгоритмы внешних 
            сортировок более подробно.</P>
            <DIV id=mark_23 class=lecture_mark></DIV><A name=sect2></A>
            <H3>Сортировка простым слиянием</H3>
            <P id=id_24>Одна из сортировок на основе слияния называется <SPAN 
            class=xml_em_italic>простым слиянием</SPAN>.</P>
            <DIV id=mark_24 class=lecture_mark></DIV>
            <P id=id_25>Алгоритм сортировки простым слияния является простейшим 
            алгоритмом внешней сортировки, основанный на процедуре слияния 
            серией.</P>
            <DIV id=mark_25 class=lecture_mark></DIV>
            <P id=id_26>В данном алгоритме длина серий фиксируется на каждом 
            шаге. В исходном файле все серии имеют длину 1, после первого шага 
            она равна 2, после второго – 4, после третьего – 8, после <SPAN 
            class=texample>k</SPAN>-го шага – <SPAN 
            class=texample>2<SUP>k</SUP></SPAN>.</P>
            <DIV id=mark_26 class=lecture_mark></DIV>
            <P id=id_29><SPAN class=xml_em_italic>Алгоритм сортировки простым 
            слиянием</SPAN></P>
            <DIV id=mark_29 class=lecture_mark></DIV>
            <P id=id_30>Шаг 1. Исходный файл <SPAN class=texample>f</SPAN> 
            разбивается на два вспомогательных файла <SPAN 
            class=texample>f1</SPAN> и <SPAN class=texample>f2</SPAN>.</P>
            <DIV id=mark_30 class=lecture_mark></DIV>
            <P id=id_34>Шаг 2. Вспомогательные файлы <SPAN 
            class=texample>f1</SPAN> и <SPAN class=texample>f2</SPAN> сливаются 
            в файл <SPAN class=texample>f</SPAN>, при этом одиночные элементы 
            образуют упорядоченные пары.</P>
            <DIV id=mark_34 class=lecture_mark></DIV>
            <P id=id_38>Шаг 3. Полученный файл <SPAN class=texample>f</SPAN> 
            вновь обрабатывается, как указано в шагах 1 и 2. При этом 
            упорядоченные пары переходят в упорядоченные четверки.</P>
            <DIV id=mark_38 class=lecture_mark></DIV>
            <P id=id_40>Шаг 4. Повторяя шаги, сливаем четверки в восьмерки и 
            т.д., каждый раз удваивая длину слитых последовательностей до тех 
            пор, пока не будет упорядочен целиком весь файл (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/43/staldata_43.html#image.43.1">рис. 
            43.1</A>).</P>
            <DIV id=mark_40 class=lecture_mark></DIV>
            <P id=id_41>После выполнения <SPAN class=texample>i</SPAN> проходов 
            получаем два файла, состоящих из серий длины <SPAN 
            class=texample>2<SUP>i</SUP></SPAN>. Окончание процесса происходит 
            при выполнении условия <SPAN class=texample>2<SUP>i</SUP><IMG 
            style="POSITION: relative; TOP: 2px" border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/ge.gif" 
            width=8 height=18>n</SPAN>. Следовательно, процесс сортировки 
            простым слиянием требует порядка <SPAN class=texample>O(log 
            n)</SPAN> проходов по данным.</P>
            <DIV id=mark_41 class=lecture_mark></DIV>
            <P id=id_46>Признаками конца сортировки простым слиянием являются 
            следующие условия:</P>
            <DIV id=mark_46 class=lecture_mark></DIV>
            <UL id=id_47>
              <LI>длина серии не меньше количества элементов в файле 
              (определяется после фазы слияния);
              <LI>количество серий равно 1 (определяется на фазе слияния).
              <LI>при однофазной сортировке второй по счету вспомогательный файл 
              после распределения серий остался пустым. </LI></UL>
            <DIV id=mark_47 class=lecture_mark></DIV>
            <P id=id_51 align=left><A name=image.43.1></A>
            <DIV><IMG 
            alt="Демонстрация сортировки двухпутевым двухфазным простым слиянием" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/43_01.png" 
            width=634 height=269></DIV><BR><B>Рис. 43.1.</B>&nbsp; Демонстрация 
            сортировки двухпутевым двухфазным простым слиянием
            <P></P>
            <DIV id=mark_51 class=lecture_mark></DIV><A></A>
            <DIV class=example><PRE>//Описание функции сортировки простым слиянием
void Simple_Merging_Sort (char *name){
  int a1, a2, k, i, j, kol, tmp;
  FILE *f, *f1, *f2;
  kol = 0;
  if ( (f = fopen(name,"r")) == NULL )
    printf("\nИсходный файл не может быть прочитан...");
  else {
    while ( !feof(f) ) {
      fscanf(f,"%d",&amp;a1);
      kol++;
    }
    fclose(f);
  }
  k = 1;
  while ( k &lt; kol ){
    f = fopen(name,"r");
    f1 = fopen("smsort_1","w");
    f2 = fopen("smsort_2","w");
    if ( !feof(f) ) fscanf(f,"%d",&amp;a1);
    while ( !feof(f) ){
      for ( i = 0; i &lt; k &amp;&amp; !feof(f) ; i++ ){
        fprintf(f1,"%d ",a1);
        fscanf(f,"%d",&amp;a1);
      }
      for ( j = 0; j &lt; k &amp;&amp; !feof(f) ; j++ ){
        fprintf(f2,"%d ",a1);
        fscanf(f,"%d",&amp;a1);
      }
    }
    fclose(f2);
    fclose(f1);
    fclose(f);

    f = fopen(name,"w");
    f1 = fopen("smsort_1","r");
    f2 = fopen("smsort_2","r");
    if ( !feof(f1) ) fscanf(f1,"%d",&amp;a1);
    if ( !feof(f2) ) fscanf(f2,"%d",&amp;a2);
    while ( !feof(f1) &amp;&amp; !feof(f2) ){
      i = 0;
      j = 0;
      while ( i &lt; k &amp;&amp; j &lt; k &amp;&amp; !feof(f1) &amp;&amp; !feof(f2) ) {
        if ( a1 &lt; a2 ) {
          fprintf(f,"%d ",a1);
          fscanf(f1,"%d",&amp;a1);
          i++;
        }
        else {
          fprintf(f,"%d ",a2);
          fscanf(f2,"%d",&amp;a2);
          j++;
        }
      }
      while ( i &lt; k &amp;&amp; !feof(f1) ) {
        fprintf(f,"%d ",a1);
        fscanf(f1,"%d",&amp;a1);
        i++;
      }
      while ( j &lt; k &amp;&amp; !feof(f2) ) {
        fprintf(f,"%d ",a2);
        fscanf(f2,"%d",&amp;a2);
        j++;
      }
    }
    while ( !feof(f1) ) {
      fprintf(f,"%d ",a1);
      fscanf(f1,"%d",&amp;a1);
    }
    while ( !feof(f2) ) {
      fprintf(f,"%d ",a2);
      fscanf(f2,"%d",&amp;a2);
    }
    fclose(f2);
    fclose(f1);
    fclose(f);
    k *= 2;
  }
  remove("smsort_1");
  remove("smsort_2");
}
</PRE><SPAN class=objectName>Листинг . </SPAN></DIV>
            <P id=id_53>Заметим, что для выполнения внешней сортировки методом 
            простого слияния в оперативной памяти требуется расположить всего 
            лишь две переменные – для размещения очередных элементов (записей) 
            из вспомогательных файлов. Исходный и вспомогательные файлы будут 
            <SPAN class=texample>O(log n)</SPAN> раз прочитаны и столько же раз 
            записаны.</P>
            <DIV id=mark_53 class=lecture_mark></DIV><A name=sect3></A>
            <H3>Сортировка естественным слиянием</H3>
            <P id=id_55>В случае простого слияния частичная упорядоченность 
            сортируемых данных не дает никакого преимущества. Это объясняется 
            тем, что на каждом проходе сливаются серии фиксированной длины. При 
            естественном слиянии длина серий не ограничивается, а определяется 
            количеством элементов в уже упорядоченных подпоследовательностях, 
            выделяемых на каждом проходе.</P>
            <DIV id=mark_55 class=lecture_mark></DIV>
            <P id=id_56>Сортировка, при которой всегда сливаются две самые 
            длинные из возможных последовательностей, является естественным 
            слиянием. В данной сортировке объединяются серии максимальной 
            длины.</P>
            <DIV id=mark_56 class=lecture_mark></DIV>
            <P id=id_57><SPAN class=xml_em_italic>Алгоритм сортировки 
            естественным слиянием</SPAN></P>
            <DIV id=mark_57 class=lecture_mark></DIV>
            <P id=id_58>Шаг 1. Исходный файл <SPAN class=texample>f</SPAN> 
            разбивается на два вспомогательных файла <SPAN 
            class=texample>f1</SPAN> и <SPAN class=texample>f2</SPAN>. 
            Распределение происходит следующим образом: поочередно считываются 
            записи <SPAN class=texample>a<SUB>i</SUB></SPAN> исходной 
            последовательности (неупорядоченной) таким образом, что если 
            значения ключей соседних записей удовлетворяют условию <SPAN 
            class=texample>f(a<SUB>i</SUB>)<IMG 
            style="POSITION: relative; TOP: 2px" border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/le.gif" 
            width=8 height=18>f(a<SUB>i+1</SUB>)</SPAN>, то они записываются в 
            первый вспомогательный файл <SPAN class=texample>f1</SPAN>. Как 
            только встречаются <SPAN 
            class=texample>f(a<SUB>i</SUB>)&gt;f(a<SUB>i+1</SUB>)</SPAN>, то 
            записи <SPAN class=texample>a<SUB>i+1</SUB></SPAN> копируются во 
            второй вспомогательный файл <SPAN class=texample>f2</SPAN>. 
            Процедура повторяется до тех пор, пока все записи исходной 
            последовательности не будут распределены по файлам.</P>
            <DIV id=mark_58 class=lecture_mark></DIV>
            <P id=id_68>Шаг 2. Вспомогательные файлы <SPAN 
            class=texample>f1</SPAN> и <SPAN class=texample>f2</SPAN> сливаются 
            в файл <SPAN class=texample>f</SPAN>, при этом серии образуют 
            упорядоченные последовательности.</P>
            <DIV id=mark_68 class=lecture_mark></DIV>
            <P id=id_72>Шаг 3. Полученный файл <SPAN class=texample>f</SPAN> 
            вновь обрабатывается, как указано в шагах 1 и 2.</P>
            <DIV id=mark_72 class=lecture_mark></DIV>
            <P id=id_74>Шаг 4. Повторяя шаги, сливаем упорядоченные серии до тех 
            пор, пока не будет упорядочен целиком весь файл.</P>
            <DIV id=mark_74 class=lecture_mark></DIV>
            <P id=id_75>Символ "`" обозначает признак конца серии.</P>
            <DIV id=mark_75 class=lecture_mark></DIV>
            <P id=id_76>Признаками конца сортировки естественным слиянием 
            являются следующие условия:</P>
            <DIV id=mark_76 class=lecture_mark></DIV>
            <UL id=id_77>
              <LI>количество серий равно 1 (определяется на фазе слияния).
              <LI>при однофазной сортировке второй по счету вспомогательный файл 
              после распределения серий остался пустым.</LI></UL>
            <DIV id=mark_77 class=lecture_mark></DIV>
            <P id=id_80>Естественное слияние, у которого после фазы 
            распределения количество серий во вспомогательных файлах отличается 
            друг от друга не более чем на единицу, называется <SPAN 
            class=xml_em_italic>сбалансированным слиянием</SPAN>, в противном 
            случае – <SPAN class=xml_em_italic>несбалансированное 
            слияние</SPAN>.</P>
            <DIV id=mark_80 class=lecture_mark></DIV>
            <P id=id_81 align=left><A name=image.43.2></A>
            <DIV><IMG 
            alt="Демонстрация сортировки двухпутевым двухфазным естественным слиянием" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/43_02.png" 
            width=652 height=267></DIV><BR><B>Рис. 43.2.</B>&nbsp; Демонстрация 
            сортировки двухпутевым двухфазным естественным слиянием
            <P></P>
            <DIV id=mark_81 class=lecture_mark></DIV><A></A>
            <DIV class=example><PRE>//Описание функции сортировки естественным слиянием
void Natural_Merging_Sort (char *name){
  int s1, s2, a1, a2, mark;
  FILE *f, *f1, *f2;
  s1 = s2 = 1;
  while ( s1 &gt; 0 &amp;&amp; s2 &gt; 0 ){
    mark = 1;
    s1 = 0;
    s2 = 0;
    f = fopen(name,"r");
    f1 = fopen("nmsort_1","w");
    f2 = fopen("nmsort_2","w");
    fscanf(f,"%d",&amp;a1);
    if ( !feof(f) ) {
      fprintf(f1,"%d ",a1);
    }
    if ( !feof(f) ) fscanf(f,"%d",&amp;a2);
    while ( !feof(f) ){
      if ( a2 &lt; a1 ) {
        switch (mark) {
          case 1:{fprintf(f1,"' "); mark = 2; s1++; break;}
          case 2:{fprintf(f2,"' "); mark = 1; s2++; break;}
        }
      }
      if ( mark == 1 ) { fprintf(f1,"%d ",a2); s1++; }
      else { fprintf(f2,"%d ",a2); s2++;}
      a1 = a2;
      fscanf(f,"%d",&amp;a2);
    }
    if ( s2 &gt; 0 &amp;&amp; mark == 2 ) { fprintf(f2,"'");}
    if ( s1 &gt; 0 &amp;&amp; mark == 1 ) { fprintf(f1,"'");}
    fclose(f2);
    fclose(f1);
    fclose(f);
    
    cout &lt;&lt; endl;
    Print_File(name);
    Print_File("nmsort_1");
    Print_File("nmsort_2");
    cout &lt;&lt; endl;
    
    f = fopen(name,"w");
    f1 = fopen("nmsort_1","r");
    f2 = fopen("nmsort_2","r");
    if ( !feof(f1) ) fscanf(f1,"%d",&amp;a1);
    if ( !feof(f2) ) fscanf(f2,"%d",&amp;a2);
    bool file1, file2;
    while ( !feof(f1) &amp;&amp; !feof(f2) ){
      file1 = file2 = false;
      while ( !file1 &amp;&amp; !file2 ) {
        if ( a1 &lt;= a2 ) {
          fprintf(f,"%d ",a1);
          file1 = End_Range(f1);
          fscanf(f1,"%d",&amp;a1);
        }
        else {
          fprintf(f,"%d ",a2);
          file2 = End_Range(f2);
          fscanf(f2,"%d",&amp;a2);
        }
      } 
      while ( !file1 ) {
        fprintf(f,"%d ",a1);
        file1 = End_Range(f1);
        fscanf(f1,"%d",&amp;a1);
      }
      while ( !file2 ) {
        fprintf(f,"%d ",a2);
        file2 = End_Range(f2);
        fscanf(f2,"%d",&amp;a2);
      }
    }
    file1 = file2 = false;
    while ( !file1 &amp;&amp; !feof(f1) ) {
      fprintf(f,"%d ",a1);
      file1 = End_Range(f1);
      fscanf(f1,"%d",&amp;a1);
    }
    while ( !file2 &amp;&amp; !feof(f2) ) {
      fprintf(f,"%d ",a2);
      file2 = End_Range(f2);
      fscanf(f2,"%d",&amp;a2);
    }
    fclose(f2);
    fclose(f1);
    fclose(f);
  }
  remove("nmsort_1");
  remove("nmsort_2");
}
//определение конца блока
bool End_Range (FILE * f){
  int tmp;
  tmp = fgetc(f);
  tmp = fgetc(f);
  if (tmp != '\'') fseek(f,-2,1);
  else fseek(f,1,1);
  return tmp == '\'' ? true : false;
}
</PRE><SPAN class=objectName>Листинг . </SPAN></DIV>
            <P id=id_83>Таким образом, число чтений или перезаписей файлов при 
            использовании метода естественного слияния будет не хуже, чем при 
            применении метода простого слияния, а в среднем – даже лучше. Но в 
            этом методе увеличивается число сравнений за счет тех, которые 
            требуются для распознавания концов серий. Помимо этого, максимальный 
            размер вспомогательных файлов может быть близок к размеру исходного 
            файла, так как длина серий может быть произвольной.</P>
            <DIV id=mark_83 class=lecture_mark></DIV><A name=sect4></A>
            <H3>Ключевые термины</H3>
            <P id=id_84><B>Внешняя сортировка</B> – это сортировка данных, 
            которые расположены на внешних устройствах и не вмещающихся в 
            оперативную память.</P>
            <DIV id=mark_84 class=lecture_mark></DIV>
            <P id=id_85><B>Двухпутевое слияние</B> – это сортировка, в которой 
            данные распределяются на два вспомогательных файла. </P>
            <DIV id=mark_85 class=lecture_mark></DIV>
            <P id=id_86><B>Двухфазная сортировка</B> – это сортировка, в которой 
            отдельно реализуется две фазы: распределение и слияние. </P>
            <DIV id=mark_86 class=lecture_mark></DIV>
            <P id=id_87><B>Длина серии</B> – это количество элементов в серии. 
            </P>
            <DIV id=mark_87 class=lecture_mark></DIV>
            <P id=id_88><B>Естественное слияние</B> – это сортировка, при 
            которой всегда сливаются две самые длинные из возможных серий.</P>
            <DIV id=mark_88 class=lecture_mark></DIV>
            <P id=id_89><B>Многопутевое слияние</B> – это сортировка, в которой 
            данные распределяются на <SPAN class=texample>N (N &gt; 2)</SPAN> 
            вспомогательных файлов.</P>
            <DIV id=mark_89 class=lecture_mark></DIV>
            <P id=id_91><B>Несбалансированное слияние</B> – это естественное 
            слияние, у которого после фазы распределения количество серий во 
            вспомогательных файлах отличается друг от друга более чем на 
            единицу.</P>
            <DIV id=mark_91 class=lecture_mark></DIV>
            <P id=id_92><B>Однофазная сортировка</B> – это сортировка, в которой 
            объединены фазы распределения и слияния в одну. </P>
            <DIV id=mark_92 class=lecture_mark></DIV>
            <P id=id_93><B>Простое слияние</B> – это одна из сортировок на 
            основе слияния называется, в которой длина серий фиксируется на 
            каждом шаге.</P>
            <DIV id=mark_93 class=lecture_mark></DIV>
            <P id=id_94><B>Распределение</B> – это процесс разделения 
            упорядоченных серий на два и несколько вспомогательных файла.</P>
            <DIV id=mark_94 class=lecture_mark></DIV>
            <P id=id_95><B>Сбалансированное слияние</B> – это естественное 
            слияние, у которого после фазы распределения количество серий во 
            вспомогательных файлах отличается друг от друга не более чем на 
            единицу.</P>
            <DIV id=mark_95 class=lecture_mark></DIV>
            <P id=id_96><B>Серия (упорядоченный отрезок)</B> – это 
            последовательность элементов, которая упорядочена по ключу.</P>
            <DIV id=mark_96 class=lecture_mark></DIV>
            <P id=id_97><B>Слияние</B> – это процесс объединения двух (или 
            более) упорядоченных серий в одну упорядоченную последовательность 
            при помощи циклического выбора элементов доступных в данный 
            момент.</P>
            <DIV id=mark_97 class=lecture_mark></DIV>
            <P id=id_98><B>Фаза</B> – это действия по однократной обработке всей 
            последовательности элементов.</P>
            <DIV id=mark_98 class=lecture_mark></DIV><A name=sect5></A>
            <H3>Краткие итоги</H3>
            <OL id=id_99>
              <LI>Внешние сортировки применяются к данным, которые хранятся во 
              внешней памяти. Внешние сортировки применяются, если объем 
              сортируемых данных превосходит допустимое место в ОЗУ.
              <LI>Внешние сортировки, по сравнению с внутренними, 
              характеризуются проигрышем по времени за счет обращения к внешним 
              носителям. 
              <LI>К наиболее известным алгоритмам внешних сортировок относятся: 
              сортировки слиянием (простое слияние и естественное слияние); 
              улучшенные сортировки (многофазная сортировка и каскадная 
              сортировка).
              <LI>Алгоритмы внешних сортировок отличаются по реализации числом 
              фаз и путей.
              <LI>Простое слияние является одной из сортировок на основе 
              слияния, в которой длина серий фиксируется на каждом шаге.
              <LI>Естественное слияние является сортировкой, при которой всегда 
              сливаются две самые длинные из возможных серий.
              <LI>Число чтений или перезаписей файлов при использовании метода 
              естественного слияния будет не хуже, чем при применении метода 
              простого слияния, а в среднем – даже лучше. Однако в данном методе 
              увеличивается число сравнений за счет распознавания концов 
              серий.</LI></OL>
            <DIV id=mark_99 class=lecture_mark></DIV><A name=sect6></A>
            <H3>Лабораторная работа 43. Алгоритмы сортировки массивов. Внешняя 
            сортировка</H3>
            <P id=id_107><B>Цель работы:</B> изучить основные алгоритмы внешних 
            сортировок, научиться решать задачи сортировок массивов различными 
            методами и выполнять оценку эффективности алгоритмов внешней 
            сортировки.</P>
            <DIV id=mark_107 class=lecture_mark></DIV>
            <P id=id_108>При выполнении лабораторной работы для каждого задания 
            требуется написать программу на языке С++, которая получает на входе 
            числовые данные, выполняет генерацию и вывод массива указанного типа 
            в зависимости от постановки задачи. В каждой задаче необходимо 
            выполнить сортировку данных и реализовать один из алгоритмов внешних 
            сортировок в виде отдельных функций. Ввод данных осуществляется из 
            файла с учетом требований к входным данным, содержащихся в 
            постановке задачи. Ограничениями на входные данные являются 
            максимальный размер строковых данных, диапазон используемого 
            числового типа данных в языке С++.</P>
            <DIV id=mark_108 class=lecture_mark></DIV>
            <P id=id_109><B>Теоретические сведения.</B></P>
            <DIV id=mark_109 class=lecture_mark></DIV>
            <P id=id_110>Ознакомьтесь с материалом лекции 43.</P>
            <DIV id=mark_110 class=lecture_mark></DIV>
            <P id=id_111><B>Задания к лабораторной работе.</B></P>
            <DIV id=mark_111 class=lecture_mark></DIV>
            <P id=id_112>Выполните приведенные ниже задания.</P>
            <DIV id=mark_112 class=lecture_mark></DIV>
            <OL id=id_113>
              <LI>На основании приведенной в лекции 43 функции реализуйте 
              программу, в которой выполняется алгоритм внешней сортировки 
              двухпутевым двухфазным простым слиянием.
              <LI>На основании приведенной в лекции функции реализуйте 
              программу, в которой выполняется алгоритм внешней сортировки 
              двухпутевым двухфазным естественным слиянием.
              <LI>Дан полный перечень всех стран, который включает в себя: 
              название, континент, столицу, площадь, численность населения. 
              Указать сведения о государствах заданного континента в порядке 
              возрастания численности населения. Использовать двухпутевое 
              однофазное простое слияние.
              <LI>Даны сведения о химических веществах, которые включает в себя: 
              класс вещества, название вещества, молекулярная масса вещества. 
              Упорядочить по возрастанию молекулярных масс все вещества 
              указанного класса. Использовать двухпутевое двухфазное 
              естественное сбалансированное слияние.
              <LI>В файле хранится последовательность русских слов. Упорядочить 
              ее в алфавитном порядке. Использовать внешнюю сортировку. Учесть, 
              что порядок кодов букв русского алфавита не соответствует порядку 
              букв в алфавите.</LI></OL>
            <DIV id=mark_113 class=lecture_mark></DIV>
            <P id=id_119>Указания к выполнению работы.</P>
            <DIV id=mark_119 class=lecture_mark></DIV>
            <P id=id_120>Каждое задание необходимо решить в соответствии с 
            изученными алгоритмами внешних сортировок. Программные коды следует 
            реализовать на языке С++. Рекомендуется воспользоваться материалами 
            лекции 43, где подробно рассматриваются описание используемых в 
            работе алгоритмов, примеры их реализации на языке С++. Программу для 
            решения каждого задания необходимо разработать методом процедурной 
            абстракции, используя функции. Этапы решения сопроводить 
            комментариями в коде. В отчете следует отразить разработку и 
            обоснование математической модели решения задачи и примеры входных и 
            выходных файлов.</P>
            <DIV id=mark_120 class=lecture_mark></DIV>
            <P id=id_121>Следует реализовать каждое задание в соответствии с 
            приведенными этапами:</P>
            <DIV id=mark_121 class=lecture_mark></DIV>
            <UL id=id_122>
              <LI>изучить словесную постановку задачи, выделив при этом все виды 
              данных;
              <LI>сформулировать математическую постановку задачи;
              <LI>выбрать метод решения задачи, если это необходимо;
              <LI>разработать графическую схему алгоритма;
              <LI>записать разработанный алгоритм на языке С++;
              <LI>разработать контрольный тест к программе;
              <LI>отладить программу;
              <LI>представить отчет по работе.</LI></UL>
            <DIV id=mark_122 class=lecture_mark></DIV>
            <P id=id_131><B>Требования к отчету.</B></P>
            <DIV id=mark_131 class=lecture_mark></DIV>
            <P id=id_132>Отчет по лабораторной работе должен соответствовать 
            следующей структуре.</P>
            <DIV id=mark_132 class=lecture_mark></DIV>
            <UL id=id_133>
              <LI>Титульный лист.
              <LI>Словесная постановка задачи. В этом подразделе проводится 
              полное описание задачи. Описывается суть задачи, анализ входящих в 
              нее физических величин, область их допустимых значений, единицы их 
              измерения, возможные ограничения, анализ условий при которых 
              задача имеет решение (не имеет решения), анализ ожидаемых 
              результатов.
              <LI>Математическая модель. В этом подразделе вводятся 
              математические описания физических величин и математическое 
              описание их взаимодействий. Цель подраздела – представить решаемую 
              задачу в математической формулировке.
              <LI>Алгоритм решения задачи. В подразделе описывается разработка 
              структуры алгоритма, обосновывается абстракция данных, задача 
              разбивается на подзадачи. Схема алгоритма выполняется по ЕСПД 
              (ГОСТ 19.003-80 и ГОСТ 19.002-80).
              <LI>Листинг программы. Подраздел должен содержать текст программы 
              на языке программирования С++, реализованный в среде MS Visual 
              Studio 2010.
              <LI>Контрольный тест. Подраздел содержит наборы исходных данных и 
              полученные в ходе выполнения программы результаты.
              <LI>Выводы по лабораторной работе. 
              <LI>Ответы на контрольные вопросы.</LI></UL>
            <DIV id=mark_133 class=lecture_mark></DIV>
            <P id=id_142><B>Контрольные вопросы</B></P>
            <DIV id=mark_142 class=lecture_mark></DIV>
            <OL id=id_143>
              <LI>Чем обусловлено использование алгоритмов внешних сортировок?
              <LI>Как расходуется ОЗУ при использовании различных алгоритмов 
              внешних сортировок?
              <LI>Каким слиянием, простым или естественным, эффективнее 
              объединять два упорядоченных по общему ключу файла? Ответ 
              обоснуйте.
              <LI>Какие еще факторы, кроме числа фаз и путей, следует учитывать 
              при анализе эффективности алгоритмов внешних сортировок?
              <LI>Как определить, какому алгоритму внешних сортировок отдать 
              предпочтение при решении задачи?</LI></OL>
            <DIV id=mark_143 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript 
src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/urchin.js">
</SCRIPT>

<SCRIPT 
type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
