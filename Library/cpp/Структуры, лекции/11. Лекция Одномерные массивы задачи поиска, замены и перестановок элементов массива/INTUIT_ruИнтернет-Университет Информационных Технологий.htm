<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0071)http://www.intuit.ru/department/algorithms/staldata/11/staldata_11.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/printable.css">
<META name=GENERATOR content="MSHTML 9.00.8080.16413"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="COLOR: #000000; FONT-WEIGHT: bold">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD>
    <TD><!-- content -->
      <TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD class=head>Структуры и алгоритмы компьютерной обработки 
        данных</TD></TR>
        <TR>
          <TD height=4><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>11. Лекция: Одномерные массивы: задачи 
            поиска, замены и перестановок элементов массива: версия для печати и 
            PDA</SPAN> <BR><SPAN class=rtxt>В лекции рассматривается 
            классификация типовых задач на обработку одномерных массивов, 
            приводятся примеры алгоритмизации задач поиска, замены и 
            перестановок в одномерных массивах. </SPAN></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3></H3>
            <P id=id_1><B>Цель лекции:</B> изучить алгоритмы поиска, замены, 
            перестановок и научиться решать задачи на применение алгоритмов 
            поиска, замены, перестановок в одномерных массивах в языке C++.</P>
            <DIV id=mark_1 class=lecture_mark></DIV>
            <P id=id_2>Задачи по программированию с использованием массивов 
            решаются, как правило, по следующему алгоритму: объявление массива, 
            генерация или инициализация, обработка значений элементов, вывод. 
            При этом, если в процессе обработки значения элементов массива 
            изменяются, то вывод осуществляется дважды: до и после 
обработки.</P>
            <DIV id=mark_2 class=lecture_mark></DIV><A name=sect2></A>
            <H3>Классы задач по обработке массивов</H3>
            <P id=id_3><SPAN class=xml_em_italic>Задачи генерации и вывода 
            массивов</SPAN> предполагают заполнение массива значениями элементов 
            требуемым способом и их вывод.</P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <P id=id_4><SPAN class=xml_em_italic>Задачи поиска в массивах</SPAN> 
            предполагают нахождение элементов массива, соответствующих заданным 
            условиям (например, количество положительных элементов, сумму четных 
            элементов, максимальный элемент и т.д.). Просмотр массива с целью 
            поиска можно проводить с начального элемента, с конечного, с 
            середины и т.д. Однако <SPAN class=xml_em_italic>эффективные</SPAN> 
            поисковые алгоритмы, в которых просмотр массива выполняется особым 
            образом, позволяют уменьшить трудоемкость выполнения поиска.</P>
            <DIV id=mark_4 class=lecture_mark></DIV>
            <P id=id_5><SPAN class=xml_em_italic>Задачи замены в массивах</SPAN> 
            предполагают изменение значений элементов массива в соответствии с 
            условием (заменить все отрицательные значения их модулями, все 
            четные положительные элементы уменьшить вдвое и т.д.).</P>
            <DIV id=mark_5 class=lecture_mark></DIV>
            <P id=id_6><SPAN class=xml_em_italic>Задачи перестановок в 
            массивах</SPAN> предполагают в первоначально заданном массиве 
            выполнить обмен местами отдельных элементов в соответствии с 
            условием (поменять местами наибольший и наименьший элементы, 
            элементы четных позиций с элементами нечетных позиций и т.д.).</P>
            <DIV id=mark_6 class=lecture_mark></DIV>
            <P id=id_7><SPAN class=xml_em_italic>Задачи сортировок 
            массивов</SPAN> предполагают расположить элементы массива по 
            закономерности (по возрастанию, по алфавиту, в порядке убывания 
            модулей и т.д.).</P>
            <DIV id=mark_7 class=lecture_mark></DIV>
            <P id=id_8>Как правило, реальные задачи носят <SPAN 
            class=xml_em_italic>комбинированный</SPAN> характер, так как 
            являются представителями нескольких классов одновременно (разделить 
            все элементы массива на наибольший по модулю элемент, выполнить 
            дихотомический поиск в массиве и т.д.).</P>
            <DIV id=mark_8 class=lecture_mark></DIV><A name=sect3></A>
            <H3>Задачи поиска в массивах</H3>
            <P id=id_9>Решение задач данного вида сводится к установлению того, 
            как обрабатывается каждый элемент или указанные элементы. Затем 
            подбирается подходящая схема перебора, в которую вставляются 
            операторы обработки элементов массива.</P>
            <DIV id=mark_9 class=lecture_mark></DIV>
            <P id=id_10><SPAN class=xml_em_italic>Пример 1</SPAN>. Найдем 
            минимальный элемент в одномерном целочисленном массиве, заданном 
            случайными числами на промежутке [-100; 100).</P>
            <DIV id=mark_10 class=lecture_mark></DIV>
            <P id=id_11>Один из алгоритмов поиска минимального элемента в 
            массиве таков. Будем формировать значение минимального элемента в 
            переменной min. Предположим, что минимальный элемент массива равен 
            нулевому (<SPAN class=texample>min=x[0]</SPAN>). Затем выполним 
            просмотр массива с первого элемента до последнего (<SPAN 
            class=texample>for (i=1;i&lt;k;i++)</SPAN>). Каждый элемент массива 
            сравниваем со значением переменной <SPAN class=texample>min</SPAN>. 
            Если значение очередного <SPAN class=texample>i</SPAN>-го элемента 
            массива меньше <SPAN class=texample>min</SPAN>, то выполняем 
            присваивание <SPAN class=texample>min=x[i]</SPAN>.</P>
            <DIV id=mark_11 class=lecture_mark></DIV>
            <DIV class=example><PRE>//Поиск наименьшего элемента в массиве 
#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
#include &lt;time.h&gt; 
//подключение модуля для генератора случайных чисел
#define max 100

void gen (int k,int a, int b,int x[max]); 
//прототип функции генерации массива
void out (int k,int x[max]);
//прототип функции вывода массива
int minimum (int k,int x[max]); 
//прототип функции поиска минимального элемента

int _tmain(int argc, _TCHAR* argv[]){
  int mas[max],n; 
  do {
    printf("\nВведите количество элементов массива n (n&lt;=100):");
    scanf ("%d",&amp;n);
  }
  while (n&gt;max);
  gen(n,-100,100,mas);
  out(n,mas);
  printf ("\nНаименьший элемент в массиве равен %d", minimum(n,mas));
  system("pause");
  return 0;
}

//Описание функции генерации массива
void gen(int k,int a, int b, int x[max]){     
  int i;
  srand(time(NULL)*1000); 
  //устанавливает начальную точку генерации случайных чисел
  for (i=0;i&lt;k;i++){
    x[i]= rand()%(b-a)+a; 
    //функция генерации случайных чисел на [a,b)
  }
}
//Описание функции вывода массива в строку
void out (int k,int x[max]){
  int i;
  printf("\nВывод значений %d элементов массива в строку: \n",k); 
  for (i=0;i&lt;k;i++)
  printf("%-6d",x[i]);
}
//Описание функции поиска минимального элемента
int minimum (int k,int x[max]) {
  int i,min=x[0];
  for (i=1;i&lt;k;i++)
    if (min&gt;x[i])  min=x[i];
  return min;
}
</PRE></DIV>
            <P id=id_19><SPAN class=xml_em_italic>Пример 2</SPAN>. Найдем 
            среднее арифметическое элементов одномерного вещественного массива, 
            заданного с клавиатуры.</P>
            <DIV id=mark_19 class=lecture_mark></DIV>
            <DIV class=example><PRE>//Поиск среднего арифметического элементов массива
#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
#include &lt;time.h&gt;
//подключение модуля для генератора случайных чисел
#define max 100

void gen (int k, float x[max]); 
//прототип функции генерации массива
float sred_arifm (int k, float x[max]); 
/*прототип функции поиска среднего арифметического элементов массива*/

int _tmain(int argc, _TCHAR* argv[]){
  float mas[max];
  int n; 
  do {
    printf("\nВведите количество элементов массива n (n&lt;=100):");
    scanf ("%d",&amp;n);
  }
  while (n&gt;max);
  gen(n,mas);
  printf ("\nСреднее арифметическое массива равно %f", 
            sred_arifm(n,mas));
  system("pause");
  return 0;
}

//Описание функции генерации массива с клавиатуры
void gen(int k, float x[max]){
  int i;
  printf("\nВведите значения %d элементов массива: \n",k); 
  for (i=0;i&lt;k;i++){
    printf("x[%d]= ",i);
    scanf("%f",&amp;x[i]);
  }
}
/*Описание функции поиска среднего арифметического элементов массива*/
float sred_arifm (int k, float x[max]) {
  int i;
  float sum=0.0;
  for (i=0;i&lt;k;i++)
    sum+=x[i]; //вычисление суммы элементов массива
  return sum/k;
}
</PRE></DIV><A name=sect4></A>
            <H3>Задачи замены в массивах</H3>
            <P id=id_21>Задачи замены в массивах предполагают решение задачи на 
            поиск с последующим изменением найденных значений. В основе решения 
            таких задач лежат поисковые алгоритмы с выбором подходящей схемы 
            перебора.</P>
            <DIV id=mark_21 class=lecture_mark></DIV>
            <P id=id_22><SPAN class=xml_em_italic>Пример 3</SPAN>. Дан 
            одномерный целочисленный массив, заданный случайными числами на 
            промежутке [-50; 50). Заменить в массиве все отрицательные элементы 
            им противоположными.</P>
            <DIV id=mark_22 class=lecture_mark></DIV>
            <P id=id_23>Для решения задачи выполним просмотр массива с начала. 
            Каждый элемент сравним с нулем, при этом отрицательные значения 
            элементов заменим им противоположными (<SPAN class=texample>if 
            (x[i]&lt;0) x[i]=-x[i]</SPAN>). В данной задаче целесообразно 
            выполнить вывод массива дважды: до и после замены.</P>
            <DIV id=mark_23 class=lecture_mark></DIV>
            <DIV class=example><PRE>//Замена отрицательных значений элементов противоположными
#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
#include &lt;time.h&gt;
//подключение модуля для генератора случайных чисел
#define max 100

void gen (int k, int a, int b,int x[max]); 
//прототип функции генерации массива
void out (int k, int x[max]); 
//прототип функции вывода массива
void zamena (int k, int x[max]);
//прототип функции замены

int _tmain(int argc, _TCHAR* argv[]){
  int mas[max];
  int n; 
  do {
    printf("\nВведите количество элементов массива n (n&lt;=100):");
    scanf ("%d",&amp;n);
  }
  while (n&gt;max);
  gen(n,-50,50,mas);
  printf("Вывод сгенерированного массива из %d элементов: \n", n);
  out(n,mas); 
  zamena (n,mas);
  printf("\nВывод массива после замены отрицательных 
          элементов на протипоположные:\n");
  out(n,mas);
  system("pause");
  return 0;
}

//Описание функции генерации массива 
void gen(int k,int a, int b, int x[max]){     
  int i;
  srand(time(NULL)*1000); 
  for (i=0;i&lt;k;i++){
   x[i]=rand()%(b-a)+a;
   }
}
//Описание функции вывода массива в строку
void out (int k,int x[max]){
  int i;
  for (i=0;i&lt;k;i++)
  printf("%-6d",x[i]);
} 
//Описание функции замены
void zamena(int k,int x[max]){
  int i;
  for (i=0;i&lt;k;i++) 
    if (x[i]&lt;0) x[i]=-x[i];
}
</PRE></DIV><A name=sect5></A>
            <H3>Задачи перестановок в массивах</H3>
            <P id=id_26>Решение таких задач сводится к выбору алгоритма 
            просмотра массива с целью выполнить требуемые перестановки.</P>
            <DIV id=mark_26 class=lecture_mark></DIV>
            <P id=id_27><SPAN class=xml_em_italic>Пример 4</SPAN>. Дан 
            одномерный целочисленный массив, заданный случайными числами на 
            промежутке [-10; 10). Выполните циклический сдвиг элементов с 
            нулевой позиции вправо на одну позицию. То есть должна быть 
            реализована схема перестановок: <SPAN class=texample>x[0] <IMG 
            style="POSITION: relative; TOP: 2px" border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/srarr.gif" 
            width=15 height=18> x[1], x[1] <IMG 
            style="POSITION: relative; TOP: 2px" border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/srarr.gif" 
            width=15 height=18> x[2], ... , x[k-1] <IMG 
            style="POSITION: relative; TOP: 2px" border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/srarr.gif" 
            width=15 height=18> x[0]</SPAN>.</P>
            <DIV id=mark_27 class=lecture_mark></DIV>
            <P id=id_29>Одним из алгоритмов такого циклического сдвига является 
            следующая последовательность действий. Поместим в буфер последний 
            элемент массива (<SPAN class=texample>buf=x[k-1]</SPAN>). Выполним 
            смещение остальных элементов вправо на одну позицию (<SPAN 
            class=texample>x[i]=x[i-1]</SPAN>). При этом важен <SPAN 
            class=xml_em_italic>порядок</SPAN> смещения: на освободившееся место 
            последнего элемента перемещается предпоследний, на место 
            предпоследнего – предшествующий ему и т.д. В результате таких 
            перемещений освобождается место нулевого элемента, на которое 
            перемещается элемент из буфера. В данной задаче целесообразно 
            выполнить вывод массива дважды: до и после циклического сдвига.</P>
            <DIV id=mark_29 class=lecture_mark></DIV>
            <DIV class=example><PRE>/*Циклический сдвиг элементов в массиве с нулевой позиции на одну позицию вправо*/
#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
#include &lt;time.h&gt;
//подключение модуля для генератора случайных чисел
#define max 100

void gen (int k, int a, int b,int x[max]);
//прототип функции генерации массива
void out (int k, int x[max]);
//прототип функции вывода массива
void sdvig (int k, int x[max]);
//прототип функции циклического сдвига элементов массива

int _tmain(int argc, _TCHAR* argv[]){
  int mas[max];
  int n; 
  do {
    printf("\nВведите количество элементов массива n (n&lt;=100):");
    scanf ("%d",&amp;n);
  }
  while (n&gt;max);
  gen(n,-10,10,mas);
  printf("Вывод сгенерированного массива из %d элементов: \n",n);
  out(n,mas); 
  sdvig (n,mas);
  printf("\nВывод массива после циклического сдвига 
          элементов: \n");
  out(n,mas);
  system("pause");
  return 0;
}

//Описание функции генерации массива
void gen(int k,int a, int b, int x[max]){
  int i;
  srand(time(NULL)*1000); 
  for (i=0;i&lt;k;i++){
   x[i]=rand()%(b-a)+a;
   }
}

//Описание функции вывода массива в строку
void out (int k,int x[max]){
  int i;
  for (i=0;i&lt;k;i++)
  printf("%d   ",x[i]);
} 
//Описание функции циклического сдвига элементов массива
void sdvig(int k,int x[max]){
  int i,buf;
  buf=x[k-1];
  for (i=k-1;i&gt;0;i--) 
    x[i]=x[i-1];
  x[0]=buf;
}
</PRE></DIV><A name=sect6></A>
            <H3>Ключевые термины</H3>
            <P id=id_33><B>Задачи генерации и вывода массивов</B> – это 
            заполнение массива значениями элементов требуемым способом и их 
            вывод.</P>
            <DIV id=mark_33 class=lecture_mark></DIV>
            <P id=id_34><B>Задачи замены в массивах</B> – это изменение значений 
            элементов массива в соответствии с условием.</P>
            <DIV id=mark_34 class=lecture_mark></DIV>
            <P id=id_35><B>Задачи перестановок в массивах</B> – это выполнение 
            обмена местами элементов в первоначально заданном массиве в 
            соответствии с условием.</P>
            <DIV id=mark_35 class=lecture_mark></DIV>
            <P id=id_36><B>Задачи поиска в массивах</B> – это нахождение 
            элементов массива, соответствующих заданным условиям </P>
            <DIV id=mark_36 class=lecture_mark></DIV>
            <P id=id_37><B>Задачи сортировок массивов</B> – это расположение 
            элементов массива по заданной закономерности.</P>
            <DIV id=mark_37 class=lecture_mark></DIV>
            <P id=id_38><B>Комбинированные задачи</B> – это задачи, сочетающие в 
            себе алгоритмы решения нескольких классов задач одновременно.</P>
            <DIV id=mark_38 class=lecture_mark></DIV><A name=sect7></A>
            <H3>Краткие итоги</H3>
            <OL id=id_39>
              <LI>Задачи на использование массивов можно классифицировать в 
              зависимости от вида обработки его элементов.
              <LI>В поисковых задачах важным является путь обхода массива. Такие 
              задачи не изменяют первоначально заданный массив.
              <LI>Задачи замены в массивах предполагают изменения значений 
              отдельных элементов массива.
              <LI>Задачи перестановок предполагают перемещение элементов в 
              массиве на заданные позиции. При этом сами значения элементов не 
              изменяются.
              <LI>В комбинированных задачах используются приемы решения сразу 
              нескольких классов задач обработки массивов</LI></OL>
            <DIV id=mark_39 class=lecture_mark></DIV><A name=sect8></A>
            <H3>Лабораторная работа 11. Одномерные массивы: задачи поиска, 
            замены и перестановок элементов массива</H3>
            <P id=id_45><B>Цель работы:</B> изучить алгоритмы поиска, замены, 
            перестановок и научиться решать задачи на применение алгоритмов 
            поиска, замены, перестановок в одномерных массивах в языке C++.</P>
            <DIV id=mark_45 class=lecture_mark></DIV>
            <P id=id_46>При выполнении лабораторной работы для каждого задания 
            требуется написать программу на языке С++, которая получает на входе 
            числовые данные (в зависимости от постановки задачи), выполняет 
            генерацию и вывод одномерного массива указанного типа. В каждой 
            задаче необходимо выполнить обработку одномерного массива. Для этого 
            необходимо разработать алгоритм (поиска, замены или перестановок в 
            одномерных массивах) и реализовать его в виде отдельной функции. 
            Ввод данных осуществляется с клавиатуры с учетом требований к 
            входным данным, содержащихся в постановке задачи. Ограничениями на 
            входные данные является диапазон используемого числового типа данных 
            в языке С++ и максимально допустимый размер объявляемого одномерного 
            массива.</P>
            <DIV id=mark_46 class=lecture_mark></DIV>
            <P id=id_47><B>Теоретические сведения.</B></P>
            <DIV id=mark_47 class=lecture_mark></DIV>
            <P id=id_48>Ознакомьтесь с материалом лекции 11.</P>
            <DIV id=mark_48 class=lecture_mark></DIV>
            <P id=id_49><B>Задания к лабораторной работе.</B></P>
            <DIV id=mark_49 class=lecture_mark></DIV>
            <P id=id_50>Выполните приведенные ниже задания.</P>
            <DIV id=mark_50 class=lecture_mark></DIV>
            <OL id=id_51>
              <LI>Дан одномерный целочисленный массив из <SPAN 
              class=texample>N</SPAN> элементов, заданных с клавиатуры. Найти: 
              количество и процентное соотношение положительных, отрицательных и 
              нулевых элементов.
              <LI>Дан одномерный целочисленный массив из <SPAN 
              class=texample>N</SPAN> элементов, заданных случайными числами на 
              промежутке <SPAN class=texample>[a; b)</SPAN>. Заменить все 
              элементы массива, кратные 3, на сумму их цифр.
              <LI>Дан одномерный вещественный массив из <SPAN 
              class=texample>N</SPAN> элементов (<SPAN class=texample>N</SPAN> – 
              нечетное), заданных случайными числами на промежутке <SPAN 
              class=texample>[a; b)</SPAN>. Поменять местами элементы 
              симметричные относительно центрального.
              <LI>Дан одномерный целочисленный массив из N элементов, заданных 
              случайными числами на промежутке <SPAN class=texample>[a; 
              b)</SPAN>. Поменять местами первый минимальный и последний 
              максимальный элементы.
              <LI>Дан одномерный вещественный массив из <SPAN 
              class=texample>N</SPAN> элементов, заданных случайными числами на 
              промежутке <SPAN class=texample>[a; b)</SPAN>. Выполните 
              циклический сдвиг элементов с <SPAN class=texample>n</SPAN>-ой 
              позиции вправо на <SPAN class=texample>k</SPAN> позиций.</LI></OL>
            <DIV id=mark_51 class=lecture_mark></DIV>
            <P id=id_68><B>Указания к выполнению работы.</B></P>
            <DIV id=mark_68 class=lecture_mark></DIV>
            <P id=id_69>Каждое задание необходимо решить в соответствии с 
            изученными методами объявления, генерации и вывода одномерных 
            массивов в языке С++. Обработку данных необходимо выполнить, 
            используя алгоритмы поиска, замены и перестановок данных в 
            одномерных массивах. При разработке программного кода требуется 
            использовать метод процедурной абстракции и комментировать фрагменты 
            кода.</P>
            <DIV id=mark_69 class=lecture_mark></DIV>
            <P id=id_70>Следует реализовать каждое задание в соответствии с 
            приведенными этапами:</P>
            <DIV id=mark_70 class=lecture_mark></DIV>
            <UL id=id_71>
              <LI>изучить словесную постановку задачи, выделив при этом все виды 
              данных;
              <LI>сформулировать математическую постановку задачи;
              <LI>выбрать метод решения задачи, если это необходимо;
              <LI>разработать графическую схему алгоритма;
              <LI>записать разработанный алгоритм на языке С++;
              <LI>разработать контрольный тест к программе;
              <LI>отладить программу;
              <LI>представить отчет по работе.</LI></UL>
            <DIV id=mark_71 class=lecture_mark></DIV>
            <P id=id_80><B>Требования к отчету.</B></P>
            <DIV id=mark_80 class=lecture_mark></DIV>
            <P id=id_81>Отчет по лабораторной работе должен соответствовать 
            следующей структуре.</P>
            <DIV id=mark_81 class=lecture_mark></DIV>
            <UL id=id_82>
              <LI>Титульный лист.
              <LI>Словесная постановка задачи. В этом подразделе проводится 
              полное описание задачи. Описывается суть задачи, анализ входящих в 
              нее физических величин, область их допустимых значений, единицы их 
              измерения, возможные ограничения, анализ условий при которых 
              задача имеет решение (не имеет решения), анализ ожидаемых 
              результатов.
              <LI>Математическая модель. В этом подразделе вводятся 
              математические описания физических величин и математическое 
              описание их взаимодействий. Цель подраздела – представить решаемую 
              задачу в математической формулировке.
              <LI>Алгоритм решения задачи. В подразделе описывается разработка 
              структуры алгоритма, обосновывается абстракция данных, задача 
              разбивается на подзадачи. Схема алгоритма выполняется по ЕСПД 
              (ГОСТ 19.003-80 и ГОСТ 19.002-80).
              <LI>Листинг программы. Подраздел должен содержать текст программы 
              на языке программирования С++, реализованный в среде MS Visual 
              Studio 2010.
              <LI>Контрольный тест. Подраздел содержит наборы исходных данных и 
              полученные в ходе выполнения программы результаты.
              <LI>Выводы по лабораторной работе. 
              <LI>Ответы на контрольные вопросы.</LI></UL>
            <DIV id=mark_82 class=lecture_mark></DIV>
            <P id=id_91><B>Контрольные вопросы</B></P>
            <DIV id=mark_91 class=lecture_mark></DIV>
            <OL id=id_92>
              <LI>Какие классы задач предполагают изменение значений элементов 
              массива?
              <LI>Какие классы задач предполагают только изменение порядка 
              следования элементов в массиве?
              <LI>Каким образом можно выполнять обход массива?
              <LI>Почему в алгоритме циклического сдвига элементов массива важен 
              порядок смещения элементов?
              <LI>Чем различаются алгоритмы поиска первого и последнего 
              минимального (максимального) элемента в массиве?</LI></OL>
            <DIV id=mark_92 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript 
src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/urchin.js">
</SCRIPT>

<SCRIPT 
type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
