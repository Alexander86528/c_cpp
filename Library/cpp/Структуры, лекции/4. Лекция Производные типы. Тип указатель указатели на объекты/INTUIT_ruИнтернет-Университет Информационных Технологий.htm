<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0069)http://www.intuit.ru/department/algorithms/staldata/4/staldata_4.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/printable.css">
<META name=GENERATOR content="MSHTML 9.00.8080.16413"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="COLOR: #000000; FONT-WEIGHT: bold">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD>
    <TD><!-- content -->
      <TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD class=head>Структуры и алгоритмы компьютерной обработки 
        данных</TD></TR>
        <TR>
          <TD height=4><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>4. Лекция: Производные типы. Тип указатель: 
            указатели на объекты: версия для печати и PDA</SPAN> <BR><SPAN 
            class=rtxt>В лекции рассматриваются определение и виды указателей, 
            способы объявления, инициализация указателей на объекты, методы 
            доступа к данным через указатели, размещение указателей и адресуемых 
            ими объектов в памяти, операции над указателями. </SPAN></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3></H3>
            <P id=id_1><B>Цель</B> лекции: изучить классификацию производных 
            типов, тип указатель и соотношения между именами, адресами и 
            значениями переменных, научиться использовать указатели в 
            программных кодах на языке C++.</P>
            <DIV id=mark_1 class=lecture_mark></DIV>
            <P id=id_2>В языке С++ разрешено наряду со стандартными 
            использование производных типов, полученных на основе более простых 
            базовых типов. Производные типы можно условно подразделить на две 
            группы:</P>
            <DIV id=mark_2 class=lecture_mark></DIV>
            <P id=id_3><SPAN class=xml_em_italic>Непосредственно производные 
            типы</SPAN>. Эти типы являются производными от некоторых 
            существующих типов, реализуя типы указателей, ссылки, функции 
            преобразования типов. В группу непосредственно производных типов 
            входят:</P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <UL id=id_4>
              <LI>массивы; 
              <LI>указатели; 
              <LI>ссылки; 
              <LI>перечисления.</LI></UL>
            <DIV id=mark_4 class=lecture_mark></DIV>
            <P id=id_9><SPAN class=xml_em_italic>Составные производные 
            типы</SPAN>. В группу составных производных типов входят типы, 
            являющиеся производными от различных существующих или ранее 
            объявленных типов:</P>
            <DIV id=mark_9 class=lecture_mark></DIV>
            <UL id=id_10>
              <LI>классы; 
              <LI>структуры; 
              <LI>объединения.</LI></UL>
            <DIV id=mark_10 class=lecture_mark></DIV><A name=sect2></A>
            <H3>Переименование типов</H3>
            <P id=id_14>В некоторых программных кодах бывает удобно вводить 
            новые обозначения имен отдельных используемых типов данных. Задавать 
            новое имя типу можно с помощью ключевого слова <SPAN 
            class=texample>typedef</SPAN>.</P>
            <DIV id=mark_14 class=lecture_mark></DIV>
            <P id=id_16>Синтаксис:</P>
            <DIV id=mark_16 class=lecture_mark></DIV>
            <DIV class=example><PRE>typedef Тип НовоеИмяТипа[Размерность];
</PRE></DIV>
            <P id=id_18>Например:</P>
            <DIV id=mark_18 class=lecture_mark></DIV>
            <DIV class=example><PRE>typedef unsigned int UNIT;
typedef char Msg[100];
</PRE></DIV>
            <P id=id_20>Такое имя можно затем использовать так же, как и 
            стандартное имя типа:</P>
            <DIV id=mark_20 class=lecture_mark></DIV>
            <DIV class=example><PRE>UNIT a,b,c;//переменные типа unsigned int
Msg str[10];//массив из 10 строк по 100 символов
</PRE></DIV>
            <P id=id_22>Рассмотрим тип указатель. Указатели являются 
            специальными объектами в программах на С++. Они предназначены для 
            хранения адресов памяти.</P>
            <DIV id=mark_22 class=lecture_mark></DIV>
            <P id=id_23>Рассмотрим пример (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/4/staldata_4.html#image.4.1">рис. 
            4.1</A>). Когда компилятор обрабатывает оператор определения 
            переменной, например, <SPAN class=texample>int a=10;</SPAN>, то в 
            памяти выделяется участок памяти в соответствии с типом переменной и 
            записывается в этот участок указанное значение (размер типа <SPAN 
            class=texample>int</SPAN> не менее 2 байтов и зависит от 
            реализации). Все обращения к переменной <SPAN 
            class=texample>a</SPAN> компилятор заменит на адрес области памяти, 
            в которой хранится эта переменная. Операция <SPAN 
            class=texample>&amp;a</SPAN> является операцией взятия адреса ее 
            операнда.</P>
            <DIV id=mark_23 class=lecture_mark></DIV>
            <P id=id_28 align=left><A name=image.4.1></A>
            <DIV><IMG alt="Адресация в С++" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/04_01.png" 
            width=114 height=65></DIV><BR><B>Рис. 4.1.</B>&nbsp; Адресация в С++
            <P></P>
            <DIV id=mark_28 class=lecture_mark></DIV>
            <P id=id_29>Программист может определить собственные переменные для 
            хранения адресов областей памяти. Такие переменные называются 
            указателями.</P>
            <DIV id=mark_29 class=lecture_mark></DIV>
            <P id=id_30><B>Указатель</B> – именованный объект, предназначенный 
            для хранения адреса области памяти (объекта, непоименованной области 
            оперативной памяти либо точки входа в функцию).</P>
            <DIV id=mark_30 class=lecture_mark></DIV>
            <P id=id_31>Указатель не является самостоятельным типом, он всегда 
            связан с каким-то другим типом. Указатели делятся на две 
            категории:</P>
            <DIV id=mark_31 class=lecture_mark></DIV>
            <UL id=id_32>
              <LI>указатели на объекты;
              <LI>указатели на функции.</LI></UL>
            <DIV id=mark_32 class=lecture_mark></DIV>
            <P id=id_35>Эти категории указателей отличаются друг от друга 
            свойствами и правилами манипулирования. Каждый указатель имеет 
            соответствующий тип.</P>
            <DIV id=mark_35 class=lecture_mark></DIV><A name=sect3></A>
            <H3>Указатели на объекты</H3>
            <P id=id_36>В общем случае синтаксис определения указателя на 
            объект:</P>
            <DIV id=mark_36 class=lecture_mark></DIV>
            <DIV class=example><PRE>Тип*Описатель;
</PRE></DIV>
            <P id=id_38>При определении указателя специфицируется имя 
            указателя-переменной (в дальнейшем указатель) и тип объекта, на 
            который он ссылается.</P>
            <DIV id=mark_38 class=lecture_mark></DIV>
            <P id=id_39><SPAN class=texample>Тип</SPAN> задает тип объекта, 
            адрес которого будет содержать определяемая переменная и может 
            соответствовать базовому, пустому (свободному, родовому, то есть 
            типу <SPAN class=texample>void</SPAN>), перечислению, структурному 
            типу и типу объединения. Реально указатель на <SPAN 
            class=texample>void</SPAN> ни на что не указывает, но обладает 
            способностью указывать на область любого размера после его 
            типизирования каким-либо объектом.</P>
            <DIV id=mark_39 class=lecture_mark></DIV>
            <P id=id_43><SPAN class=texample>Описатель</SPAN> – это 
            идентификатор, определяющий имя объявляемой переменой типа указатель 
            или конструкция, которая организует непосредственно доступ к памяти. 
            Описателю обязательно должна предшествовать звездочка (*). </P>
            <DIV id=mark_43 class=lecture_mark></DIV>
            <P id=id_45>Знак '*' является унарной операцией косвенной адресации, 
            его операнд – указатель, а результат – адрес объекта, на который 
            указывает операнд. Адресация является <SPAN 
            class=xml_em_italic>косвенно</SPAN>й, так как обращение к области 
            памяти осуществляется не напрямую по адресу (например, 1А2В), а 
            через объект, которому в памяти соответствует определенный участок. 
            Объем памяти, который выделяется для хранения данных, определяется 
            типом данных и моделью памяти. Для приведенной на рисунке 2 модели 
            памяти адресом переменной типа <SPAN class=texample>float</SPAN> с 
            именем <SPAN class=texample>summa</SPAN> является 0012FF48, адресом 
            переменной типа <SPAN class=texample>int</SPAN> с именем <SPAN 
            class=texample>date</SPAN> является 0012FF54, адресом переменной 
            типа <SPAN class=texample>char</SPAN> с именем <SPAN 
            class=texample>ch</SPAN> является 0012FF63.</P>
            <DIV id=mark_45 class=lecture_mark></DIV>
            <P id=id_52 align=left><A name=image.4.2></A>
            <DIV><IMG alt="Адресация типов в С++" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/04_02.png" 
            width=670 height=114></DIV><BR><B>Рис. 4.2.</B>&nbsp; Адресация 
            типов в С++
            <P></P>
            <DIV id=mark_52 class=lecture_mark></DIV>
            <P id=id_53>Примеры определения указателей:</P>
            <DIV id=mark_53 class=lecture_mark></DIV>
            <DIV class=example><PRE>int *P;
  /*указатель Р может содержать адрес объекта типа int*/
float *s;
  /*указатель s может содержать адрес объекта типа float*/
</PRE></DIV>
            <P id=id_55>Синтаксис объявления указателя на объект базового 
            типа:</P>
            <DIV id=mark_55 class=lecture_mark></DIV>
            <DIV class=example><PRE>Тип*ИмяУказателя;
</PRE></DIV>
            <P id=id_57>где <SPAN class=texample>ИмяУказателя</SPAN> – 
            идентификатор.</P>
            <DIV id=mark_57 class=lecture_mark></DIV>
            <P id=id_59>Например,</P>
            <DIV id=mark_59 class=lecture_mark></DIV>
            <DIV class=example><PRE>char *s; //переменная s – указатель на объект типа char
double *x; /*переменная х – указатель на объект типа 
             double, вещественного числа с плавающей 
             точкой удвоенной точности*/
int *k, *ff; //k, ff – указатели на объекты целого типа
int *p, y; /*р – указатель на объект типа int, 
y – целочисленная переменная и не является
    указателем*/
int x, *p; /*х – целочисленная переменная и не является
                 указателем,
р – указатель на объект типа int*/
</PRE></DIV>
            <P id=id_61>Указатель может быть константой или переменной, а также 
            указывать на константу или переменную.</P>
            <DIV id=mark_61 class=lecture_mark></DIV>
            <P id=id_62>Например:</P>
            <DIV id=mark_62 class=lecture_mark></DIV>
            <DIV class=example><PRE>int i;//целая переменная 
const int ci=1; //целая константа

int *pi; //указатель на целую переменную
const int *pci; //указатель на целую константу

int *const cpi; //указатель-константа на целую переменную
const int *const cpc;
                //указатель-константа на целую константу
</PRE></DIV>
            <P id=id_64>При объявлении указателя его можно сразу 
            проинициализировать (задать значение):</P>
            <DIV id=mark_64 class=lecture_mark></DIV>
            <DIV class=example><PRE>int *pi=&amp;i; //указатель на целую переменную
const int *pci=&amp;ci; //указатель на целую константу

int *const cpi=&amp;i; 
            //указатель-константа на целую переменную
const int *const cpc=&amp;ci; 
           //указатель-константа на целую константу
</PRE></DIV>
            <P id=id_66>Если модификатор <SPAN class=texample>const</SPAN> 
            относится к указателю (т.е. находится между именем указателя и *), 
            то он запрещает изменение значения указателя, а если он находится 
            слева от типа (т.е. слева от *), то он запрещает изменение значения, 
            на которое указывает указатель. </P>
            <DIV id=mark_66 class=lecture_mark></DIV>
            <P id=id_68><SPAN class=xml_em_italic>Способы инициализации 
            указателя</SPAN></P>
            <DIV id=mark_68 class=lecture_mark></DIV>
            <OL id=id_69>
              <LI>Присваивание указателю адреса области памяти существующего 
              объекта: 
              <UL id=id_71>
                <LI>с помощью операции получения адреса: 
                <DIV class=example><PRE>int a=5; 
int *p=&amp;a; 
 </PRE></DIV>
                <LI>с помощью проинициализированного указателя 
                <DIV class=example><PRE>int *r=p; 
 </PRE></DIV></LI></UL>
              <DIV id=mark_71 class=lecture_mark></DIV>
              <P id=id_76 align=left><A></A>
              <DIV><IMG alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/04_03.png"></DIV><BR>
              <P></P>
              <DIV id=mark_76 class=lecture_mark></DIV>
              <LI>Присваивание указателю адреса области памяти в явном виде: 
              <DIV class=example><PRE>char *cp=(char*)0х В800 0000;
</PRE></DIV>где <SPAN class=texample>0х</SPAN> В800 0000 – 
              шестнадцатеричная константа, (<SPAN class=texample>char*</SPAN>) – 
              операция приведения типа. 
              <LI>Присваивание указателю пустого значения: 
              <DIV class=example><PRE>int *N=NULL; или int *N=0;
</PRE></DIV></LI></OL>
            <DIV id=mark_69 class=lecture_mark></DIV>
            <P id=id_83><SPAN class=xml_em_italic>Спецификатор указателя при 
            форматированном выводе</SPAN></P>
            <DIV id=mark_83 class=lecture_mark></DIV>
            <P id=id_84>Если на экран необходимо вывести адрес, следует 
            применять спецификатор <SPAN class=texample>%p</SPAN>.</P>
            <DIV id=mark_84 class=lecture_mark></DIV>
            <P id=id_86><SPAN class=texample>%p</SPAN> – спецификатор 
            указателя.</P>
            <DIV id=mark_86 class=lecture_mark></DIV>
            <P id=id_88>Этот спецификатор формата заставляет функцию <SPAN 
            class=texample>printf()</SPAN> выводить на экран адрес, формат 
            которого совместим с типом адресации, принятой в компьютере.</P>
            <DIV id=mark_88 class=lecture_mark></DIV>
            <P id=id_90><SPAN class=xml_em_italic>Операции с 
            указателями</SPAN></P>
            <DIV id=mark_90 class=lecture_mark></DIV>
            <P id=id_91>С указателями можно выполнять следующие операции:</P>
            <DIV id=mark_91 class=lecture_mark></DIV>
            <UL id=id_92>
              <LI>разыменование (*) – получение значения величины, адрес которой 
              хранится в указателе;
              <LI>взятие адреса (&amp;);
              <LI>присваивание;
              <LI>арифметические операции 
              <UL id=id_97>
                <LI>сложение указателя только с константой,
                <LI>вычитание: допускается разность указателей и разность 
                указателя и константы,
                <LI>инкремент (++) увеличивает значение указателя на величину 
                <SPAN class=texample>sizeof(тип);</SPAN>
                <LI>декремент (--) уменьшает значение указателя на величину 
                <SPAN class=texample>sizeof(тип);</SPAN></LI></UL>
              <DIV id=mark_97 class=lecture_mark></DIV>
              <LI>сравнение;
              <LI>приведение типов.</LI></UL>
            <DIV id=mark_92 class=lecture_mark></DIV>
            <P id=id_106><SPAN class=xml_em_italic>Пример 1</SPAN>. Демонстрация 
            ситуации, когда указатели различных типов указывают на одно и то же 
            место в памяти. Однако при разыменовании получаются разные 
            результаты.</P>
            <DIV id=mark_106 class=lecture_mark></DIV>
            <DIV class=example><PRE>// Выбор данных из памяти с помощью разных указателей
// Использование функций приведения типов
#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
int _tmain(int argc, _TCHAR* argv[]){
  unsigned long L=12345678;
  char *cp=(char*)&amp;L;
  int *ip=(int*)&amp;L;
  long *lp=(long*)&amp;L;

  cout &lt;&lt;"\n&amp;L = "&lt;&lt;&amp;L; 
  cout &lt;&lt;"\nL = "&lt;&lt;L;  
  cout &lt;&lt;"\n*cp = "&lt;&lt;*cp; 
  cout &lt;&lt;"\n*ip = "&lt;&lt;*ip;
  cout &lt;&lt;"\n*lp = "&lt;&lt;*lp;
  
  system("pause");
  return 0;
}
</PRE></DIV>
            <P id=id_108><SPAN class=xml_em_italic>Пример 2.</SPAN></P>
            <DIV id=mark_108 class=lecture_mark></DIV>
            <DIV class=example><PRE>//Операции над указателями
#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;

int _tmain(int argc, _TCHAR* argv[]){
  int a,c,b;
  int  *ca, *cb;
  int *sa, *sb, *sc;
  cout &lt;&lt; "a = "; cin &gt;&gt; a;
  cout &lt;&lt; "b = "; cin &gt;&gt; b;  
  c=a+b;

  sb=&amp;b;//инициализация указателей через взятие адреса
  sa=&amp;a;
  sc =&amp;c;
  //присваивание указателю значения выражения
  *sc = c+a-b;
  ca=sa;//присваивание указателю значения другого указателя
  cb=sb;
  *sa=12;//присваивание указателю значения константы

  cout &lt;&lt; "\n*ca = " &lt;&lt; *ca;
  cout &lt;&lt; "\n*sa = " &lt;&lt; *sa; 
  cout &lt;&lt; "\n*cb = " &lt;&lt; *cb; 
  cout &lt;&lt; "\n*sb = " &lt;&lt; *sb;
  cout &lt;&lt; "\n*sc = " &lt;&lt; *sc;

  cout &lt;&lt; "\nca = " &lt;&lt; ca; 
  cout &lt;&lt; "\ncb = " &lt;&lt; cb;
  cout &lt;&lt; "\nsc = " &lt;&lt; sc;

  cout &lt;&lt; "\na = " &lt;&lt; a;
  cout &lt;&lt; "\nb = " &lt;&lt; b;
  cout &lt;&lt; "\nc = " &lt;&lt; c;

  cout &lt;&lt; "\n&amp;a = " &lt;&lt; &amp;a; 
  cout &lt;&lt; "\n&amp;b = " &lt;&lt; &amp;b;
  cout &lt;&lt; "\n&amp;c = " &lt;&lt; &amp;c;

  cout &lt;&lt; "\n*&amp;a = " &lt;&lt; *&amp;a;  
  
  cout &lt;&lt; "\n*cb-*ca = " &lt;&lt; *cb-*ca;
  cout &lt;&lt; "\n*cb+*ca = " &lt;&lt; *cb+*ca;
  *cb=+2; //сложение с константой
  cout &lt;&lt; "\ncb = " &lt;&lt; cb;
  cb++; //инкремент
  cout &lt;&lt; "\ncb = " &lt;&lt; cb;
  ca--; //декремент
  cout &lt;&lt; "\ncа = " &lt;&lt; ca;
  /*разность указателей - разность их значений, деленная
    на размер типа в байтах*/
   cout &lt;&lt; "\ncb-ca = " &lt;&lt; cb-ca; 
  system("pause");
  return 0;
}
</PRE></DIV>
            <P id=id_110>Указатели одного и того же типа можно сравнивать с 
            помощью стандартных операций сравнения. При этом сравниваются 
            значения указателей, а не значения величин, на которые данные 
            указатели ссылаются. </P>
            <DIV id=mark_110 class=lecture_mark></DIV>
            <P id=id_111><SPAN class=xml_em_italic>Пример 3.</SPAN></P>
            <DIV id=mark_111 class=lecture_mark></DIV>
            <DIV class=example><PRE>#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
int _tmain(int argc, _TCHAR* argv[]){
  int x=10;
  int y=10;
  int *xptr=&amp;x;
  int *yptr=&amp;y;
  
//сравниваем указатели
  if (xptr == yptr) 
    cout &lt;&lt; "Указатели равны\n";
     else  
    cout &lt;&lt; "Указатели неравны\n";

//сравниваем значения, на которое указывает указатель
  if (*xptr == *yptr) {
    cout &lt;&lt; "Значения равны\n";
    } else { 
    cout &lt;&lt; "Значения неравны\n";}
  system("pause");
  return 0;
}
</PRE></DIV>
            <P id=id_113>В приведенном примере результат первой операции 
            сравнения будет ложным, а второй – истинным, поскольку переменные 
            <SPAN class=texample>x</SPAN> и <SPAN class=texample>y</SPAN> имеют 
            одно и то же значение.</P>
            <DIV id=mark_113 class=lecture_mark></DIV><A name=sect4></A>
            <H3>Ключевые термины</H3>
            <P id=id_116><B>Адрес объекта</B> – это адрес области оперативной 
            памяти, по которому хранится объект в соответствии с особенностями 
            представления типа.</P>
            <DIV id=mark_116 class=lecture_mark></DIV>
            <P id=id_117><B>Инициализация указателя</B> – это определение 
            значения указателя.</P>
            <DIV id=mark_117 class=lecture_mark></DIV>
            <P id=id_118><B>Косвенная адресация</B> – это обращение к области 
            памяти не напрямую, по адресу, а через объект, которому в памяти 
            соответствует определенный участок.</P>
            <DIV id=mark_118 class=lecture_mark></DIV>
            <P id=id_119><B>Непосредственно производные типы</B> – это типы, 
            которые являются производными от некоторых существующих типов, 
            реализуя типы указателей, ссылки, функции преобразования типов.</P>
            <DIV id=mark_119 class=lecture_mark></DIV>
            <P id=id_120><B>Переименование типов</B> – это задание нового имени 
            для существующего типа.</P>
            <DIV id=mark_120 class=lecture_mark></DIV>
            <P id=id_121><B>Производные типы данных</B> – это типы, полученные 
            на основе более простых базовых типов.</P>
            <DIV id=mark_121 class=lecture_mark></DIV>
            <P id=id_122><B>Разыменование</B> – это операция получения значения 
            объекта, адрес которого хранится в указателе;</P>
            <DIV id=mark_122 class=lecture_mark></DIV>
            <P id=id_123><B>Составные производные типы</B> – это типы, 
            являющиеся производными от различных существующих или ранее 
            объявленных типов.</P>
            <DIV id=mark_123 class=lecture_mark></DIV>
            <P id=id_124><B>Указатель</B> – это именованный объект, 
            предназначенный для хранения адреса области памяти.</P>
            <DIV id=mark_124 class=lecture_mark></DIV>
            <P id=id_125><B>Указатель на константу</B> – это указатель на такой 
            объект, значение которого нельзя изменить в процессе выполнения 
            программы.</P>
            <DIV id=mark_125 class=lecture_mark></DIV>
            <P id=id_126><B>Указатель-константа</B> – это указатель, значение 
            которого нельзя изменить в процессе выполнения программы.</P>
            <DIV id=mark_126 class=lecture_mark></DIV>
            <P id=id_127><B>Указатель-константа на константу</B> – это 
            указатель, для которого невозможно изменение как самого указателя, 
            так и значения адресуемого объекта.</P>
            <DIV id=mark_127 class=lecture_mark></DIV><A name=sect5></A>
            <H3>Краткие итоги</H3>
            <OL id=id_128>
              <LI>В языке С++ производные типы данных классифицируют в 
              зависимости от построения на производные и непосредственно 
              производные.
              <LI>Для экономии памяти и времени, затрачиваемого на обращение к 
              данным, в программах используют указатели на объекты.
              <LI>Указатель не является самостоятельным типом, он всегда связан 
              с другим типом.
              <LI>Указатель может быть константой или переменной, а также 
              указывать на константу или переменную.
              <LI>Указатель типа <SPAN class=texample>void</SPAN> указывает на 
              область памяти любого размера. Разыменование такого указателя 
              необходимо проводить с операцией приведения типов.
              <LI>До первого использования в программе объявленный указатель 
              необходимо проинициализировать.
              <LI>С помощью указателей можно выполнять косвенную адресацию 
              объектов.
              <LI>Над указателями определены операции: разыменование, взятие 
              адреса, декремент, инкремент, увеличение (уменьшение) на целую 
              константу, разность, определение размера.
              <LI>Над указателями определены операции сравнения.</LI></OL>
            <DIV id=mark_128 class=lecture_mark></DIV><A name=sect6></A>
            <H3>Лабораторная работа 4. Производные типы. Тип указатель: 
            указатели на объекты.</H3>
            <P id=id_139><B>Цель работы:</B> изучить классификацию производных 
            типов, тип указатель и соотношения между именами, адресами и 
            значениями переменных, научиться использовать указатели в 
            программных кодах на языке C++.</P>
            <DIV id=mark_139 class=lecture_mark></DIV>
            <P id=id_140>При выполнении лабораторной работы для каждого задания 
            требуется написать программу на языке С++, которая получает на входе 
            данные различных типов (в соответствии с условиями задач), выполняет 
            их обработку в соответствии с требованиями задания и выводит 
            результат на экран. Ввод данных осуществляется с клавиатуры с учетом 
            требований к входным данным, содержащихся в постановке задачи. 
            Ограничениями на входные данные является допустимый диапазон 
            значений используемых числовых типов в языке С++.</P>
            <DIV id=mark_140 class=lecture_mark></DIV>
            <P id=id_141><B>Теоретические сведения.</B></P>
            <DIV id=mark_141 class=lecture_mark></DIV>
            <P id=id_142>Ознакомьтесь с материалом лекции 4.</P>
            <DIV id=mark_142 class=lecture_mark></DIV>
            <P id=id_143><B>Задания к лабораторной работе.</B></P>
            <DIV id=mark_143 class=lecture_mark></DIV>
            <P id=id_144>Выполните приведенные ниже задания.</P>
            <DIV id=mark_144 class=lecture_mark></DIV>
            <UL id=id_145>
              <LI>В программе определите и инициализируйте переменную типа <SPAN 
              class=texample>double</SPAN>, указатель <SPAN 
              class=texample>double *</SPAN> и указатель типа <SPAN 
              class=texample>void *</SPAN>. Присвойте указателям адрес 
              переменной. Напечатайте адрес переменной, значения указателей и 
              значения, получаемые при разыменовании указателей. Чтобы 
              продемонстрировать роли и последовательность выполнения унарных 
              операций получения адреса <SPAN class=texample>&amp;</SPAN> и 
              разыменования <SPAN class=texample>*</SPAN>, выведите на печать 
              значение выражения <SPAN 
              class=texample>*&amp;имя_переменной</SPAN>.
              <LI>Задано натуральное число. Разместите в памяти последовательно 
              все его цифры, используя указатели и операции над ними.
              <LI>Определите и инициализируйте переменную типа <SPAN 
              class=texample>double</SPAN>. Определите указатели <SPAN 
              class=texample>char *, int *, double *, void *</SPAN>, 
              инициализируйте их адресом переменной. Напечатайте значения 
              указателей, их размеры и длины участков памяти, которые связаны с 
              выражениями, разыменовывающими указатели. </LI></UL>
            <DIV id=mark_145 class=lecture_mark></DIV>
            <P id=id_157><B>Указания к выполнению работы.</B></P>
            <DIV id=mark_157 class=lecture_mark></DIV>
            <P id=id_158>Каждое задание необходимо решить в соответствии с 
            изученными методами работы с указателями в языке С++. В отчете 
            следует пояснить различия в использовании указателей разных типов, 
            адресующих один и тот же участок памяти, и отразить основные случаи 
            использования в программе указателя типа <SPAN class=texample>void 
            *</SPAN>.</P>
            <DIV id=mark_158 class=lecture_mark></DIV>
            <P id=id_160>Следует реализовать каждое задание в соответствии с 
            приведенными этапами:</P>
            <DIV id=mark_160 class=lecture_mark></DIV>
            <UL id=id_161>
              <LI>изучить словесную постановку задачи, выделив при этом все виды 
              данных;
              <LI>сформулировать математическую постановку задачи;
              <LI>выбрать метод решения задачи, если это необходимо;
              <LI>разработать графическую схему алгоритма;
              <LI>записать разработанный алгоритм на языке С++;
              <LI>разработать контрольный тест к программе;
              <LI>отладить программу;
              <LI>представить отчет по работе.</LI></UL>
            <DIV id=mark_161 class=lecture_mark></DIV>
            <P id=id_170><B>Требования к отчету.</B></P>
            <DIV id=mark_170 class=lecture_mark></DIV>
            <P id=id_171>Отчет по лабораторной работе должен соответствовать 
            следующей структуре.</P>
            <DIV id=mark_171 class=lecture_mark></DIV>
            <UL id=id_172>
              <LI>Титульный лист.
              <LI>Словесная постановка задачи. В этом подразделе проводится 
              полное описание задачи. Описывается суть задачи, анализ входящих в 
              нее физических величин, область их допустимых значений, единицы их 
              измерения, возможные ограничения, анализ условий при которых 
              задача имеет решение (не имеет решения), анализ ожидаемых 
              результатов.
              <LI>Математическая модель. В этом подразделе вводятся 
              математические описания физических величин и математическое 
              описание их взаимодействий. Цель подраздела – представить решаемую 
              задачу в математической формулировке.
              <LI>Алгоритм решения задачи. В подразделе описывается разработка 
              структуры алгоритма, обосновывается абстракция данных, задача 
              разбивается на подзадачи. Схема алгоритма выполняется по ЕСПД 
              (ГОСТ 19.003-80 и ГОСТ 19.002-80).
              <LI>Листинг программы. Подраздел должен содержать текст программы 
              на языке программирования С++, реализованный в среде MS Visual 
              Studio 2010.
              <LI>Контрольный тест. Подраздел содержит наборы исходных данных и 
              полученные в ходе выполнения программы результаты.
              <LI>Выводы по лабораторной работе. 
              <LI>Ответы на контрольные вопросы.</LI></UL>
            <DIV id=mark_172 class=lecture_mark></DIV>
            <P id=id_181><B>Контрольные вопросы</B></P>
            <DIV id=mark_181 class=lecture_mark></DIV>
            <OL id=id_182>
              <LI>Почему указатель не может существовать как самостоятельный 
тип?
              <LI>С какой целью в программе может быть использован указатель 
              типа <SPAN class=texample>void</SPAN>?
              <LI>Что будет являться результатом разыменования указателя типа 
              <SPAN class=texample>void</SPAN> без приведения типов?
              <LI>Как изменится значение указателя после применения к нему 
              операции инкремента (декремента)?
              <LI>Почему для указателей определены сложение и вычитание только с 
              целыми константами?
              <LI>В чем отличие указателя на константу от указателя-константы?
              <LI>Два указателя разных типов указывают на одно и то же место в 
              памяти. Сравните результаты операций разыменования и взятия адреса 
              с такими указателям. Сравните значения указателей.
              <LI>Если объект занимает в памяти несколько байтов, то какой адрес 
              является значением указателя на этот объект?
              <LI>Каким образом при разыменовании указателей становится 
              известно, сколько байтов памяти доступно?</LI></OL>
            <DIV id=mark_182 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript 
src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/urchin.js">
</SCRIPT>

<SCRIPT 
type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
