<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0071)http://www.intuit.ru/department/algorithms/staldata/27/staldata_27.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/printable.css">
<META name=GENERATOR content="MSHTML 9.00.8080.16413"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="COLOR: #000000; FONT-WEIGHT: bold">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD>
    <TD><!-- content -->
      <TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD class=head>Структуры и алгоритмы компьютерной обработки 
        данных</TD></TR>
        <TR>
          <TD height=4><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>27. Лекция: Решение задач на динамические 
            массивы: версия для печати и PDA</SPAN> <BR><SPAN class=rtxt>В 
            лекции рассматриваются преимущества и недостатки управления 
            динамической памятью, типичные ошибки при работе с динамической 
            памятью, организация проверки выделения памяти, многомерные 
            динамические массивы, приемы представления, чтения и записи 
            динамических массивов. </SPAN></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3></H3>
            <P id=id_1><SPAN class=texample>Цель лекции:</SPAN> изучить 
            алгоритмы и приемы чтения-записи, перестановок, поиска и сортировок 
            в динамических массивах, научиться решать задачи с использованием 
            алгоритмов чтения-записи, перестановок, поиска и сортировок в 
            динамических массивах на языке C++.</P>
            <DIV id=mark_1 class=lecture_mark></DIV>
            <P id=id_3>Динамическая память, называемая также "кучей", выделяется 
            явно по запросу программы из ресурсов операционной системы и 
            контролируется указателем. Она не инициализируется автоматически и 
            должна быть явно освобождена. В отличие от статической и 
            автоматической памяти динамическая память практически не ограничена 
            (ограничена лишь размером оперативной памяти) и может динамически 
            меняться в процессе работы программы. Выделим основные преимущества 
            и недостатки динамического управления памятью.</P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <P id=id_4><SPAN class=xml_em_italic>Преимущества:</SPAN></P>
            <DIV id=mark_4 class=lecture_mark></DIV>
            <UL id=id_5>
              <LI>разумное использование динамических структур данных приводит к 
              сокращению объёма памяти, необходимого для работы программы;
              <LI>динамические данные не требуют объявлений их как данных 
              фиксированного размера;
              <LI>ряд алгоритмов более эффективен при реализации их с 
              использованием динамических структур. Например, вставка элемента в 
              статический массив на определенное место требует перемещения части 
              элементов массива. При вставке в середину динамического списка 
              достаточно несколько операторов присваивания.</LI></UL>
            <DIV id=mark_5 class=lecture_mark></DIV>
            <P id=id_9><SPAN class=xml_em_italic>Недостатки:</SPAN></P>
            <DIV id=mark_9 class=lecture_mark></DIV>
            <UL id=id_10>
              <LI>алгоритмы для динамических структур обычно более сложны, 
              трудны для отладки по сравнению с аналогичными для статических 
              данных;
              <LI>использование динамических структур требует затрат на память 
              для ссылок. В некоторых задачах объём памяти, отводимой для 
              ссылок, превосходит объём памяти, выделяемой непосредственно для 
              данных;
              <LI>существуют алгоритмы, реализация которых более эффективна на 
              статических данных.</LI></UL>
            <DIV id=mark_10 class=lecture_mark></DIV><A name=sect2></A>
            <H3>Типичные ошибки при работе с динамической памятью</H3>
            <P id=id_14>При работе с динамической памятью можно совершить 
            большое количество ошибок, которые имеют различные последствия и 
            различную степень тяжести. Большинство этих ошибок проявляется не 
            сразу, а через некоторое время в процессе выполнения программы. 
            Следовательно, такие ошибки трудно находимы и потому особенно 
            опасны. Перечислим наиболее часто встречающиеся варианты ошибок при 
            работе с динамической памятью.</P>
            <DIV id=mark_14 class=lecture_mark></DIV>
            <P id=id_15><SPAN class=xml_em_italic>1) Попытка воспользоваться 
            неинициализированным указателем.</SPAN></P>
            <DIV id=mark_15 class=lecture_mark></DIV>
            <DIV class=example><PRE>float *pi;
*pi=3.14;//использование неинициализированного указателя
</PRE></DIV>
            <P id=id_17>Если <SPAN class=texample>pi</SPAN> – глобальная 
            переменная, то она автоматически инициализируется нулевым значением, 
            т.е. имеет значение <SPAN class=texample>NULL</SPAN>. Разыменование 
            нулевого указателя приводит к ошибке времени выполнения. Если <SPAN 
            class=texample>pi</SPAN> – локальная переменная, то она по умолчанию 
            не инициализируется, а поэтому содержит непредсказуемое значение. 
            Это значение трактуется как адрес вещественной переменной, к которой 
            осуществляется доступ. По чистой случайности может оказаться, что 
            указатель <SPAN class=texample>pi</SPAN> содержит истинный адрес 
            переменной программы, тогда значение переменной будет изменено, 
            выполнение программы продолжится дальше, а факт изменения переменной 
            непредсказуемым образом повлияет на дальнейшее выполнение 
            программы.</P>
            <DIV id=mark_17 class=lecture_mark></DIV>
            <P id=id_22><SPAN class=xml_em_italic>2) "Висячие" 
            указатели.</SPAN></P>
            <DIV id=mark_22 class=lecture_mark></DIV>
            <P id=id_23>После освобождения динамической памяти указатель 
            продолжает указывать на прежний адрес памяти. Такие указатели 
            называются "висячими". Попытка записи по такому указателю не 
            приводит к немедленной ошибке. Однако память, на которую он 
            указывает, могла быть уже выделена другой динамической переменной, и 
            попытка записи приведет к порче этой переменной.</P>
            <DIV id=mark_23 class=lecture_mark></DIV>
            <DIV class=example><PRE>int *p;
p= new int;
*p=55;
delete p; // указатель становится "висячим"
*p=8; // использование "висячего" указателя 
</PRE></DIV>
            <P id=id_25>Если после <SPAN class=texample>delete p;</SPAN> сразу 
            написать <SPAN class=texample>p=NULL;</SPAN>, то в дальнейшем при 
            попытке разыменовать нулевой указатель p возникнет исключение, что 
            является более предпочтительным, чем скрытая ошибка изменения другой 
            переменной. Данный прием следует иметь ввиду и после освобождения 
            динамической переменной обнулять указатель:</P>
            <DIV id=mark_25 class=lecture_mark></DIV>
            <DIV class=example><PRE>delete p; 
p=NULL;
</PRE></DIV>
            <P id=id_29><SPAN class=xml_em_italic>3) "Утечка" памяти.</SPAN></P>
            <DIV id=mark_29 class=lecture_mark></DIV>
            <P id=id_30>Данная ошибка возникает, когда память не освобождается, 
            но перестает контролироваться указателем. Подобную ошибку называют 
            "утечкой" памяти, поскольку такую память невозможно освободить. 
            Такая ошибка труднонаходима, поскольку практически не сказывается на 
            работе приложения. Однако при систематических утечках программа 
            требует все больше памяти у операционной системы, замедляя работу 
            других приложений. Далее приводятся две распространенные ситуации, в 
            которых возникает утечка памяти.</P>
            <DIV id=mark_30 class=lecture_mark></DIV>
            <P id=id_31>Пример. Повторное выделение памяти.</P>
            <DIV id=mark_31 class=lecture_mark></DIV>
            <P id=id_32>Если выделить память повторно для того же указателя, то 
            ранее выделенная память "утечет":</P>
            <DIV id=mark_32 class=lecture_mark></DIV>
            <DIV class=example><PRE>int *p;
p= new int;
*p=55;
p= new int; 
//выделяется новый участок памяти под тот же указатель 
</PRE></DIV>
            <P id=id_34>Пример. Выделение памяти под <SPAN 
            class=xml_em_italic>локальную</SPAN> переменную без 
освобождения.</P>
            <DIV id=mark_34 class=lecture_mark></DIV>
            <DIV class=example><PRE>function pp (int n) {  
  int *p;
  p= new int;
  *p=n;
}
</PRE></DIV>
            <P id=id_36>Такой фрагмент кода наиболее опасен при использовании 
            локальных переменных в функциях. При неоднократных вызовах функция 
            выделяет новую область памяти, не освобождая ее после использования. 
            В результате может возникнуть ситуация нехватки памяти.</P>
            <DIV id=mark_36 class=lecture_mark></DIV>
            <P id=id_37><SPAN class=xml_em_italic>4) Попытка освободить 
            динамическую память, не выделенную ранее.</SPAN></P>
            <DIV id=mark_37 class=lecture_mark></DIV>
            <DIV class=example><PRE>int *p;
delete p; 
</PRE></DIV>
            <P id=id_39>Вызов операции <SPAN class=xml_em_italic>delete</SPAN> 
            для неинициализированного указателя игнорируется, не приводя к 
            генерации ошибки.</P>
            <DIV id=mark_39 class=lecture_mark></DIV>
            <P id=id_40><SPAN class=xml_em_italic>5) Попытка освободить 
            нединамическую память.</SPAN></P>
            <DIV id=mark_40 class=lecture_mark></DIV>
            <DIV class=example><PRE>int *p,i=55;
p=&amp;i;
delete p;
</PRE></DIV>
            <P id=id_42>При вызове <SPAN class=texample>delete</SPAN> для 
            нединамической переменной будет сгенерирована ошибка.</P>
            <DIV id=mark_42 class=lecture_mark></DIV><A name=sect3></A>
            <H3>Проверка на выделение памяти</H3>
            <P id=id_44>Существует единственное числовое значение, которое можно 
            присвоить непосредственно указателю – это <SPAN 
            class=texample>NULL</SPAN>. Нулевой адрес – особый, по этому адресу 
            не может храниться ни одна переменная. То есть указатель, имеющий 
            нулевое значение указывает в "никуда", к такому указателю нельзя 
            применить оператор разыменования.</P>
            <DIV id=mark_44 class=lecture_mark></DIV>
            <P id=id_46>Библиотечные функции <SPAN class=texample>malloc 
            (calloc)</SPAN> или оператор <SPAN class=texample>new</SPAN> 
            используют функцию операционной системы для выделения памяти. Если 
            затребованный размер памяти слишком большой (а также при попытке 
            создать массив из нуля или отрицательного числа элементов), 
            операционная система не будет выделять память и тогда функции или 
            оператору вернет нулевое значение (<SPAN 
            class=texample>NULL</SPAN>). Если это нулевое значение будет 
            присвоено указателю, к которому впоследствии будет применен оператор 
            разыменования или оператор обращения к элементу массива, то 
            программа аварийно завершит работу с ошибкой "segmentation fault" 
            (ошибка сегментации). Для того чтобы избежать таких ошибок 
            необходимо сразу после выделения памяти проверить ее значение, 
            которое возвращает функция или оператор. Проверку можно осуществить 
            с помощью одного из условий: <SPAN class=texample>if 
            (pi==NULL)</SPAN> или <SPAN class=texample>if (!pi)</SPAN>. В случае 
            если это значение равно NULL, выполнить какие-либо действия, 
            например, вывести сообщение о невозможности выделения необходимого 
            объема памяти.</P>
            <DIV id=mark_46 class=lecture_mark></DIV>
            <P id=id_52>Например:</P>
            <DIV id=mark_52 class=lecture_mark></DIV>
            <DIV class=example><PRE>int n=1000000000;
int *pi=new int[n];
if (pi==NULL) { // if (!pi)
  printf ("Требуемая память не выделена!");
  return;
}
</PRE></DIV>
            <P id=id_54>Все рассмотренные функции по работе с динамической 
            памятью могут выделять память размером не более одного сегмента, то 
            есть не более 64K в 16-ти разрядных моделях и не более 4G в 32-х 
            разрядных моделях памяти.</P>
            <DIV id=mark_54 class=lecture_mark></DIV><A name=sect4></A>
            <H3></H3>
            <P id=id_55>Многомерные динамические массивы</P>
            <DIV id=mark_55 class=lecture_mark></DIV>
            <P id=id_56>Для многомерных динамических массивов память 
            распределяется аналогичным образом, что и для двумерных динамических 
            массивов. Следует только помнить, что в дальнейшем ненужную для 
            выполнения программы память следует освобождать. Приведем пример 
            распределения памяти для трехмерного массива размером <SPAN 
            class=texample>n, m, k</SPAN>.</P>
            <DIV id=mark_56 class=lecture_mark></DIV>
            <DIV class=example><PRE>#include &lt;stdlib.h&gt; 
void main () { 
  long ***a; 
  int n, m, k, i, j,l; 
  scanf("%d", &amp;n); 
  scanf("%d", &amp;m); 
  scanf("%d", &amp;k); 
  //распределение памяти 
  a=(long ***) calloc(n,sizeof(long **)); 
  for (i=0; i&lt;n; i++) { 
    a[i]=(long **) calloc(m,sizeof(long *)); 
    for (j=0; j&lt;m; j++) {
      a[i][j]=(long *) calloc(k,sizeof(long)); 
      for (l=0; l&lt;k; l++)
        a[i][j][l]=rand();
    }
  } 
. . . . . . . . . . . . 
  //освобождение памяти 
  for (i=0; i&lt;n; i++) { 
    for (j=0; j&lt;m; j++) 
      free (a[i][j]); 
    free (a[i]); 
  } 
  free (a); 
} 
</PRE></DIV><A name=sect5></A>
            <H3>Приемы чтения и записи динамических массивов</H3>
            <P id=id_59>Для <SPAN class=xml_em_italic>формирования динамического 
            массива</SPAN>, то есть для выделения участка памяти заданного 
            размера для хранения данных определенного типа, необходимо выполнить 
            следующие действия:</P>
            <DIV id=mark_59 class=lecture_mark></DIV>
            <OL id=id_60>
              <LI>Описать указатель (например, переменную <SPAN 
              class=texample>p</SPAN>) определенного типа.
              <LI>Начиная с адреса, определенного указателем, с помощью функций 
              <SPAN class=texample>calloc, malloc</SPAN> или операции new 
              выделить участок памяти определенного размера. После этого p будет 
              адресом первого элемента выделенного участка оперативной памяти 
              (0-й элемент массива), <SPAN class=texample>p+1</SPAN> будет 
              адресовать следующий элемент в выделенном участке памяти (1-й 
              элемент динамического массива), ..., <SPAN 
              class=texample>p+i</SPAN> является адресом i-го элемента. 
              Необходимо только следить, чтобы не выйти за границы выделенного 
              участка памяти. К i-му элементу динамического массива p можно 
              обратиться одним из двух способов <SPAN 
              class=texample>*(p+i)</SPAN> или <SPAN class=texample>p[i]</SPAN>.
              <LI>Когда участок памяти будет не нужен, его необходимо освободить 
              с помощью функции <SPAN class=texample>free()</SPAN> или операции 
              <SPAN class=texample>delete</SPAN>.</LI></OL>
            <DIV id=mark_60 class=lecture_mark></DIV>
            <P id=id_72>Работа с <SPAN class=xml_em_italic>двумерными 
            динамическими массивами</SPAN> основана на двух следующих 
            способах.</P>
            <DIV id=mark_72 class=lecture_mark></DIV>
            <OL id=id_73>
              <LI>Используется двойного указателя – указателя на указатель. 
              <DIV class=example><PRE>float **a; 
//это указатель на float *, или указатель на массив
</PRE></DIV>
              <LI>Применяется одинарный указатель. В этом случае двумерный 
              динамический массив рассматривается как аналог одномерного 
              массива. При работе с динамическими матрицами следует помнить, что 
              выделенный участок памяти под двумерный массив <SPAN 
              class=texample>A(N,M)</SPAN> представляет собой участок памяти 
              размером <SPAN class=texample>N*M</SPAN> элементов. Поэтому 
              выделение памяти будет выглядеть следующим образом: 
              <DIV class=example><PRE>A = (тип *) calloc(N*M, sizeof(тип));
</PRE></DIV>или 
              <DIV class=example><PRE>A = (тип *) malloc(N*M*sizeof(тип));
</PRE></DIV>Для обращения к элементу <SPAN 
              class=texample>A<SUB>i,j</SUB></SPAN> необходимо по номеру строки 
              <SPAN class=texample>i</SPAN> и номеру столбца <SPAN 
              class=texample>j</SPAN> вычислить номер этого элемента <SPAN 
              class=texample>k</SPAN> в одномерном динамическом массиве. 
              Учитывая, что в массиве элементы нумеруются с нуля, <SPAN 
              class=texample>k=i*M+j</SPAN>. Статический элемент матрицы <SPAN 
              class=texample>a[i][j]</SPAN> записывается как <SPAN 
              class=texample>a[i*М+j]</SPAN> или <SPAN 
              class=texample>*(a+i*М+j)</SPAN>. </LI></OL>
            <DIV id=mark_73 class=lecture_mark></DIV>
            <P id=id_89>Чтение и запись данных при работе с динамическими 
            массивами аналогична работе со статическими массивами. 
            Продемонстрируем это в следующем примере.</P>
            <DIV id=mark_89 class=lecture_mark></DIV>
            <P id=id_90><SPAN class=xml_em_italic>Пример 1</SPAN>. Вычислить и 
            запомнить средние арифметические значения положительных элементов 
            каждой строки матрицы A(K,L). Имена входного и выходного файла 
            задаются пользователем. Входной файл в первой строке содержит 
            размерность матрицы, со второй строки задается сама матрица.</P>
            <DIV id=mark_90 class=lecture_mark></DIV>
            <DIV class=example><PRE>#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
void input (int n,int m, int *mas, FILE *t);
void out (int n,int m,int *mas);
void outmas (int n, float *ml, FILE *g);
void work(int n, int m, int *mas, float *ml);

int _tmain(int argc, _TCHAR* argv[]) {
  int *mass,k,l;
  float *ml;
  float sr;
  char file1[10],file2[10];
  FILE *t,*g;
  printf("Введите имя входного файла: ");
  scanf("%s",file1);
  printf("Введите имя выходного файла: ");
  scanf("%s",file2);
  t=fopen(file1,"r");//открытие файла для чтения
  g=fopen(file2,"w");//открытие файла для записи
  fscanf(t,"%d",&amp;k);
  fscanf(t,"%d",&amp;l);
  mass=(int*)malloc(k*l*sizeof(int)); 
  //выделение памяти для массива 
  ml=(float*)malloc(k*sizeof(float)); 
  //выделение памяти для массива
  printf("\nМассив:\n");
  input(k,l,mass,t);
  out(k,l,mass);
  work(k,l,mass,ml);
  printf("\nСредние арифметические значения положительных 
          элементов каждой строки матрицы\n");
  outmas(k,ml,g);
  fclose(t);  //закрытие файла
  fclose(g); //закрытие файла 
  free(ml); //освобождение памяти
  free(mass); //освобождение памяти
  system("pause");
  return 0;
}

void input(int n, int m,int *mas, FILE *t){
  int i,j;
  for (i=0;i&lt;n;i++)
    for (j=0;j&lt;m;j++)
      fscanf(t,"%d",mas+i*m+j);
}
void out (int n,int m, int *mas){
  int i,j;
  for (i=0;i&lt;n;i++) {
    for (j=0;j&lt;m;j++)
      printf("%4d",mas[i*m+j]);
      printf("\n");
      }
}
void outmas (int n, float *ml, FILE *g){
  int i;
  for (i=0;i&lt;n;i++) {
     printf("%6.2f\n",ml[i]);
     fprintf(g,"%6.2f\n",ml[i]);
     }
}
void work(int n, int m, int *mas, float *ml) {
  int i,j,kol;
  for (i=0;i&lt;n;i++){
    ml[i]=0;
    kol=0;
    for (j=0;j&lt;m;j++)
      if (mas[i*m+j]&gt;0) {
        ml[i]+=mas[i*m+j];
        kol++;
      }
  if (kol&gt;0) ml[i]/=kol;
  }
}
</PRE></DIV><A name=sect6></A>
            <H3>Поиск, перестановка и сортировка в динамических массивах</H3>
            <P id=id_92>Задачи по обработке динамических массивов (задачи на 
            поиск, перестановки и сортировки в динамических массивах) 
            реализуются аналогично соответствующим задачам по обработке данных 
            статических массивов.</P>
            <DIV id=mark_92 class=lecture_mark></DIV>
            <P id=id_93>При этом в задачах на обработку двумерных массивов 
            необходимо определить способ просмотра массива (по строкам, по 
            столбцам, вдоль диагоналей и т.д.). При выборе обхода матрицы 
            следует помнить, что параметр внешнего цикла меняется медленнее, чем 
            параметр вложенных в него циклов. Под сортировкой двумерного массива 
            понимают упорядочивание элементов, объединенных в строки или 
            столбцы. В этом случае строку или столбец рассматривают как 
            одномерный массив.</P>
            <DIV id=mark_93 class=lecture_mark></DIV>
            <P id=id_94><SPAN class=xml_em_italic>Пример 2</SPAN>. Дана 
            прямоугольная матрица переставить столбцы таким образом, чтобы их 
            максимальные элементы образовывали неубывающую последовательность. 
            Разрешается использовать только дополнительный одномерный 
            динамический массив.</P>
            <DIV id=mark_94 class=lecture_mark></DIV>
            <DIV class=example><PRE>#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
#include &lt;time.h&gt;

void Initialization(int **mas, int *k, int *l,int **vmas);
void Print(int *mas, int k, int l);
void Work(int *mas, int k, int l,int *vmas);
void FindMax(int *mas, int k, int l,int *vmas);
void Obmen(int *mas,int k,int l,int i,int q);
void Distraction(int *mas,int *vmas);

int _tmain(int argc, _TCHAR* argv[]) {
  int *mass, n, m, *vmass;
  Initialization(&amp;mass, &amp;n, &amp;m, &amp;vmass);
  cout &lt;&lt; "Исходная матрица" &lt;&lt; "\n";
  Print(mass, n, m);
  Work(mass, n, m, vmass);
  cout &lt;&lt; "Преобразованная матрица" &lt;&lt; "\n";
  Print(mass, n, m);
  Distraction(mass, vmass);
  system("pause");
  return 0;
}

void Initialization(int **mas, int *k, int *l,int **vmas){
  int i, j, a, b;
  cout &lt;&lt; "Введите размерность матрицы:" &lt;&lt; "\n";
  cout &lt;&lt; "n = ";
  cin &gt;&gt; *k;
  cout &lt;&lt; "m = ";
  cin &gt;&gt; *l;
  cout &lt;&lt; "Введите границы генерации элементов 
           матрицы:"&lt;&lt;"\n";
  cout &lt;&lt; "a = ";
  cin &gt;&gt; a;
  cout &lt;&lt; "b = ";
  cin &gt;&gt; b;
  srand(time(NULL)*1000);
  *mas = new int[(*k)*(*l)];
  *vmas = new int[(*l)];
  for (i = 0; i &lt; *k ; i++)
    for (j = 0; j &lt; *l ; j++)
      (*mas)[i*(*l)+j] = rand()%(b-a)+a;
}

void Print(int *mas, int k, int l){
  int i, j;
  for (i = 0; i &lt; k ; i++){
    for (j = 0; j &lt; l ; j++)
      cout &lt;&lt; mas[i*l+j] &lt;&lt; "   ";
    cout &lt;&lt; "\n";
  }
}

void Work(int *mas, int k, int l,int *vmas){
  int i, j, q, r;
  FindMax(mas, k, l, vmas);
  for( i=0; i &lt; l; i++) { // i - номер текущего шага
    q=i;
    for( j=i+1; j &lt; l; j++)
    //цикл выбора наименьшего максимального элемента
      if (vmas[j]&lt;vmas[q]) 
        q=j;//q - индекс наименьшего максимального элемента
    r = vmas[q]; // меняем местами наименьший с vmas[i]
    vmas[q] = vmas[i]; 
    vmas[i] = r;  
    Obmen(mas, k, l, i, q);
    //меняем местами столбцы с номерами i и q матрицы mas 
  }
}

void FindMax(int *mas, int k, int l,int *vmas){
  int i, j;
  for (j = 0; j &lt; l; j++){
    vmas[j] = mas[j];
    for (i = 1; i &lt; k; i++)
      if (vmas[j] &lt; mas[i*l+j]) 
        vmas[j] = mas[i*l+j];
  }  
}

void Obmen(int *mas,int k,int l,int i,int q){
  int j, r;
  for (j = 0; j &lt; k; j++){
    r = mas[j*l+i];
    mas[j*l+i] = mas[j*l+q];
    mas[j*l+q] = r;
  }
}

void Distraction(int *mas,int *vmas){
  delete(vmas);
  delete(mas);
}
</PRE></DIV><A name=sect7></A>
            <H3>Ключевые термины</H3>
            <P id=id_96><B>"Висячий" указатель</B> – указатель на освобожденный 
            блок динамической памяти; признак ошибочного использования 
            динамической памяти.</P>
            <DIV id=mark_96 class=lecture_mark></DIV>
            <P id=id_97><B>"Утечка" памяти</B> – процесс выделения динамической 
            памяти без ее освобождения, приводящий к состоянию нехватки памяти; 
            признак ошибочного использования динамической памяти.</P>
            <DIV id=mark_97 class=lecture_mark></DIV>
            <P id=id_98><B>Использование неинициализированного указателя</B> – 
            попытка обращения к неопределенному адресу памяти или к значению 
            NULL; признак ошибочного использования динамической памяти.</P>
            <DIV id=mark_98 class=lecture_mark></DIV>
            <P id=id_99><B>Многомерный динамический массив</B> – это многомерный 
            массив, расположенный в динамической памяти.</P>
            <DIV id=mark_99 class=lecture_mark></DIV>
            <P id=id_100><B>Ошибки при работе с динамической памятью</B> – 
            приемы некорректной работы с динамической памятью, приводящие к 
            выполнению логически неверных действий в программе.</P>
            <DIV id=mark_100 class=lecture_mark></DIV><A name=sect8></A>
            <H3>Краткие итоги</H3>
            <OL id=id_101>
              <LI>Динамическая память не инициализируется автоматически и должна 
              быть явно освобождена.
              <LI>Динамическое управление памятью имеет как преимущества, так и 
              недостатки.
              <LI>При некорректной работе с динамической памятью можно совершить 
              большое количество ошибок, которые имеют различные последствия и 
              различную степень тяжести. К основным ошибкам относятся: попытка 
              воспользоваться неинициализированным указателем; "висячие" 
              указатели, "утечка" памяти, попытка освободить динамическую 
              память, не выделенную ранее; попытка освободить нединамическую 
              память.
              <LI>Во избежание ошибок целесообразно после выделения динамической 
              памяти проверять ее значение, которое возвращается функцией или 
              оператором.
              <LI>Работа с двумерными динамическими массивами можно организовать 
              двумя способами: через двойной указатель (указатель на указатель) 
              и через одинарный указатель (двумерный динамический массив 
              рассматривается как аналог одномерного динамического массива).
              <LI>В многомерных динамических массивах память распределяется 
              аналогично двумерным динамическим массивам.
              <LI>Задачи по обработке динамических массивов (задачи на поиск, 
              перестановки и сортировки в динамических массивах) реализуются 
              аналогично соответствующим задачам по обработке данных статических 
              массивов.</LI></OL>
            <DIV id=mark_101 class=lecture_mark></DIV><A name=sect9></A>
            <H3>Лабораторная работа 27. Решение задач на динамические 
            массивы</H3>
            <P id=id_109><B>Цель работы:</B> изучить алгоритмы и приемы 
            чтения-записи, перестановок, поиска и сортировок в динамических 
            массивах, научиться решать задачи с использованием алгоритмов 
            чтения-записи, перестановок, поиска и сортировок в динамических 
            массивах на языке C++.</P>
            <DIV id=mark_109 class=lecture_mark></DIV>
            <P id=id_110>При выполнении лабораторной работы для каждого задания 
            требуется написать программу на языке С++, которая получает на входе 
            числовые данные (в зависимости от постановки задачи), выполняет 
            генерацию и вывод одномерного или двумерного массива указанного 
            типа. Для хранения массивов необходимо использовать ресурсы 
            динамической памяти. В каждой задаче необходимо выполнить обработку 
            двумерных или одномерных динамических массивов. Для этого необходимо 
            разработать алгоритм (поиска, замены или перестановок в массивах) и 
            реализовать его в виде отдельной функции. Ввод данных осуществляется 
            с клавиатуры с учетом требований к входным данным, содержащихся в 
            постановке задачи. Ограничениями на входные данные является диапазон 
            используемого числового типа данных в языке С++ и максимально 
            допустимый размер динамической памяти.</P>
            <DIV id=mark_110 class=lecture_mark></DIV>
            <P id=id_111><B>Теоретические сведения.</B></P>
            <DIV id=mark_111 class=lecture_mark></DIV>
            <P id=id_112>Ознакомьтесь с материалом лекции 27.</P>
            <DIV id=mark_112 class=lecture_mark></DIV>
            <P id=id_113><B>Задания к лабораторной работе.</B></P>
            <DIV id=mark_113 class=lecture_mark></DIV>
            <P id=id_114>Выполните приведенные ниже задания.</P>
            <DIV id=mark_114 class=lecture_mark></DIV>
            <OL id=id_115>
              <LI>Двумерная целочисленная квадратная матрица размера n задает 
              преобразование базиса <SPAN class=texample>Е</SPAN> в базис <SPAN 
              class=texample>Е'</SPAN>, а одномерный массив из n вещественных 
              чисел – координаты вектора в базисе <SPAN class=texample>Е</SPAN>. 
              Найдите координаты этого вектора в базисе <SPAN 
              class=texample>Е'</SPAN>.
              <LI>Переставьте столбцы вещественной квадратной матрицы так, чтобы 
              элементы ее побочной диагонали образовали невозрастающую 
              последовательность.
              <LI>Латинским квадратом размера <SPAN class=texample>n</SPAN> 
              называется таблица <SPAN class=texample>n &#215; n</SPAN>, заполненная 
              <SPAN class=texample>n</SPAN> различными символами таким образом, 
              чтобы в каждой строке и в каждом столбце встречались все <SPAN 
              class=texample>n</SPAN> символов (каждый по одному разу). 
              Латинские квадраты существуют для любого <SPAN 
              class=texample>n</SPAN>. Заполните латинский квадрат размера <SPAN 
              class=texample>n</SPAN> натуральными числами от 1 до <SPAN 
              class=texample>n</SPAN>.
              <LI>Для данной вещественной квадратной матрицы составьте 
              соответствующую матрицу миноров каждого ее элемента. </LI></OL>
            <DIV id=mark_115 class=lecture_mark></DIV><A name=sect10></A>
            <H3>Указания к выполнению работы.</H3>
            <P id=id_131>Каждое задание необходимо решить в соответствии с 
            изученными методами объявления, генерации и вывода двумерных и 
            одномерных динамических массивов в языке С++. Обработку данных 
            необходимо выполнить, используя алгоритмы сортировок или 
            перестановок данных в двумерных массивах. В задаче 4 необходимо 
            выполнить числовую обработку данных двумерного динамического 
            массива. Вывод входных данных и результатов их обработки следует 
            осуществить на экран. При разработке программного кода требуется 
            использовать метод процедурной абстракции и комментировать фрагменты 
            кода.</P>
            <DIV id=mark_131 class=lecture_mark></DIV>
            <P id=id_132>Следует реализовать каждое задание в соответствии с 
            приведенными этапами:</P>
            <DIV id=mark_132 class=lecture_mark></DIV>
            <UL id=id_133>
              <LI>изучить словесную постановку задачи, выделив при этом все виды 
              данных;
              <LI>сформулировать математическую постановку задачи;
              <LI>выбрать метод решения задачи, если это необходимо;
              <LI>разработать графическую схему алгоритма;
              <LI>записать разработанный алгоритм на языке С++;
              <LI>разработать контрольный тест к программе;
              <LI>отладить программу;
              <LI>представить отчет по работе.</LI></UL>
            <DIV id=mark_133 class=lecture_mark></DIV>
            <P id=id_142><B>Требования к отчету.</B></P>
            <DIV id=mark_142 class=lecture_mark></DIV>
            <P id=id_143>Отчет по лабораторной работе должен соответствовать 
            следующей структуре.</P>
            <DIV id=mark_143 class=lecture_mark></DIV>
            <UL id=id_144>
              <LI>Титульный лист.
              <LI>Словесная постановка задачи. В этом подразделе проводится 
              полное описание задачи. Описывается суть задачи, анализ входящих в 
              нее физических величин, область их допустимых значений, единицы их 
              измерения, возможные ограничения, анализ условий при которых 
              задача имеет решение (не имеет решения), анализ ожидаемых 
              результатов.
              <LI>Математическая модель. В этом подразделе вводятся 
              математические описания физических величин и математическое 
              описание их взаимодействий. Цель подраздела – представить решаемую 
              задачу в математической формулировке.
              <LI>Алгоритм решения задачи. В подразделе описывается разработка 
              структуры алгоритма, обосновывается абстракция данных, задача 
              разбивается на подзадачи. Схема алгоритма выполняется по ЕСПД 
              (ГОСТ 19.003-80 и ГОСТ 19.002-80).
              <LI>Листинг программы. Подраздел должен содержать текст программы 
              на языке программирования С++, реализованный в среде MS Visual 
              Studio 2010.
              <LI>Контрольный тест. Подраздел содержит наборы исходных данных и 
              полученные в ходе выполнения программы результаты.
              <LI>Выводы по лабораторной работе. 
              <LI>Ответы на контрольные вопросы.</LI></UL>
            <DIV id=mark_144 class=lecture_mark></DIV>
            <P id=id_153><B>Контрольные вопросы</B></P>
            <DIV id=mark_153 class=lecture_mark></DIV>
            <OL id=id_154>
              <LI>Всегда ли эффективно использование динамической памяти в 
              программах?
              <LI>Почему ошибки при работе с динамической памятью относят к 
              опасным?
              <LI>Опишите последствия использования в программах 
              неинициализированных указателей.
              <LI>Почему в программах не следует оставлять "висячие" указатели?
              <LI>Почему выделенную ранее динамическую память следует 
              освобождать после использования?
              <LI>К каким последствиям в работе программы приводит попытка 
              освободить динамическую память, не выделенную ранее? 
              <LI>Почему к нулевому указателю нельзя применить операцию 
              разыменования?
              <LI>Какие используются способы представления двумерных 
              динамических массивов?
              <LI>Назовите порядок выделения и освобождения памяти под двумерный 
              динамический массив. Укажите различия для разных способов 
              представления двумерных динамических массивов.</LI></OL>
            <DIV id=mark_154 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript 
src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/urchin.js">
</SCRIPT>

<SCRIPT 
type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
