<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0071)http://www.intuit.ru/department/algorithms/staldata/22/staldata_22.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/printable.css">
<META name=GENERATOR content="MSHTML 9.00.8080.16413"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="COLOR: #000000; FONT-WEIGHT: bold">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD>
    <TD><!-- content -->
      <TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD class=head>Структуры и алгоритмы компьютерной обработки 
        данных</TD></TR>
        <TR>
          <TD height=4><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>22. Лекция: Работа с элементами файлов: 
            версия для печати и PDA</SPAN> <BR><SPAN class=rtxt>В лекции 
            рассматриваются особенности организации файлового ввода-вывода в С++ 
            в потоковом и стандартном режимах, основные типы задач 
            редактирования элементов файлов, способы алгоритмизации задач 
            исключения, вставки и замены в файлах, приводятся примеры решения 
            типовых задач. </SPAN></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3></H3>
            <P id=id_1><B>Цель лекции:</B> изучить алгоритмы и приемы 
            чтения-записи, перестановок, поиска и сортировок элементов файла и 
            научиться решать задачи с использованием алгоритмов чтения-записи, 
            перестановок, поиска и сортировок элементов файлов на языке C++.</P>
            <DIV id=mark_1 class=lecture_mark></DIV><A name=sect2></A>
            <H3>Стандартизация ввода-вывода в С++</H3>
            <P id=id_2>В программах зачастую необходимо обрабатывать данные 
            больших объемов, причем сами данные и/или результаты обработки 
            требуется сохранять относительно долгое время. Проблему выделения 
            дополнительных ресурсов для хранения обрабатываемых данных можно 
            решить за счет динамической памяти, однако, ее ресурс ограничен. 
            Организовать длительное хранение информации только средствами 
            оперативной памяти практически невозможно ввиду энергозависимости 
            устройства. Поэтому работу с объемными данными и организацию 
            долговременного хранения данных в языках программирования 
            осуществляют с помощью файлов, расположенных на внешних 
            носителях.</P>
            <DIV id=mark_2 class=lecture_mark></DIV>
            <P id=id_3>Файловый ввод-вывод, как самостоятельный аппарат, не 
            предусмотрен в функциональной части языка С, так как изначально был 
            зависим от платформенной реализации. Вместе с тем, обмен данными с 
            внешними устройствами осуществляется с помощью организации потоков – 
            общего понятия, которое достаточно наглядно демонстрирует 
            направленную передачу данных по специально организованным каналам. 
            При этом под внешними устройствами следует понимать устройства 
            ввода-вывода данных, к которым также можно отнести и файлы. 
            Прототипы основных функций для работы с файлами входят в стандартную 
            библиотеку <SPAN class=texample>stdio.h</SPAN>. Эти функции описаны 
            в стандарте ANSI. </P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <P id=id_5>В C++ часто используются библиотеки классов для 
            ввода-вывода, в том числе и для обмена данными с использованием 
            файлов. При этом функции из стандартных библиотек, соответствующие 
            стандарту ANSI, поддерживаются всеми С-компиляторами, что 
            обеспечивает совместимость программ и достаточную мобильность при 
            переносе на другие платформы.</P>
            <DIV id=mark_5 class=lecture_mark></DIV><A name=sect3></A>
            <H3>Особенности потокового ввода-вывода в файлы</H3>
            <P id=id_6>С точки зрения концепции языка С++ файлы представляют 
            собой последовательности байтов (в С и С++ нет понятия 
            &lt;структурированный&lt; или &lt;типизированный&lt; файл, как, 
            например, в языке Pascal). Именно поэтому передача данных в потоки 
            ввода-вывода осуществляется побайтно. Вместе с символами в виде 
            байтов передаются и управляющие последовательности, такие как 
            перевод строки (<SPAN class=texample>'\n'</SPAN> – шестнадцатеричный 
            код <SPAN class=texample>0A</SPAN>), возврат каретки (<SPAN 
            class=texample>'\r'</SPAN> – шестнадцатеричный код <SPAN 
            class=texample>0D</SPAN>), символ конца файла (шестнадцатеричный код 
            <SPAN class=texample>1A</SPAN>) и другие. Операционные системы MS 
            DOS и MS Windows рассматривают пару символов <SPAN 
            class=texample>'\r\n'</SPAN> как один символ. Это обеспечивает 
            читабельность содержащейся информации, так как придает определенную 
            структуру файлу в виде строк. В системе Unix строки разделяются 
            одним символом, который интерпретируется как <SPAN 
            class=texample>new line</SPAN>. Таким образом, внутреннее 
            представление текста всегда соответствует системе Unix, а внешнее – 
            реально используемой операционной системе.</P>
            <DIV id=mark_6 class=lecture_mark></DIV>
            <P id=id_14>Поток в С++ можно рассматривать как отдельный <SPAN 
            class=xml_em_italic>класс</SPAN> (тип данных), который представляют 
            объекты со схожей организацией последовательной передачи данных от 
            источника к приемнику. Потоки ввода/вывода, такие как <SPAN 
            class=texample>cin</SPAN> и <SPAN class=texample>cout</SPAN>, 
            являются примерами объектов класса &lt;поток&gt;. Список функций для 
            работы с файловыми потоками хранится в заголовочном файле <SPAN 
            class=texample>fstream.h</SPAN>.</P>
            <DIV id=mark_14 class=lecture_mark></DIV>
            <P id=id_18>В С++ предусмотрены различные режимы обмена данными в 
            файловых потоках. Разница в организации обмена информацией 
            заключается в наличии/отсутствии буферизации и преобразования типов 
            данных перед помещением в поток или после извлечения из потока.</P>
            <DIV id=mark_18 class=lecture_mark></DIV>
            <P id=id_19><SPAN class=xml_em_italic>Пример 1</SPAN>. Программа 
            печатает собственный код на экран и другой файл. Файл с программным 
            кодом сохранен как <SPAN class=texample>Task_1.cpp</SPAN>.</P>
            <DIV id=mark_19 class=lecture_mark></DIV>
            <DIV class=example><PRE>#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
#include &lt;fstream&gt;
int _tmain(int argc, _TCHAR* argv[]){
  char character;
  ifstream in_stream;
  ofstream out_stream;
  in_stream.open("Task_1.cpp");
  out_stream.open("Copy.txt");
  in_stream.get(character);
  while (!in_stream.eof()) {
    cout &lt;&lt; character;
    out_stream.put(character);
    in_stream.get(character);
  }
  out_stream.close();
  in_stream.close();
  system("pause");
  return 0;
}
</PRE></DIV>
            <P id=id_22>Последовательное чтение данных из файла неудобно, если 
            требуется изменить последовательность доступа к данным. Например, 
            прочитать последний символ или последнюю строку. Еще более 
            трудоемкими задачами являются перестановки или сортировки данных в 
            файле. Особенно, если при этом нельзя использовать дополнительный 
            массив данных, в котором предполагается временно сохранить 
            содержимое файла (например, в случае больших объемов данных).</P>
            <DIV id=mark_22 class=lecture_mark></DIV><A name=sect4></A>
            <H3>Доступ к элементам файла</H3>
            <P id=id_23>Если рассматривать файл как последовательность байтов, 
            то элементом файла будет выступать последовательность нулей и единиц 
            размером в один байт.</P>
            <DIV id=mark_23 class=lecture_mark></DIV>
            <P id=id_24>Функция <SPAN class=texample>fseek</SPAN> перемещает 
            указатель, соответствующий потоку <SPAN 
            class=texample>stream</SPAN>, на новое место расположения, отстоящее 
            от начала на указанное число байтов. Следующая операция в потоке 
            выполняется над новым месторасположением. Если поток открыт для 
            обновления, то следующей операцией будет либо чтение, либо запись. 
            Функция <SPAN class=texample>fseek</SPAN> используется для 
            перемещения указателя в любое место файла. Указатель может быть 
            также размещен за концом файла. Однако попытка расположить указатель 
            до начала файла приведет к ошибке. Для потоков, открытых в режиме 
            преобразования типов, применение <SPAN class=texample>fseek</SPAN> 
            является ограниченным, т.к. комбинации управляющих 
            последовательностей перевода строки могут стать причиной выработки 
            непредвиденного результата.</P>
            <DIV id=mark_24 class=lecture_mark></DIV><A name=sect5></A>
            <H3>Задачи редактирования файла</H3>
            <P id=id_29>Более сложными являются задачи редактирования файлов на 
            программном уровне. К <SPAN class=xml_em_italic>типовым операциям 
            над файлами</SPAN> можно отнести:</P>
            <DIV id=mark_29 class=lecture_mark></DIV>
            <OL id=id_30>
              <LI>Исключение из файла фрагмента текста.
              <LI>Вставка в файл фрагмента текста. 
              <LI>Замена фрагмента текста файла на другой фрагмент.
              <LI>Упорядочивание элементов файла по определенному ключу.</LI></OL>
            <DIV id=mark_30 class=lecture_mark></DIV>
            <P id=id_35>Операцию замены можно выполнить с помощью первых двух 
            операций: исключить один фрагмент текста и вставить другой. Но 
            поскольку эта операция широко распространена, она часто 
            рассматривается как отдельная операция.</P>
            <DIV id=mark_35 class=lecture_mark></DIV>
            <P id=id_36>Собственно редактирование можно было бы выполнять 
            аналогично, но в системе предусмотрены меры, которые способствуют 
            сохранению информации в аварийных ситуациях, то есть система всегда 
            готова закрыть файл, выполнив для этого минимально необходимое 
            количество операций. Даже при зависании машины файл, в целом, не 
            должен быть испорчен. Системная защита реализована следующим 
            образом. В конце текстовых файлов должен быть записан управляющий 
            символ конца файла, который в действительности помещается на 
            последнюю позицию при выполнении любой операции записи в файл. Так 
            как работа с файлом осуществляется через буфер, то символ конца 
            файла записывается в этот буфер после каждой операции записи, а не 
            при физическом сохранении содержимого буфера на диск.</P>
            <DIV id=mark_36 class=lecture_mark></DIV>
            <P id=id_37>По этой причине невозможно непосредственно реализовать 
            такую операцию, как запись в середину файла вместо одного символа 
            другого. Из-за указанной особенности реализации операций записи в 
            файл непосредственно прямым способом эту задачу не решить, поскольку 
            после записи символа в требуемом месте после него будет записан 
            символ конца файла, что приведет к тому, что весь остаток файла от 
            места перезаписи до конца файла больше считываться не будет.</P>
            <DIV id=mark_37 class=lecture_mark></DIV>
            <P id=id_38>Таким образом, для выполнения операций исключения, 
            вставки и замены фрагментов текста в файлах можно использовать 
            только два способа (а также их комбинацию).</P>
            <DIV id=mark_38 class=lecture_mark></DIV>
            <OL id=id_39>
              <LI>Рабочую память выделять в памяти программы и считывать в нее 
              файл для обработки (с целью экономного расходования памяти 
              желательно пользоваться массивами указателей). 
              <LI>В качестве рабочей памяти использовать вспомогательный 
              файл.</LI></OL>
            <DIV id=mark_39 class=lecture_mark></DIV>
            <P id=id_42><SPAN class=xml_em_italic>Первый способ</SPAN> не 
            вызывает трудностей при небольших размерах файла. Если же файл 
            целиком нельзя разместить в памяти программы, то алгоритм 
            усложняется, поскольку файл приходится считывать по частям и 
            осуществлять перенос информации из одной части в другую.</P>
            <DIV id=mark_42 class=lecture_mark></DIV>
            <P id=id_43>При <SPAN class=xml_em_italic>втором способе</SPAN> 
            размер файла не играет существенной роли, но ограничение по 
            использованию определяется наличием свободного места на диске. Кроме 
            того, после выполнения обработки необходимо исключать 
            вспомогательный файл. Поэтому этот способ оправдан, когда в 
            результате операции редактирования формируется новый файл, который 
            будет сохранять все результаты изменений. Ниже приведены примеры 
            программ вставки символа в файл, иллюстрирующие оба из указанных 
            способов. В первом примере для вставки символа используется память 
            программы. Файл считывается в символьный массив (буфер), символ 
            вставляется в этот массив (для этого предварительно часть массива от 
            точки вставки до конца копируется со сдвигом на один символ вправо, 
            освобождая место для символа), после этого массив переписывается 
            обратно в исходный файл.</P>
            <DIV id=mark_43 class=lecture_mark></DIV>
            <P id=id_44><SPAN class=xml_em_italic>Пример 2</SPAN>. Замещение 
            символа в файле на введенный символ. В качестве дополнительной 
            области используется память программы.</P>
            <DIV id=mark_44 class=lecture_mark></DIV>
            <DIV class=example><PRE>#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
#include &lt;conio.h&gt; 
#include &lt;ctype.h&gt; 
#include &lt;io.h&gt; 
#define SIZE 40 
int _tmain(int argc, _TCHAR* argv[]){
  char *buffer,str[SIZE],*pt,*qt,c; 
  long n; 
  int i,k,len; 
  FILE *f; 
  f = fopen("copy.txt","r+");
  //Режим "r" без '+' создает защиту от записи 
  printf("\n Введите символ и позицию вставки\n"); 
  c = getchar();
  scanf("%d",&amp;k); 
  n = filelength (fileno(f));
  //число символов в файле
  len = (int)n-1 ; 
  //поправка на символ конца файла
  buffer = (char*)malloc(len);
  fread(buffer, len,1,f);
  fseek(f,0L,SEEK_SET); 
  /*После команды fread текущая позиция в файле изменилась,
    поэтому возврат ее в исходное положение*/
  //Установить указатель на текущий символ на конец буфера 
  pt = buffer; 
  while(*pt++); 
  qt = pt + 1; // Второй указатель на 1 позицию вправо 
  for (i = 0; i &lt; len - k + 1; i++) 
  // Копирование до точки вставки 
  *qt-- = *pt--; 
  buffer[k - 1] = c; 
  // Вставка символа, поскольку место свободно 
  fwrite(buffer, len,1,f); 
  fseek(f,0L,SEEK_SET);
  // После команды fwrite позиция в файле изменилась 
  fscanf(f,"%s",str); 
  printf("\n Cтрока после вставки равна %s",str); 
  system("pause");
  return 0;
}
</PRE></DIV>
            <P id=id_46><SPAN class=xml_em_italic>Пример 3</SPAN>. Вставка 
            фрагмента в файл. В качестве дополнительной области используется 
            другой файл.</P>
            <DIV id=mark_46 class=lecture_mark></DIV>
            <DIV class=example><PRE>#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
#include &lt;io.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;conio.h&gt; 
#include &lt;ctype.h&gt; 
#define SIZE 2000 
int _tmain(int argc, _TCHAR* argv[]){
  FILE *f1, *f2;
  char str[SIZE],c;
  int i,n;
  f1 = fopen("copy1.txt","w");
  f2 = fopen("copy.txt","r");
  printf("\nВведите позицию и фрагмент для вставки \n"); 
  scanf("%d%s",&amp;n,str); 
  if (n &gt; 0 &amp;&amp; n &lt; (int)filelength (fileno(f2)) ) {
  //Обработка  
    i = 1; 
    // Переписать исходный файл в конечный до точки вставки  
    while(i &lt; n &amp;&amp; feof(f2) == 0) {
      c = getc(f2);
      putc(c,f1);
      i++;
    }
    fputs(str,f1); // Переписать вставляемый фрагмент 
    // Переписать исходный файл в конечный до конца 
    while(feof(f2) == 0) {
      c = getc(f2);
        if (c!=-1) putc(c,f1);
    }
  } // Конец оператора if  
  else printf("\nОшибка ввода параметра смещения (%d)",n); 
  system("pause");
  return 0;
}
</PRE></DIV>
            <P id=id_48>Чтобы вставить строку в середину файла, используя 
            вспомогательный файл, необходимо проделать следующий алгоритм.</P>
            <DIV id=mark_48 class=lecture_mark></DIV>
            <OL id=id_49>
              <LI>Открыть входной файл в режиме чтения и вспомогательный файл в 
              режиме записи (этот файл будет создан автоматически). 
              <LI>Прочесть из входного файла текст до места вставки. 
              <LI>Записать прочитанный фрагмент во вспомогательный файл. 
              <LI>Записать во вспомогательный файл вставляемый фрагмент.
              <LI>Прочесть из входного файла остаточный фрагмент и записать его 
              во вспомогательный файл. 
              <LI>Закрыть оба файла. </LI></OL>
            <DIV id=mark_49 class=lecture_mark></DIV>
            <P id=id_56>Пример 4. Для редактирования файла используется 
            временный файл.</P>
            <DIV id=mark_56 class=lecture_mark></DIV>
            <DIV class=example><PRE>#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
#define BSIZE 200 
int _tmain(int argc, _TCHAR* argv[]){
  char arg[20]="task.txt";
  char buf[BSIZE]; 
  int ch; 
  FILE *in, *tmp; 
  in=fopen(arg,"rb"); 
  if(in==NULL) 
     printf("Не открывается файл %s\n", arg); 
  else {
    tmp = tmpfile(); 
    buf[0]='\t'; 
    while(fgets(buf+1,BSIZE-1,in) != NULL) 
      fputs(buf,tmp); 
    fclose(in); 
    in = fopen(arg,"wb"); 
    fseek(tmp,0l,SEEK_SET); 
    while ((ch=fgetc(tmp)) != EOF) 
      fputc(ch,in); 
    fclose(in); 
    fclose(tmp); 
  }
  system("pause");
  return 0;
}
</PRE></DIV><A name=sect6></A>
            <H3>Ключевые термины</H3>
            <P id=id_58><B>Класс поток</B> – это тип данных, представленный 
            объектами со схожей организацией последовательной передачи данных от 
            источника к приемнику.</P>
            <DIV id=mark_58 class=lecture_mark></DIV>
            <P id=id_59><B>Рабочая память</B> – это дополнительная область 
            памяти, предназначенная для временного хранения изменений при 
            редактировании файла.</P>
            <DIV id=mark_59 class=lecture_mark></DIV>
            <P id=id_60><B>Редактирование файла на программном уровне</B> – это 
            изменения, производимые с элементами файла в процессе работы 
            программ.</P>
            <DIV id=mark_60 class=lecture_mark></DIV>
            <P id=id_61><B>Стандарт ANSI</B> – стандарт языка С, опубликованный 
            Американским национальным институтом стандартов.</P>
            <DIV id=mark_61 class=lecture_mark></DIV>
            <P id=id_62><B>Элемент файла</B> – это последовательность нулей и 
            единиц размером в один байт.</P>
            <DIV id=mark_62 class=lecture_mark></DIV><A name=sect7></A>
            <H3>Краткие итоги</H3>
            <OL id=id_63>
              <LI>Работу с объемными данными и организацию долговременного 
              хранения данных в языках программирования осуществляют с помощью 
              файлов, расположенных на внешних носителях.
              <LI>Файловый ввод-вывод, как самостоятельный аппарат, не 
              предусмотрен в стандарте языка С.
              <LI>С точки зрения концепции языка С++ файлы представляют собой 
              последовательности байтов.
              <LI>Поток в С++ можно рассматривать как отдельный класс.
              <LI>При буферизированном вводе-выводе данных искажение информации 
              может возникать при чтении управляющих последовательностей.
              <LI>К типовым задачам редактирования файлов на программном уровне 
              относятся: исключение, вставка, замена и упорядочивание элементов. 
              Причем первые два вида задач являются базовыми, и к их реализации 
              можно свести остальные.
              <LI>При буферизированном вводе-выводе данных вставка элемента в 
              середину файла приводит к усечению файла до вставляемого элемента.
              <LI>Редактирование файлов выполняется с использованием рабочей 
              памяти для сохранения промежуточных результатов.
              <LI>Для организации рабочей памяти при редактировании файла 
              используют массивы, вспомогательные фалы или их 
комбинацию.</LI></OL>
            <DIV id=mark_63 class=lecture_mark></DIV><A name=sect8></A>
            <H3>Лабораторная работа 22. Работа с элементами файлов</H3>
            <P id=id_73><B>Цель работы:</B> изучить алгоритмы и приемы 
            чтения-записи, перестановок, поиска и сортировок элементов файла и 
            научиться решать задачи с использованием алгоритмов чтения-записи, 
            перестановок, поиска и сортировок элементов файлов на языке C++.</P>
            <DIV id=mark_73 class=lecture_mark></DIV>
            <P id=id_74>При выполнении лабораторной работы для каждого задания 
            требуется написать программу на языке С++, которая получает на входе 
            строковые величины, являющиеся корректными именами входных и 
            выходных файлов (при этом в программе следует предусмотреть проверку 
            существования и корректности открытия используемых файлов). Ввод 
            данных осуществляется из входных файлов с учетом требований к 
            входным данным, содержащихся в постановке задачи. Ограничениями на 
            входные данные является максимальный размер строковых данных и 
            допустимый диапазон числовых типов в языке С++. При некорректном 
            открытии файла программа должна завершить работу с выдачей на экран 
            соответствующего сообщения. Считанные из файла данные обрабатываются 
            в соответствии с условием задачи с помощью алгоритмов перестановок, 
            поиска или сортировок, после чего осуществляется вывод в выходной 
            файл.</P>
            <DIV id=mark_74 class=lecture_mark></DIV>
            <P id=id_75><B>Теоретические сведения.</B></P>
            <DIV id=mark_75 class=lecture_mark></DIV>
            <P id=id_76>Ознакомьтесь с материалом лекции 22.</P>
            <DIV id=mark_76 class=lecture_mark></DIV>
            <P id=id_77><B>Задания к лабораторной работе.</B></P>
            <DIV id=mark_77 class=lecture_mark></DIV>
            <P id=id_78>Выполните приведенные ниже задания.</P>
            <DIV id=mark_78 class=lecture_mark></DIV>
            <OL id=id_79>
              <LI>Файл заполнен символами латинского алфавита. Выведите в другой 
              файл все неповторяющиеся символы исходного файла. Дополнительный 
              массив не использовать.
              <LI>Дан входной файл, каждая строка которого содержит одно целое 
              число. Удалите все числа между первым максимальным и последним 
              минимальным. Дополнительный массив не использовать.
              <LI>Даны два входных текстовых файла. Сформируйте выходной файл, 
              вставив в первый входной файл содержимое второго входного файла с 
              указанной позиции. Если вставка невозможна, выдайте об этом 
              сообщение.
              <LI>Даны два файла вещественных чисел, в которых данные 
              отсортированы по неубыванию. Сформируйте выходной файл из чисел 
              первого и второго входных файлов, чтобы его данные были 
              отсортированы по невозрастанию.</LI></OL>
            <DIV id=mark_79 class=lecture_mark></DIV>
            <P id=id_84><B>Указания к выполнению работы.</B></P>
            <DIV id=mark_84 class=lecture_mark></DIV>
            <P id=id_85>Каждое задание необходимо решить в соответствии с 
            изученными методами и алгоритмами обработки файлов в языке С++. В 
            программном коде к каждой задаче следует выполнять чтение данных из 
            существующих входных файлов (имя каждого файла вводится в виде 
            строки символов и считается корректным с точки зрения организации 
            файловой системы). Данные входных файлов необходимо обработать, 
            применив алгоритмы поиска, перестановок или сортировок. В задачах 1 
            и 2 нельзя использовать дополнительные массивы для хранения 
            промежуточных данных. Вывод следует осуществить в выходной файл, имя 
            которого вводится как строка символов с клавиатуры. Данные входного 
            и выходного файлов необходимо дублировать на экране с 
            соответствующими комментариями. Программу для решения каждого 
            задания необходимо разработать методом процедурной абстракции, 
            оформив комментарии к коду.</P>
            <DIV id=mark_85 class=lecture_mark></DIV>
            <P id=id_86>Следует реализовать каждое задание в соответствии с 
            приведенными этапами:</P>
            <DIV id=mark_86 class=lecture_mark></DIV>
            <UL id=id_87>
              <LI>изучить словесную постановку задачи, выделив при этом все виды 
              данных;
              <LI>сформулировать математическую постановку задачи;
              <LI>выбрать метод решения задачи, если это необходимо;
              <LI>разработать графическую схему алгоритма;
              <LI>записать разработанный алгоритм на языке С++;
              <LI>разработать контрольный тест к программе;
              <LI>отладить программу;
              <LI>представить отчет по работе.</LI></UL>
            <DIV id=mark_87 class=lecture_mark></DIV>
            <P id=id_96><B>Требования к отчету.</B></P>
            <DIV id=mark_96 class=lecture_mark></DIV>
            <P id=id_97>Отчет по лабораторной работе должен соответствовать 
            следующей структуре.</P>
            <DIV id=mark_97 class=lecture_mark></DIV>
            <UL id=id_98>
              <LI>Титульный лист.
              <LI>Словесная постановка задачи. В этом подразделе проводится 
              полное описание задачи. Описывается суть задачи, анализ входящих в 
              нее физических величин, область их допустимых значений, единицы их 
              измерения, возможные ограничения, анализ условий при которых 
              задача имеет решение (не имеет решения), анализ ожидаемых 
              результатов.
              <LI>Математическая модель. В этом подразделе вводятся 
              математические описания физических величин и математическое 
              описание их взаимодействий. Цель подраздела – представить решаемую 
              задачу в математической формулировке.
              <LI>Алгоритм решения задачи. В подразделе описывается разработка 
              структуры алгоритма, обосновывается абстракция данных, задача 
              разбивается на подзадачи. Схема алгоритма выполняется по ЕСПД 
              (ГОСТ 19.003-80 и ГОСТ 19.002-80).
              <LI>Листинг программы. Подраздел должен содержать текст программы 
              на языке программирования С++, реализованный в среде MS Visual 
              Studio 2010.
              <LI>Контрольный тест. Подраздел содержит наборы исходных данных и 
              полученные в ходе выполнения программы результаты.
              <LI>Выводы по лабораторной работе. 
              <LI>Ответы на контрольные вопросы.</LI></UL>
            <DIV id=mark_98 class=lecture_mark></DIV>
            <P id=id_107>Контрольные вопросы</P>
            <DIV id=mark_107 class=lecture_mark></DIV>
            <OL id=id_108>
              <LI>Почему передача данных при файловом вводе-выводе 
              осуществляется побайтно?
              <LI>Почему при обмене данными через потоки файлы отождествляются с 
              внешними устройствами?
              <LI>Возможно ли расположить указатель в файле перед началом файла? 
              Обоснуйте ответ.
              <LI>Возможно ли расположить указатель в файле после символа конца 
              файла? Обоснуйте ответ.
              <LI>По какой причине для потоков, открытых в режиме преобразования 
              типов, применение <SPAN class=texample>fseek</SPAN> является 
              ограниченным?
              <LI>Как изменится файл, если произвести запись данных в середину 
              файла при буферизированном вводе-выводе?
              <LI>В чем преимущества и недостатки каждого из способов 
              организации рабочей памяти (в виде массива или другого файла) при 
              редактировании файла?</LI></OL>
            <DIV id=mark_108 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript 
src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/urchin.js">
</SCRIPT>

<SCRIPT 
type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
