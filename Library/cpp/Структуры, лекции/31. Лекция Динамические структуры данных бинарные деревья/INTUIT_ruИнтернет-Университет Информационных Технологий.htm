<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0071)http://www.intuit.ru/department/algorithms/staldata/31/staldata_31.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/printable.css">
<META name=GENERATOR content="MSHTML 9.00.8080.16413"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="COLOR: #000000; FONT-WEIGHT: bold">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD>
    <TD><!-- content -->
      <TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD class=head>Структуры и алгоритмы компьютерной обработки 
        данных</TD></TR>
        <TR>
          <TD height=4><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>31. Лекция: Динамические структуры данных: 
            бинарные деревья: версия для печати и PDA</SPAN> <BR><SPAN 
            class=rtxt>В лекции рассматриваются определения, свойства и виды 
            деревьев, элементы, характеристики и способы объявления деревьев в 
            программах, основные операции над элементами деревьев, понятие и 
            виды обходов деревьев, приводятся примеры реализации основных 
            операций над бинарными деревьями в виде рекурсивных функций. 
          </SPAN></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3></H3>
            <P id=id_1><B>Цель лекции:</B> изучить понятие, формирование, 
            особенности доступа к данным и работы с памятью в бинарных деревьях, 
            научиться решать задачи с использованием рекурсивных функций и 
            алгоритмов обхода бинарных деревьев в языке C++.</P>
            <DIV id=mark_1 class=lecture_mark></DIV>
            <P id=id_2>Дерево является одним из важнейших и интересных частных 
            случаев графа. Древовидная модель оказывается довольно эффективной 
            для представления динамических данных с целью быстрого поиска 
            информации.</P>
            <DIV id=mark_2 class=lecture_mark></DIV>
            <P id=id_3>Деревья являются одними из наиболее широко 
            распространенных структур данных в информатике и программировании, 
            которые представляют собой иерархические структуры в виде набора 
            связанных узлов. </P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <P id=id_4><B>Дерево</B> – это структура данных, представляющая 
            собой совокупность элементов и отношений, образующих иерархическую 
            структуру этих элементов (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/31/staldata_31.html#image.31.1">рис. 
            31.1</A>). Каждый элемент дерева называется <SPAN 
            class=xml_em_italic>вершиной (узлом) дерева</SPAN>. Вершины дерева 
            соединены направленными дугами, которые называют <SPAN 
            class=xml_em_italic>ветвями дерева</SPAN>. Начальный узел дерева 
            называют <SPAN class=xml_em_italic>корнем дерева</SPAN>, ему 
            соответствует нулевой уровень. <SPAN class=xml_em_italic>Листьями 
            дерева</SPAN> называют вершины, в которые входит одна ветвь и не 
            выходит ни одной ветви.</P>
            <DIV id=mark_4 class=lecture_mark></DIV>
            <P id=id_5>Каждое дерево обладает следующими свойствами:</P>
            <DIV id=mark_5 class=lecture_mark></DIV>
            <OL id=id_6>
              <LI>существует узел, в который не входит ни одной дуги (корень);
              <LI>в каждую вершину, кроме корня, входит одна дуга.</LI></OL>
            <DIV id=mark_6 class=lecture_mark></DIV>
            <P id=id_9>Деревья особенно часто используют на практике при 
            изображении различных иерархий. Например, популярны генеалогические 
            деревья.</P>
            <DIV id=mark_9 class=lecture_mark></DIV>
            <P id=id_10 align=left><A name=image.31.1></A>
            <DIV><IMG alt=Дерево 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/31_01.png" 
            width=474 height=227></DIV><BR><B>Рис. 31.1.</B>&nbsp; Дерево
            <P></P>
            <DIV id=mark_10 class=lecture_mark></DIV>
            <P id=id_11>Все вершины, в которые входят ветви, исходящие из одной 
            общей вершины, называются <SPAN 
            class=xml_em_italic>потомками</SPAN>, а сама вершина – <SPAN 
            class=xml_em_italic>предком</SPAN>. Для каждого предка может быть 
            выделено несколько. <SPAN class=xml_em_italic>Уровень</SPAN> потомка 
            на единицу превосходит уровень его предка. Корень дерева не имеет 
            предка, а листья дерева не имеют потомков.</P>
            <DIV id=mark_11 class=lecture_mark></DIV>
            <P id=id_12><SPAN class=xml_em_italic>Высота (глубина)</SPAN> дерева 
            определяется количеством уровней, на которых располагаются его 
            вершины. Высота пустого дерева рана нулю, высота дерева из одного 
            корня – единице. На первом уровне дерева может быть только одна 
            вершина – корень дерева, на втором – потомки корня дерева, на 
            третьем – потомки потомков корня дерева и т.д.</P>
            <DIV id=mark_12 class=lecture_mark></DIV>
            <P id=id_13><B>Поддерево</B> – часть древообразной структуры данных, 
            которая может быть представлена в виде отдельного дерева.</P>
            <DIV id=mark_13 class=lecture_mark></DIV>
            <P id=id_14><SPAN class=xml_em_italic>Степенью вершины</SPAN> в 
            дереве называется количество дуг, которое из нее выходит. <SPAN 
            class=xml_em_italic>Степень дерева</SPAN> равна максимальной степени 
            вершины, входящей в дерево. При этом листьями в дереве являются 
            вершины, имеющие степень нуль. По величине степени дерева различают 
            два типа деревьев:</P>
            <DIV id=mark_14 class=lecture_mark></DIV>
            <UL id=id_15>
              <LI>двоичные – степень дерева не более двух;
              <LI>сильноветвящиеся – степень дерева произвольная.</LI></UL>
            <DIV id=mark_15 class=lecture_mark></DIV>
            <P id=id_18><B>Упорядоченное дерево</B> – это дерево, у которого 
            ветви, исходящие из каждой вершины, упорядочены по определенному 
            критерию.</P>
            <DIV id=mark_18 class=lecture_mark></DIV>
            <P id=id_19>Деревья являются рекурсивными структурами, так как 
            каждое поддерево также является деревом. Таким образом, дерево можно 
            определить как рекурсивную структуру, в которой каждый элемент 
            является:</P>
            <DIV id=mark_19 class=lecture_mark></DIV>
            <UL id=id_20>
              <LI>либо пустой структурой;
              <LI>либо элементом, с которым связано конечное число 
              поддеревьев.</LI></UL>
            <DIV id=mark_20 class=lecture_mark></DIV>
            <P id=id_23>Действия с рекурсивными структурами удобнее всего 
            описываются с помощью рекурсивных алгоритмов.</P>
            <DIV id=mark_23 class=lecture_mark></DIV>
            <P id=id_24>Списочное представление деревьев основано на элементах, 
            соответствующих вершинам дерева. Каждый элемент имеет поле данных и 
            два поля указателей: указатель на начало списка потомков вершины и 
            указатель на следующий элемент в списке потомков текущего уровня. 
            При таком способе представления дерева обязательно следует сохранять 
            указатель на вершину, являющуюся корнем дерева.</P>
            <DIV id=mark_24 class=lecture_mark></DIV>
            <P id=id_25>Для того, чтобы выполнить определенную операцию над 
            всеми вершинами дерева необходимо все его вершины просмотреть. Такая 
            задача называется <SPAN class=xml_em_italic>обходом 
            дерева</SPAN>.</P>
            <DIV id=mark_25 class=lecture_mark></DIV>
            <P id=id_26><B>Обход дерева</B> – это упорядоченная 
            последовательность вершин дерева, в которой каждая вершина 
            встречается только один раз.</P>
            <DIV id=mark_26 class=lecture_mark></DIV>
            <P id=id_27>При обходе все вершины дерева должны посещаться в 
            определенном порядке. Существует несколько способов обхода всех 
            вершин дерева. Выделим три наиболее часто используемых способа 
            обхода дерева (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/31/staldata_31.html#image.31.2">рис. 
            31.2</A>):</P>
            <DIV id=mark_27 class=lecture_mark></DIV>
            <UL id=id_28>
              <LI>прямой;
              <LI>симметричный;
              <LI>обратный.</LI></UL>
            <DIV id=mark_28 class=lecture_mark></DIV>
            <P id=id_32 align=left><A name=image.31.2></A>
            <DIV><IMG alt="Обходы деревьев" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/31_02.png" 
            width=625 height=214></DIV><BR><B>Рис. 31.2.</B>&nbsp; Обходы 
            деревьев
            <P></P>
            <DIV id=mark_32 class=lecture_mark></DIV>
            <P id=id_33>Существует большое многообразие древовидных структур 
            данных. Выделим самые распространенные из них: бинарные (двоичные) 
            деревья, красно-черные деревья, В-деревья, АВЛ-деревья, матричные 
            деревья, смешанные деревья и т.д.</P>
            <DIV id=mark_33 class=lecture_mark></DIV><A name=sect2></A>
            <H3>Бинарные деревья</H3>
            <P id=id_34>Бинарные деревья являются деревьями со степенью не более 
            двух.</P>
            <DIV id=mark_34 class=lecture_mark></DIV>
            <P id=id_35><B>Бинарное (двоичное) дерево</B> – это динамическая 
            структура данных, представляющее собой дерево, в котором каждая 
            вершина имеет не более двух потомков (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/31/staldata_31.html#image.31.3">рис. 
            31.3</A>). Таким образом, бинарное дерево состоит из элементов, 
            каждый из которых содержит информационное поле и <SPAN 
            class=xml_em_italic>не более двух</SPAN> ссылок на различные 
            бинарные поддеревья. На каждый элемент дерева имеется ровно одна 
            ссылка. </P>
            <DIV id=mark_35 class=lecture_mark></DIV>
            <P id=id_36 align=left><A name=image.31.3></A>
            <DIV><IMG alt="Бинарное дерево и его организация" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/31_03.png" 
            width=566 height=255></DIV><BR><B>Рис. 31.3.</B>&nbsp; Бинарное 
            дерево и его организация
            <P></P>
            <DIV id=mark_36 class=lecture_mark></DIV>
            <P id=id_37>Каждая вершина бинарного дерева является структурой, 
            состоящей из четырех видов полей. Содержимым этих полей будут 
            соответственно:</P>
            <DIV id=mark_37 class=lecture_mark></DIV>
            <UL id=id_38>
              <LI>информационное поле (ключ вершины);
              <LI>служебное поле (их может быть несколько или ни одного);
              <LI>указатель на левое поддерево;
              <LI>указатель на правое поддерево. </LI></UL>
            <DIV id=mark_38 class=lecture_mark></DIV>
            <P id=id_43>По степени вершин бинарные деревья делятся на (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/31/staldata_31.html#image.31.4">рис. 
            31.4</A>):</P>
            <DIV id=mark_43 class=lecture_mark></DIV>
            <P id=id_44 align=left><A name=image.31.4></A>
            <DIV><IMG alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/31_04.png" 
            width=624 height=167></DIV><BR><B>Рис. 31.4.</B>&nbsp; 
            <P></P>
            <DIV id=mark_44 class=lecture_mark></DIV>
            <UL id=id_45>
              <LI><SPAN class=xml_em_italic>строгие</SPAN> – вершины дерева 
              имеют степень ноль (у листьев) или два (у узлов);
              <LI><SPAN class=xml_em_italic>нестрогие</SPAN> – вершины дерева 
              имеют степень ноль (у листьев), один или два (у узлов).</LI></UL>
            <DIV id=mark_45 class=lecture_mark></DIV>
            <P id=id_48>В общем случае у бинарного дерева на <SPAN 
            class=texample>k</SPAN>-м уровне может быть до 2<SUP>k-1</SUP> 
            вершин. Бинарное дерево называется <SPAN 
            class=xml_em_italic>полным</SPAN>, если оно содержит только 
            полностью заполненные уровни. В противном случае оно является <SPAN 
            class=xml_em_italic>неполным</SPAN>.</P>
            <DIV id=mark_48 class=lecture_mark></DIV>
            <P id=id_50>Дерево называется <SPAN 
            class=xml_em_italic>сбалансированным</SPAN>, если длины всех путей 
            от корня к внешним вершинам равны между собой. Дерево называется 
            <SPAN class=xml_em_italic>почти сбалансированным</SPAN>, если длины 
            всевозможных путей от корня к внешним вершинам отличаются не более, 
            чем на единицу.</P>
            <DIV id=mark_50 class=lecture_mark></DIV>
            <P id=id_51>Бинарное дерево может представлять собой пустое 
            множество. Бинарное дерево может выродиться в список (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/31/staldata_31.html#image.31.5">рис. 
            31.5</A>).</P>
            <DIV id=mark_51 class=lecture_mark></DIV>
            <P id=id_52 align=left><A name=image.31.5></A>
            <DIV><IMG alt="Список как частный случай бинарного дерева" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/31_05.png" 
            width=255 height=114></DIV><BR><B>Рис. 31.5.</B>&nbsp; Список как 
            частный случай бинарного дерева
            <P></P>
            <DIV id=mark_52 class=lecture_mark></DIV>
            <P id=id_53>Структура дерева отражается во входном потоке данных 
            так: каждой вводимой пустой связи соответствует условный символ, 
            например, <SPAN class=texample>'*'</SPAN> (звездочка). При этом 
            сначала описываются левые потомки, затем, правые. Для структуры 
            бинарного дерева, представленного на следующем <A 
            href="http://www.intuit.ru/department/algorithms/staldata/31/staldata_31.html#image.31.6">рисунке 
            6</A>, входной поток имеет вид: <SPAN 
            class=texample>ABD*G***CE**FH**J**</SPAN>.</P>
            <DIV id=mark_53 class=lecture_mark></DIV>
            <P id=id_56 align=left><A name=image.31.6></A>
            <DIV><IMG alt="Адресация в бинарном дереве" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/31_06.png" 
            width=440 height=278></DIV><BR><B>Рис. 31.6.</B>&nbsp; Адресация в 
            бинарном дереве
            <P></P>
            <DIV id=mark_56 class=lecture_mark></DIV>
            <P id=id_57>Бинарные деревья могут применяться для поиска данных в 
            специально построенных деревьях (базы данных), сортировки данных, 
            вычислений арифметических выражений, кодирования (метод Хаффмана) и 
            т.д.</P>
            <DIV id=mark_57 class=lecture_mark></DIV>
            <P id=id_58>Описание бинарного дерева выглядит следующим 
образом:</P>
            <DIV id=mark_58 class=lecture_mark></DIV>
            <DIV class=example><PRE>struct имя_типа {
                 информационное поле;
                 [служебное поле;]
                 адрес левого поддерева;
                 адрес правого поддерева;
                };
</PRE></DIV>
            <P id=id_60>где <SPAN class=texample>информационное поле</SPAN> – 
            это поле любого ранее объявленного или стандартного типа;</P>
            <DIV id=mark_60 class=lecture_mark></DIV>
            <P id=id_62><SPAN class=texample>адрес левого (правого) 
            поддерева</SPAN> – это указатель на объект того же типа, что и 
            определяемая структура, в него записывается адрес следующего 
            элемента левого (правого) поддерева.</P>
            <DIV id=mark_62 class=lecture_mark></DIV>
            <P id=id_64>Например:</P>
            <DIV id=mark_64 class=lecture_mark></DIV>
            <DIV class=example><PRE>struct point {
              int data;//информационное поле
              int count; //служебное поле
              point *left;//адрес левого поддерева
              point *right;//адрес правого поддерева
             };
</PRE></DIV>
            <P id=id_66>Основными операциями, осуществляемыми с бинарными 
            деревьями, являются:</P>
            <DIV id=mark_66 class=lecture_mark></DIV>
            <UL id=id_67>
              <LI>создание бинарного дерева;
              <LI>печать бинарного дерева;
              <LI>обход бинарного дерева;
              <LI>вставка элемента в бинарное дерево;
              <LI>удаление элемента из бинарного дерева;
              <LI>проверка пустоты бинарного дерева;
              <LI>удаление бинарного дерева. </LI></UL>
            <DIV id=mark_67 class=lecture_mark></DIV>
            <P id=id_75>Для описания алгоритмов этих основных операций 
            используется следующее объявление:</P>
            <DIV id=mark_75 class=lecture_mark></DIV>
            <DIV class=example><PRE>struct BinaryTree{
       int Data; //поле данных
       BinaryTree* Left; //указатель на левый потомок
       BinaryTree* Right; /указатель на правый потомок
};
. . . . . . . . . . 
BinaryTree* BTree = NULL;
</PRE></DIV>
            <P id=id_77>Приведем функции перечисленных основных операций при 
            работе с бинарным деревом.</P>
            <DIV id=mark_77 class=lecture_mark></DIV><A></A>
            <DIV class=example><PRE>//создание бинарного дерева
void Make_Binary_Tree(BinaryTree** Node, int n){
  BinaryTree** ptr;//вспомогательный указатель
  srand(time(NULL)*1000);
  while (n &gt; 0) {
    ptr = Node;
    while (*ptr != NULL) {
      if ((double) rand()/RAND_MAX &lt; 0.5) 
        ptr = &amp;((*ptr)-&gt;Left);
      else ptr = &amp;((*ptr)-&gt;Right);
    }
    (*ptr) = new BinaryTree();
    cout &lt;&lt; "Введите значение ";
    cin &gt;&gt; (*ptr)-&gt;Data;
    n--;
  }
}

//печать бинарного дерева
void Print_BinaryTree(BinaryTree* Node, int l){
  int i;
  if (Node != NULL) {
    Print_BinaryTree(Node-&gt;Right, l+1);
    for (i=0; i&lt; l; i++) cout &lt;&lt; "    ";
    printf ("%4ld", Node-&gt;Data);
    Print_BinaryTree(Node-&gt;Left, l+1);
  }
  else cout &lt;&lt; endl;
}

//прямой обход бинарного дерева
void PreOrder_BinaryTree(BinaryTree* Node){
  if (Node != NULL) {
    printf ("%3ld",Node-&gt;Data);
    PreOrder_BinaryTree(Node-&gt;Left);
    PreOrder_BinaryTree(Node-&gt;Right);
  }
}

//обратный обход бинарного дерева
void PostOrder_BinaryTree(BinaryTree* Node){
  if (Node != NULL) {
    PostOrder_BinaryTree(Node-&gt;Left);
    PostOrder_BinaryTree(Node-&gt;Right);
    printf ("%3ld",Node-&gt;Data);
  }
}

//симметричный обход бинарного дерева
void SymmetricOrder_BinaryTree(BinaryTree* Node){
  if (Node != NULL) {
    PostOrder_BinaryTree(Node-&gt;Left);
    printf ("%3ld",Node-&gt;Data);
    PostOrder_BinaryTree(Node-&gt;Right);
  }
}

//вставка вершины в бинарное дерево
void Insert_Node_BinaryTree(BinaryTree** Node,int Data) {
  BinaryTree* New_Node = new BinaryTree;
  New_Node-&gt;Data = Data;
  New_Node-&gt;Left = NULL;
  New_Node-&gt;Right = NULL;
  BinaryTree** ptr = Node;//вспомогательный указатель
  srand(time(NULL)*1000);
  while (*ptr != NULL) {
    double q = (double) rand()/RAND_MAX;
    if ( q &lt; 1/3.0) ptr = &amp;((*ptr)-&gt;Left);
    else if ( q &gt; 2/3.0) ptr = &amp;((*ptr)-&gt;Right);
    else break;
  }
  if (*ptr != NULL) {
    if ( (double) rand()/RAND_MAX &lt; 0.5 ) 
      New_Node-&gt;Left = *ptr;
    else New_Node-&gt;Right = *ptr;
    *ptr = New_Node;
  }
  else{
    *ptr = New_Node;
  }
}

//удаление вершины из бинарного дерева
void Delete_Node_BinaryTree(BinaryTree** Node,int Data){
  if ( (*Node) != NULL ){
    if ((*Node)-&gt;Data == Data){
      BinaryTree* ptr = (*Node);
      if ( (*Node)-&gt;Left == NULL &amp;&amp; (*Node)-&gt;Right == NULL ) (*Node) = NULL;
      else if ((*Node)-&gt;Left == NULL) (*Node) = ptr-&gt;Right;
      else if ((*Node)-&gt;Right == NULL) (*Node) = ptr-&gt;Left;
      else {
        (*Node) = ptr-&gt;Right;
        BinaryTree ** ptr1;
        ptr1 = Node;
        while (*ptr1 != NULL) 
          ptr1 = &amp;((*ptr1)-&gt;Left);
        (*ptr1) = ptr-&gt;Left;
      }
      delete(ptr);
      Delete_Node_BinaryTree(Node,Data);
    }
    else {
      Delete_Node_BinaryTree(&amp;((*Node)-&gt;Left),Data);
      Delete_Node_BinaryTree(&amp;((*Node)-&gt;Right),Data);
    }
  }
}

//проверка пустоты бинарного дерева
bool Empty_BinaryTree(BinaryTree* Node){
  return ( Node == NULL ? true : false );
}

//освобождение памяти, выделенной под бинарное дерево
void Delete_BinaryTree(BinaryTree* Node){
  if (Node != NULL) {
    Delete_BinaryTree(Node-&gt;Left);
    Delete_BinaryTree(Node-&gt;Right);
    delete(Node);
  }
}
</PRE><SPAN class=objectName>Листинг . </SPAN></DIV><A 
            name=sect3></A>
            <H3>Ключевые термины</H3>
            <P id=id_79><B>Бинарное (двоичное) дерево</B> – это дерево, в 
            котором каждая вершина имеет не более двух потомков.</P>
            <DIV id=mark_79 class=lecture_mark></DIV>
            <P id=id_80><B>Вершина (узел) дерева</B> – это каждый элемент 
            дерева.</P>
            <DIV id=mark_80 class=lecture_mark></DIV>
            <P id=id_81><B>Ветви дерева</B> – это направленные дуги, которыми 
            соединены вершины дерева.</P>
            <DIV id=mark_81 class=lecture_mark></DIV>
            <P id=id_82><B>Высота (глубина) дерева</B> – это количество уровней, 
            на которых располагаются его вершины.</P>
            <DIV id=mark_82 class=lecture_mark></DIV>
            <P id=id_83><B>Дерево</B> – это структура данных, представляющая 
            собой совокупность элементов и отношений, образующих иерархическую 
            структуру этих элементов. </P>
            <DIV id=mark_83 class=lecture_mark></DIV>
            <P id=id_84><B>Корень дерева</B> – это начальный узел дерева, ему 
            соответствует нулевой уровень. </P>
            <DIV id=mark_84 class=lecture_mark></DIV>
            <P id=id_85><B>Листья дерева</B> – это вершины, в которые входит 
            одна ветвь и не выходит ни одной ветви.</P>
            <DIV id=mark_85 class=lecture_mark></DIV>
            <P id=id_86><B>Неполное бинарное дерево</B> – это дерево, уровни 
            которого заполнены не полностью. </P>
            <DIV id=mark_86 class=lecture_mark></DIV>
            <P id=id_87><B>Нестрогое бинарное дерево</B> – это дерево, у 
            которого вершины имеют степень ноль (у листьев), один или два (у 
            узлов).</P>
            <DIV id=mark_87 class=lecture_mark></DIV>
            <P id=id_88><B>Обход дерева</B> – это упорядоченная 
            последовательность вершин дерева, в которой каждая вершина 
            встречается только один раз.</P>
            <DIV id=mark_88 class=lecture_mark></DIV>
            <P id=id_89><B>Поддерево</B> – это часть древообразной структуры 
            данных, которая может быть представлено в виде отдельного 
дерева.</P>
            <DIV id=mark_89 class=lecture_mark></DIV>
            <P id=id_90><B>Полное бинарное дерево</B> – это дерево, которое 
            содержит только полностью заполненные уровни. </P>
            <DIV id=mark_90 class=lecture_mark></DIV>
            <P id=id_91><B>Потомки</B> – это все вершины, в которые входят 
            ветви, исходящие из одной общей вершины.</P>
            <DIV id=mark_91 class=lecture_mark></DIV>
            <P id=id_92><B>Почти сбалансированное дерево</B> – это дерево, у 
            которого длины всевозможных путей от корня к внешним вершинам 
            отличаются не более, чем на единицу.</P>
            <DIV id=mark_92 class=lecture_mark></DIV>
            <P id=id_93><B>Предок</B> – это вершина, из которой исходят ветви к 
            вершинам следующего уровня.</P>
            <DIV id=mark_93 class=lecture_mark></DIV>
            <P id=id_94><B>Сбалансированное дерево</B> – это дерево, у которого 
            длины всех путей от корня к внешним вершинам равны между собой. </P>
            <DIV id=mark_94 class=lecture_mark></DIV>
            <P id=id_95><B>Степень вершины</B> – это количество дуг, которое 
            выходит из этой вершины. </P>
            <DIV id=mark_95 class=lecture_mark></DIV>
            <P id=id_96><B>Степень дерева</B> – это максимальная степень вершин, 
            входящих в дерево.</P>
            <DIV id=mark_96 class=lecture_mark></DIV>
            <P id=id_97><B>Строгое бинарное дерево</B> – это дерево, у которого 
            вершины имеют степень ноль (у листьев) или два (у узлов).</P>
            <DIV id=mark_97 class=lecture_mark></DIV>
            <P id=id_98><B>Упорядоченное дерево</B> – это дерево, у которого 
            ветви, исходящие из каждой вершины, упорядочены по определенному 
            критерию.</P>
            <DIV id=mark_98 class=lecture_mark></DIV>
            <P id=id_99><B>Уровень вершины</B> – это количество дуг от корня 
            дерева до вершины.</P>
            <DIV id=mark_99 class=lecture_mark></DIV><A name=sect4></A>
            <H3>Краткие итоги</H3>
            <OL id=id_100>
              <LI>Деревья являются одними из наиболее широко распространенных 
              структур данных в программировании, которые представляют собой 
              иерархические структуры в виде набора связанных узлов.
              <LI>Каждое дерево обладает следующими свойствами: существует узел, 
              в который не входит ни одной дуги (корень); в каждую вершину, 
              кроме корня, входит одна дуга.
              <LI>С понятием дерева связаны такие понятия, как корень, ветвь, 
              вершина, лист, предок, потомок, степень вершины и дерева, высота 
              дерева.
              <LI>Списочное представление деревьев основано на элементах, 
              соответствующих вершинам дерева.
              <LI>Дерево можно упорядочить по указанному ключу.
              <LI>Просмотреть с целью поиска все вершины дерева можно с помощью 
              различных способов обхода дерева. 
              <LI>Наиболее часто используемыми обходами являются прямой, 
              симметричный, обратный.
              <LI>В программировании при решении большого класса задач 
              используются бинарные деревья.
              <LI>Бинарные деревья по степени вершин делятся на строгие и 
              нестрогие, по характеру заполнения узлов – на полные и неполные, 
              по удалению вершин от корня – на сбалансированные и почти 
              сбалансированные.
              <LI>Основными операциями с бинарными деревьями являются: создание 
              бинарного дерева; печать бинарного дерева; обход бинарного дерева; 
              вставка элемента в бинарное дерево; удаление элемента из бинарного 
              дерева; проверка пустоты бинарного дерева; удаление бинарного 
              дерева.
              <LI>Бинарные деревья могут применяться для поиска данных в 
              специально построенных деревьях (базы данных), сортировки данных, 
              вычислений арифметических выражений, кодирования.</LI></OL>
            <DIV id=mark_100 class=lecture_mark></DIV><A name=sect5></A>
            <H3>Лабораторная работа 31. Динамические структуры данных: бинарные 
            деревья</H3>
            <P id=id_112><B>Цель работы:</B> изучить понятие, формирование, 
            особенности доступа к данным и работы с памятью в бинарных деревьях, 
            научиться решать задачи с использованием рекурсивных функций и 
            алгоритмов обхода бинарных деревьев в языке C++.</P>
            <DIV id=mark_112 class=lecture_mark></DIV>
            <P id=id_113>При выполнении лабораторной работы для каждого задания 
            требуется написать программу на языке С++, в которой выполнено 
            формирование бинарных деревьев в соответствии с постановкой задачи, 
            ввод данных элементов деревьев с учетом типа информационного поля, 
            их обработка и вывод на экран в указанном формате. Для хранения 
            данных бинарных деревьев следует использовать ресурсы динамической 
            памяти. Ввод данных осуществляется с клавиатуры с учетом требований 
            к входным данным, содержащихся в постановке задачи. Ограничениями на 
            входные данные являются максимальный размер строковых данных, 
            диапазоны числовых типов полей структуры и допустимый размер области 
            динамической памяти в языке С++.</P>
            <DIV id=mark_113 class=lecture_mark></DIV>
            <P id=id_114><B>Теоретические сведения.</B></P>
            <DIV id=mark_114 class=lecture_mark></DIV>
            <P id=id_115>Ознакомьтесь с материалом лекции 31.</P>
            <DIV id=mark_115 class=lecture_mark></DIV>
            <P id=id_116><B>Задания к лабораторной работе.</B></P>
            <DIV id=mark_116 class=lecture_mark></DIV>
            <P id=id_117>Выполните приведенные ниже задания.</P>
            <DIV id=mark_117 class=lecture_mark></DIV>
            <OL id=id_118>
              <LI>На основании приведенных в лекции 31 функций реализуйте 
              программу, в которой выполняются все основные операции с бинарным 
              деревом.
              <LI>Найдите количество четных элементов бинарного дерева. Укажите 
              эти элементы и их уровни.
              <LI>Найдите сумму элементов сбалансированного дерева, находящихся 
              на уровне <SPAN class=texample>k</SPAN>.
              <LI>Оператор мобильной связи организовал базу данных абонентов, 
              содержащую сведения о телефонах, их владельцах и используемых 
              тарифах, в виде бинарного дерева. Составьте программу, которая: 
              <UL id=id_124>
                <LI>обеспечивает начальное формирование базы данных в виде 
                бинарного дерева;
                <LI>производит вывод всей базы данных;
                <LI>производит поиск владельца по номеру телефона;
                <LI>выводит наиболее востребованный тариф (по наибольшему числу 
                абонентов).</LI></UL>
              <DIV id=mark_124 class=lecture_mark></DIV></LI></OL>
            <DIV id=mark_118 class=lecture_mark></DIV>
            <P id=id_129><B>Указания к выполнению работы.</B></P>
            <DIV id=mark_129 class=lecture_mark></DIV>
            <P id=id_130>Выполнение работы следует начать с решения задачи 1, 
            реализовав алгоритмы основных операций над бинарным деревом. Каждое 
            из заданий 2, 3 и 4 необходимо решить в соответствии с изученными 
            методами и реализованными алгоритмами формирования, вывода и 
            обработки данных бинарных деревьев в языке С++. Обработку бинарных 
            деревьев следует выполнить на основе базовых алгоритмов: поиск по 
            дереву, вставка элемента в дерево, балансировка дерева, удаление 
            элемента из дерева, удаление всего дерева. При объявлении бинарных 
            деревьев выполните комментирование используемых полей. Программу для 
            решения каждого задания необходимо разработать методом процедурной 
            абстракции, оформив комментарии к коду.</P>
            <DIV id=mark_130 class=lecture_mark></DIV>
            <P id=id_131>Следует реализовать каждое задание в соответствии с 
            приведенными этапами:</P>
            <DIV id=mark_131 class=lecture_mark></DIV>
            <UL id=id_132>
              <LI>изучить словесную постановку задачи, выделив при этом все виды 
              данных;
              <LI>сформулировать математическую постановку задачи;
              <LI>выбрать метод решения задачи, если это необходимо;
              <LI>разработать графическую схему алгоритма;
              <LI>записать разработанный алгоритм на языке С++;
              <LI>разработать контрольный тест к программе;
              <LI>отладить программу;
              <LI>представить отчет по работе.</LI></UL>
            <DIV id=mark_132 class=lecture_mark></DIV>
            <P id=id_141><B>Требования к отчету.</B></P>
            <DIV id=mark_141 class=lecture_mark></DIV>
            <P id=id_142>Отчет по лабораторной работе должен соответствовать 
            следующей структуре.</P>
            <DIV id=mark_142 class=lecture_mark></DIV>
            <UL id=id_143>
              <LI>Титульный лист.
              <LI>Словесная постановка задачи. В этом подразделе проводится 
              полное описание задачи. Описывается суть задачи, анализ входящих в 
              нее физических величин, область их допустимых значений, единицы их 
              измерения, возможные ограничения, анализ условий при которых 
              задача имеет решение (не имеет решения), анализ ожидаемых 
              результатов.
              <LI>Математическая модель. В этом подразделе вводятся 
              математические описания физических величин и математическое 
              описание их взаимодействий. Цель подраздела – представить решаемую 
              задачу в математической формулировке.
              <LI>Алгоритм решения задачи. В подразделе описывается разработка 
              структуры алгоритма, обосновывается абстракция данных, задача 
              разбивается на подзадачи. Схема алгоритма выполняется по ЕСПД 
              (ГОСТ 19.003-80 и ГОСТ 19.002-80).
              <LI>Листинг программы. Подраздел должен содержать текст программы 
              на языке программирования С++, реализованный в среде MS Visual 
              Studio 2010.
              <LI>Контрольный тест. Подраздел содержит наборы исходных данных и 
              полученные в ходе выполнения программы результаты.
              <LI>Выводы по лабораторной работе. 
              <LI>Ответы на контрольные вопросы.</LI></UL>
            <DIV id=mark_143 class=lecture_mark></DIV>
            <P id=id_152><B>Контрольные вопросы</B></P>
            <DIV id=mark_152 class=lecture_mark></DIV>
            <OL id=id_153>
              <LI>С чем связана популярность использования деревьев в 
              программировании?
              <LI>Можно ли список отнести к деревьям? Ответ обоснуйте.
              <LI>Какие данные содержат адресные поля элемента бинарного дерева?
              <LI>Может ли бинарное дерево быть строгим и неполным? Ответ 
              обоснуйте.
              <LI>Может ли бинарное дерево быть нестрогим и полным? Ответ 
              обоснуйте.
              <LI>Каким может быть почти сбалансированное бинарное дерево: 
              полным, неполным, строгим, нестрогим? Ответ обоснуйте.
              <LI>Куда может быть добавлен элемент в бинарное дерево в 
              зависимости от его вида (полное, неполное, строгое, нестрогое)? 
              Вид дерева при этом должен сохраниться.
              <LI>Куда может быть добавлен элемент в сбалансированное бинарное 
              дерево? Вид дерева при этом должен сохраниться.
              <LI>Чем отличаются, с точки зрения реализации алгоритма, прямой, 
              симметричный и обратный обходы бинарного дерева?</LI></OL>
            <DIV id=mark_153 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript 
src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/urchin.js">
</SCRIPT>

<SCRIPT 
type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
