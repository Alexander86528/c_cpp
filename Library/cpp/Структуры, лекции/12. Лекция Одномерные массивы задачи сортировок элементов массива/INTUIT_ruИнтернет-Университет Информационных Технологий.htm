<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0071)http://www.intuit.ru/department/algorithms/staldata/12/staldata_12.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/printable.css">
<META name=GENERATOR content="MSHTML 9.00.8080.16413"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="COLOR: #000000; FONT-WEIGHT: bold">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD>
    <TD><!-- content -->
      <TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD class=head>Структуры и алгоритмы компьютерной обработки 
        данных</TD></TR>
        <TR>
          <TD height=4><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>12. Лекция: Одномерные массивы: задачи 
            сортировок элементов массива: версия для печати и PDA</SPAN> 
            <BR><SPAN class=rtxt>В лекции рассматриваются понятие и виды 
            сортировок массивов, критерии оценки трудоемкости выполнения 
            алгоритмов сортировок одномерных массивов, приводятся примеры 
            реализации простых сортировок. </SPAN></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3></H3>
            <P id=id_1><B>Цель лекции:</B> изучить понятия и классификацию 
            алгоритмов сортировок массивов, реализацию алгоритмов простых 
            сортировок и научиться решать задачи на сортировку одномерных 
            массивов с помощью алгоритмов простых сортировок в языке C++.</P>
            <DIV id=mark_1 class=lecture_mark></DIV>
            <P id=id_2>Задача сортировки является такой же базовой, как задача 
            поиска. В практических условиях эти задачи взаимосвязаны. Решению 
            проблем, связанных с сортировкой, посвящено множество 
            фундаментальных научных исследований, разработано множество 
            алгоритмов.</P>
            <DIV id=mark_2 class=lecture_mark></DIV>
            <P id=id_3>В общем случае сортировку следует понимать как процесс 
            перегруппировки заданного множества объектов в определенном порядке. 
            Часто при сортировке больших объемов данных нецелесообразно 
            переставлять сами элементы, поэтому для решения задачи выполняется 
            упорядочивание элементов по индексам. То есть индексы элементов 
            выстраивают в такой последовательности, что соответствующие им 
            значения элементов оказываются отсортированными по условию 
            задачи.</P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <P id=id_4>Сортировка применяется для облегчения поиска элементов в 
            упорядоченном множестве. Задача сортировки одна из фундаментных в 
            программировании.</P>
            <DIV id=mark_4 class=lecture_mark></DIV>
            <P id=id_5><B>Сортировка</B> – это упорядочивание набора однотипных 
            данных по возрастанию или убыванию.</P>
            <DIV id=mark_5 class=lecture_mark></DIV>
            <P id=id_6>Чаще всего при сортировке данных лишь часть их 
            используется в качестве ключа сортировки. <SPAN 
            class=xml_em_italic>Ключ сортировки</SPAN> – это часть данных, 
            определяющая порядок элементов. Таким образом, ключ участвует в 
            сравнениях, но при обмене элементов происходит перемещение всей 
            структуры данных. Например, в списке почтовой рассылки в качестве 
            ключа может использоваться почтовый индекс, но сортируется весь 
            адрес. При решении задач сортировок массивов ключ и данные 
            совпадают.</P>
            <DIV id=mark_6 class=lecture_mark></DIV>
            <P id=id_7>Для того, чтобы отсортировать данные, можно вызывать 
            стандартную функцию <SPAN class=texample>qsort()</SPAN>, входящую в 
            библиотеку С++. Однако различные подходы к сортировке обладают 
            разными характеристиками. Несмотря на то, что некоторые способы 
            сортировки могут быть в среднем лучше, чем другие, ни один алгоритм 
            не является идеальным для всех случаев. </P>
            <DIV id=mark_7 class=lecture_mark></DIV>
            <P id=id_9>Использование функции <SPAN class=texample>qsort()</SPAN> 
            не является универсальным решением для всех задач сортировки. 
            Во-первых, функцию общего назначения, такую как <SPAN 
            class=texample>qsort()</SPAN>, невозможно применить во всех 
            ситуациях. Например, данная функция сортирует только массивы в 
            памяти и не может сортировать данные, хранящиеся в связанных 
            списках. Во-вторых, <SPAN class=texample>qsort()</SPAN> – 
            параметризованная функция, благодаря чему она может обрабатывать 
            широкий набор типов данных, но вследствие этого она работает 
            медленнее, чем эквивалентная функция, рассчитанная на какой-то один 
            тип данных. В-третьих, алгоритм быстрой сортировки, примененный в 
            функции <SPAN class=texample>qsort()</SPAN>, может оказаться не 
            самым эффективным алгоритмом в некоторых конкретных ситуациях.</P>
            <DIV id=mark_9 class=lecture_mark></DIV><A name=sect2></A>
            <H3>Оценка алгоритмов сортировки</H3>
            <P id=id_14>Существует множество различных алгоритмов сортировки. 
            Все они имеют свои положительные и отрицательные стороны. Перечислим 
            общие критерии оценки алгоритмов сортировки.</P>
            <DIV id=mark_14 class=lecture_mark></DIV>
            <UL id=id_15>
              <LI><SPAN class=xml_em_italic>Скорость работы алгоритма 
              сортировки</SPAN>. Она непосредственно связана с количеством 
              сравнений и количеством обменов, происходящих во время сортировки, 
              причем обмены занимают больше времени. Сравнение происходит тогда, 
              когда один элемент массива сравнивается с другим; обмен происходит 
              тогда, когда два элемента меняются местами. Время работы одних 
              алгоритмов сортировки растет экспоненциально, а время работы 
              других логарифмически зависит от количества элементов.
              <LI><SPAN class=xml_em_italic>Время работы в лучшем и худшем 
              случаях</SPAN>. Оно имеет значение при анализе выполнения 
              алгоритма, если одна из краевых ситуаций будет встречаться 
              довольно часто. Алгоритм сортировки зачастую имеет хорошее среднее 
              время выполнения, но в худшем случае он работает очень медленно.
              <LI><SPAN class=xml_em_italic>Поведение алгоритма 
              сортировки</SPAN>. Поведение алгоритма сортировки называется <SPAN 
              class=xml_em_italic>естественным</SPAN>, если время сортировки 
              минимально для уже упорядоченного списка элементов, увеличивается 
              по мере возрастания степени неупорядоченности списка и 
              максимально, когда элементы списка расположены в обратном порядке. 
              Объем работы алгоритма оценивается количеством производимых 
              сравнений и обменов.</LI></UL>
            <DIV id=mark_15 class=lecture_mark></DIV>
            <P id=id_19>Различные сортировки массивов отличаются по 
            быстродействию. Существуют простые методы сортировок, которые 
            требуют порядка <SPAN class=texample>n*n</SPAN> сравнений, где <SPAN 
            class=texample>n</SPAN> – количество элементов массива и быстрые 
            сортировки, которые требуют порядка <SPAN 
            class=texample>n*ln(n)</SPAN> сравнений. Простые методы удобны для 
            объяснения принципов сортировок, т.к. имеют простые и короткие 
            алгоритмы. Усложненные методы требуют меньшего числа операций, но 
            сами операции более сложные, поэтому для небольших массивов простые 
            методы более эффективны.</P>
            <DIV id=mark_19 class=lecture_mark></DIV>
            <P id=id_23>Простые методы сортировки можно разделить на три 
            основные категории:</P>
            <DIV id=mark_23 class=lecture_mark></DIV>
            <UL id=id_24>
              <LI>сортировка методом "пузырька" (простого обмена);
              <LI>сортировка методом простого выбора (простой перебор);
              <LI>сортировка методом простого включения (сдвиг-вставка, 
              вставками, вставка и сдвиг).</LI></UL>
            <DIV id=mark_24 class=lecture_mark></DIV><A name=sect3></A>
            <H3>Сортировка методом "пузырька" (простого обмена)</H3>
            <P id=id_28>Самый известный алгоритм – <SPAN 
            class=xml_em_italic>пузырьковая сортировка</SPAN> (bubble sort, 
            сортировка методом пузырька или просто сортировка пузырьком). Его 
            популярность объясняется интересным названием и простотой самого 
            алгоритма. </P>
            <DIV id=mark_28 class=lecture_mark></DIV>
            <P id=id_29>Алгоритм попарного сравнения элементов массива в 
            литературе часто называют "методом пузырька", проводя аналогию с 
            пузырьком, поднимающимся со дна бокала с газированной водой. По мере 
            всплывания пузырек сталкивается с другими пузырьками и, сливаясь с 
            ними, увеличивается в объеме. Чтобы аналогия стала очевидной, нужно 
            считать, что элементы массива расположены вертикально друг над 
            другом, и их нужно так упорядочить, чтобы они увеличивались сверху 
            вниз.</P>
            <DIV id=mark_29 class=lecture_mark></DIV>
            <P id=id_30>Алгоритм состоит в повторяющихся проходах по 
            сортируемому массиву. За каждый проход элементы последовательно 
            сравниваются попарно и, если порядок в паре неверный, выполняется 
            обмен элементов. Проходы по массиву повторяются до тех пор, пока на 
            очередном проходе не окажется, что обмены больше не нужны, что 
            означает – массив отсортирован. При проходе алгоритма элемент, 
            стоящий не на своём месте, "всплывает" до нужной позиции (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/12/staldata_12.html#image.12.1">рис. 
            12.1</A>).</P>
            <DIV id=mark_30 class=lecture_mark></DIV>
            <P id=id_31 align=left><A name=image.12.1></A>
            <DIV><IMG 
            alt='Демонстрация сортировки по неубыванию методом "пузырька"' 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/12_01.png" 
            width=459 height=468></DIV><BR><B>Рис. 12.1.</B>&nbsp; Демонстрация 
            сортировки по неубыванию методом "пузырька"
            <P></P>
            <DIV id=mark_31 class=lecture_mark></DIV>
            <DIV class=example><PRE>//Описание функции сортировки методом "пузырька"
void BubbleSort (int k,int x[max]) {
  int i,j,buf;
  for (i=k-1;i&gt;0;i--)
    for (j=0;j&lt;i;j++)
    if (x[j]&gt;x[j+1]) {
      buf=x[j];
      x[j]=x[j+1];
      x[j+1]=buf;
     }    
}
</PRE></DIV>
            <P id=id_33>В пузырьковой сортировке количество сравнений всегда 
            одно и то же, поскольку два цикла <SPAN class=texample>for</SPAN> 
            повторяются указанное количество раз независимо от того, был список 
            изначально упорядочен или нет. Это значит, что алгоритм пузырьковой 
            сортировки всегда выполняет 
            <DIV id=id_35><IMG alt="&#10;\frac{(n^2-n)}{2}&#10;" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/3e015b97e0f9faea677ac30736574993.png" 
            width=69 height=43></DIV>сравнений, где <SPAN 
            class=texample>n</SPAN> – количество сортируемых элементов. Данная 
            формула выведена на том основании, что внешний цикл выполняется 
            <SPAN class=texample>n-1</SPAN> раз, а внутренний выполняется в 
            среднем <SPAN class=texample>n/2</SPAN> раз. 
            <P></P>
            <DIV id=mark_33 class=lecture_mark></DIV>
            <P id=id_39>Пузырьковая сортировка имеет такую особенность: 
            неупорядоченные элементы на "большом" конце массива занимают 
            правильные положения за один проход, но неупорядоченные элементы в 
            начале массива поднимаются на свои места очень медленно. Поэтому, 
            вместо того чтобы постоянно просматривать массив в одном 
            направлении, в последовательных проходах можно чередовать 
            направления. Таким образом, элементы, сильно удаленные от своих 
            положений, быстро станут на свои места. Данная версия пузырьковой 
            сортировки носит название <B>шейкер-сортировки</B> (shaker sort 
            сортировка перемешиванием, сортировка взбалтыванием, сортировка 
            встряхиванием), поскольку действия, производимые ею с массивом, 
            напоминают взбалтывание или встряхивание. Ниже показана реализация 
            шейкер-сортировки.</P>
            <DIV id=mark_39 class=lecture_mark></DIV>
            <DIV class=example><PRE>//Описание функции шейкер-сортировки
void Shaker(int k,int x[max]){
  int i,t;
  bool exchange;
  do {
    exchange = false;
    for(i=k-1; i &gt; 0; --i) {
      if(x[i-1] &gt; x[i]) {
        t = x[i-1];
        x[i-1] = x[i];
        x[i] = t;
        exchange = true;
      }
    }
    for(i=1; i &lt; k; ++i) {
      if(x[i-1] &gt; x[i]) {
        t = x[i-1];
        x[i-1] = x[i];
        x[i] = t;
        exchange = true;
      }
    }
  } while(exchange); 
    //сортировать до тех пор, пока не будет обменов
}
</PRE></DIV>
            <P id=id_41>Хотя шейкер-сортировка и является улучшенным вариантом 
            по сравнению с пузырьковой сортировкой, она по-прежнему имеет время 
            выполнения порядка <SPAN class=texample>N<SUP>2</SUP></SPAN>. Это 
            объясняется тем, что количество сравнений не изменилось, а 
            количество обменов уменьшилось лишь на относительно небольшую 
            величину.</P>
            <DIV id=mark_41 class=lecture_mark></DIV><A name=sect4></A>
            <H3>Сортировка методом простого выбора (простой перебор)</H3>
            <P id=id_43>Это наиболее естественный алгоритм упорядочивания. При 
            данной сортировке из массива выбирается элемент с наименьшим 
            значением и обменивается с первым элементом. Затем из оставшихся 
            <SPAN class=texample>n - 1</SPAN> элементов снова выбирается элемент 
            с наименьшим ключом и обменивается со вторым элементом, и т.д. (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/12/staldata_12.html#image.12.2">рис. 
            12.2</A>)</P>
            <DIV id=mark_43 class=lecture_mark></DIV>
            <P id=id_45>Шаги алгоритма:</P>
            <DIV id=mark_45 class=lecture_mark></DIV>
            <OL id=id_46>
              <LI>находим минимальное значение в текущей части массива; 
              <LI>производим обмен этого значения со значением на первой 
              неотсортированной позиции;
              <LI>далее сортируем хвост массива, исключив из рассмотрения уже 
              отсортированные элементы.</LI></OL>
            <DIV id=mark_46 class=lecture_mark></DIV>
            <P id=id_50 align=left><A name=image.12.2></A>
            <DIV><IMG 
            alt="Демонстрация сортировки по неубыванию методом простого выбора" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/12_02.png" 
            width=459 height=466></DIV><BR><B>Рис. 12.2.</B>&nbsp; Демонстрация 
            сортировки по неубыванию методом простого выбора
            <P></P>
            <DIV id=mark_50 class=lecture_mark></DIV>
            <DIV class=example><PRE>//Описание функции сортировки методом простого выбора
void SelectionSort (int k,int x[max]) {
  int i,j,min,temp;
  for (i=0;i&lt;k-1;i++) {
  //устанавливаем начальное значение минимального индекса
    min=i; 
    //находим минимальный индекс элемента
    for (j=i+1;j&lt;k;j++){
      if (x[j]&lt;x[min])
        min=j;
      //меняем значения местами 
      }
      temp=x[i];
      x[i]=x[min];
      x[min]=temp;
  }
}
</PRE></DIV>
            <P id=id_52>Как и в пузырьковой сортировке, внешний цикл выполняется 
            <SPAN class=texample>n-1</SPAN> раз, а внутренний – в среднем <SPAN 
            class=texample>n/2</SPAN> раз. Следовательно, сортировка методом 
            простого выбора требует 
            <DIV id=id_55><IMG alt="&#10;\frac{(n^2-n)}{2}&#10;" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/3e015b97e0f9faea677ac30736574993.png" 
            width=69 height=43></DIV>сравнений. Таким образом, это алгоритм 
            порядка <SPAN class=texample>n<SUP>2</SUP></SPAN>, из-за чего он 
            считается слишком медленным для сортировки большого количества 
            элементов. Несмотря на то, что количество сравнений в пузырьковой 
            сортировке и сортировке простым выбором одинаковое, в последней 
            количество обменов в среднем случае намного меньше, чем в 
            пузырьковой сортировке. 
            <P></P>
            <DIV id=mark_52 class=lecture_mark></DIV><A name=sect5></A>
            <H3>Сортировка методом простого включения (сдвиг-вставка, вставками, 
            вставка и сдвиг)</H3>
            <P id=id_57>Хотя этот метод сортировки намного менее эффективен, чем 
            сложные алгоритмы (такие как быстрая сортировка), у него есть ряд 
            преимуществ:</P>
            <DIV id=mark_57 class=lecture_mark></DIV>
            <P id=id_58>Хотя этот метод сортировки намного менее эффективен, чем 
            сложные алгоритмы (такие как быстрая сортировка), у него есть ряд 
            преимуществ:</P>
            <DIV id=mark_58 class=lecture_mark></DIV>
            <UL id=id_59>
              <LI>прост в реализации;
              <LI>эффективен на небольших наборах данных, на наборах данных до 
              десятков элементов может оказаться лучшим;
              <LI>эффективен на наборах данных, которые уже частично 
              отсортированы;
              <LI>это устойчивый алгоритм сортировки (не меняет порядок 
              элементов, которые уже отсортированы);
              <LI>может сортировать массив по мере его получения;
              <LI>не требует временной памяти, даже под стек.</LI></UL>
            <DIV id=mark_59 class=lecture_mark></DIV>
            <P id=id_66>На каждом шаге алгоритма выбираем один из элементов 
            входных данных и вставляем его на нужную позицию в уже 
            отсортированной последовательности до тех пор, пока набор входных 
            данных не будет исчерпан. Метод выбора очередного элемента из 
            исходного массива произволен; может использоваться практически любой 
            алгоритм выбора (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/12/staldata_12.html#image.12.3">рис. 
            12.3</A>).</P>
            <DIV id=mark_66 class=lecture_mark></DIV>
            <P id=id_67 align=left><A name=image.12.3></A>
            <DIV><IMG 
            alt="Демонстрация сортировки по неубыванию методом простого включения" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/12_03.png" 
            width=461 height=467></DIV><BR><B>Рис. 12.3.</B>&nbsp; Демонстрация 
            сортировки по неубыванию методом простого включения
            <P></P>
            <DIV id=mark_67 class=lecture_mark></DIV>
            <DIV class=example><PRE>//Описание функции сортировки методом простого включения
void InsertSort (int k,int x[max]) {
  int i,j, temp;
  for (i=0;i&lt;k;i++) {
  //цикл проходов, i - номер прохода
    temp=x[i]; 
    //поиск места элемента
    for (j=i-1; j&gt;=0 &amp;&amp; x[j]&gt;temp; j--)
      x[j+1]=x[j];//сдвигаем элемент вправо, пока не дошли
      //место найдено, вставить элемент 
      x[j+1]=temp;  
  }
}
</PRE></DIV>
            <P id=id_69>В отличие от пузырьковой сортировки и сортировки 
            простого выбора, количество сравнений в сортировке вставками зависит 
            от изначальной упорядоченности списка. Если список уже отсортирован, 
            количество сравнений равно <SPAN class=texample>n-1</SPAN>; в 
            противном случае его производительность является величиной порядка 
            <SPAN class=texample>n<SUP>2</SUP></SPAN>.</P>
            <DIV id=mark_69 class=lecture_mark></DIV><A name=sect6></A>
            <H3>Ключевые термины</H3>
            <P id=id_72><B>Ключ сортировки</B> – это часть данных, определяющая 
            порядок элементов.</P>
            <DIV id=mark_72 class=lecture_mark></DIV>
            <P id=id_73><B>Сортировка</B> – это упорядочивание набора однотипных 
            данных по возрастанию или убыванию.</P>
            <DIV id=mark_73 class=lecture_mark></DIV>
            <P id=id_74><B>Сортировка методом "пузырька"</B> – это алгоритм 
            попарного сравнения элементов одномерного массива.</P>
            <DIV id=mark_74 class=lecture_mark></DIV>
            <P id=id_75><B>Сортировка методом простого включения</B> – это 
            алгоритм последовательного помещения элемента массива в 
            отсортированную часть в соответствии с ключом сортировки. </P>
            <DIV id=mark_75 class=lecture_mark></DIV>
            <P id=id_76><B>Сортировка методом простого выбора</B> – это алгоритм 
            последовательного обмена минимального и первого элементов 
            неотсортированной части массива.</P>
            <DIV id=mark_76 class=lecture_mark></DIV><A name=sect7></A>
            <H3>Краткие итоги</H3>
            <OL id=id_77>
              <LI>Задачи сортировок массивов имеют широкое прикладное значение.
              <LI>Существует большое количество алгоритмов сортировок массивов, 
              различающихся трудоемкостью.
              <LI>При оценке трудоемкости алгоритмов учитываются критерии: 
              количество сравнений и перестановок, время в лучшем и худшем 
              случаях, естественность поведения.
              <LI>К алгоритмам простых сортировок относятся: сортировка методом 
              "пузырька", сортировка методом простого выбора, сортировка методом 
              простого включения.
              <LI>Простые сортировки эффективны на небольших объемах 
            данных.</LI></OL>
            <DIV id=mark_77 class=lecture_mark></DIV><A name=sect8></A>
            <H3>Лабораторная работа 12. Одномерные массивы: задачи сортировок 
            элементов массива</H3>
            <P id=id_83><B>Цель работы:</B> изучить понятия и классификацию 
            алгоритмов сортировок массивов, реализацию алгоритмов простых 
            сортировок и научиться решать задачи на сортировку одномерных 
            массивов с помощью алгоритмов простых сортировок в языке C++.</P>
            <DIV id=mark_83 class=lecture_mark></DIV>
            <P id=id_84>При выполнении лабораторной работы для каждого задания 
            требуется написать программу на языке С++, которая получает на входе 
            числовые данные (в зависимости от постановки задачи), выполняет 
            генерацию и вывод одномерного массива указанного типа. В задачах 
            необходимо выполнить сортировку данных массива простыми методами и 
            реализовать алгоритмы сортировок в виде отдельных функций. Ввод 
            данных осуществляется с клавиатуры с учетом требований к входным 
            данным, содержащихся в постановке задачи. Ограничениями на входные 
            данные является диапазон используемого числового типа данных в языке 
            С++ и максимально допустимый размер объявляемого одномерного 
            массива.</P>
            <DIV id=mark_84 class=lecture_mark></DIV>
            <P id=id_85><B>Теоретические сведения.</B></P>
            <DIV id=mark_85 class=lecture_mark></DIV>
            <P id=id_86>Ознакомьтесь с материалом лекции 12.</P>
            <DIV id=mark_86 class=lecture_mark></DIV>
            <P id=id_87><B>Задания к лабораторной работе.</B></P>
            <DIV id=mark_87 class=lecture_mark></DIV>
            <P id=id_88>Выполните приведенные ниже задания.</P>
            <DIV id=mark_88 class=lecture_mark></DIV>
            <OL id=id_89>
              <LI>Отсортируйте по неубыванию методом "пузырька" одномерный 
              целочисленный массив, заданный случайными числами на промежутке 
              [-100; 100). Выведите на экран исходный и отсортированный массивы.
              <LI>Отсортируйте по невозрастанию методом простого выбора 
              одномерный вещественный массив, заданный случайными числами на 
              промежутке [0; 50). Выведите на экран исходный и отсортированный 
              массивы.
              <LI>Отсортируйте по возрастанию методом простого включения 
              одномерный целочисленный массив, заданный с клавиатуры различными 
              числами. Выведите на экран исходный и отсортированный массивы.
              <LI>Массив размером <SPAN class=texample>2m + 1</SPAN>, где <SPAN 
              class=texample>m</SPAN> – натуральное число, заполнен случайным 
              образом. Найдите в массиве медиану. Медианой называется элемент 
              ряда, делящий его на две равные части: в одной находятся элементы, 
              которые не меньше медианы, в другой – не больше медианы. 
              <LI>Массив размером <SPAN class=texample>m</SPAN>, где <SPAN 
              class=texample>m</SPAN> – натуральное число, заполнен случайным 
              образом. Найдите в массиве моду. Модой называется элемент ряда, 
              который встречается наиболее часто.</LI></OL>
            <DIV id=mark_89 class=lecture_mark></DIV>
            <P id=id_99><B>Указания к выполнению работы.</B></P>
            <DIV id=mark_99 class=lecture_mark></DIV>
            <P id=id_100>Каждое задание необходимо решить в соответствии с 
            изученными методами объявления, генерации и вывода одномерных 
            массивов в языке С++. Обработку данных необходимо выполнить, 
            используя алгоритмы простых сортировок данных в одномерных массивах. 
            При разработке программного кода требуется использовать метод 
            процедурной абстракции и комментировать фрагменты кода.</P>
            <DIV id=mark_100 class=lecture_mark></DIV>
            <P id=id_101>Следует реализовать каждое задание в соответствии с 
            приведенными этапами:</P>
            <DIV id=mark_101 class=lecture_mark></DIV>
            <UL id=id_102>
              <LI>изучить словесную постановку задачи, выделив при этом все виды 
              данных;
              <LI>сформулировать математическую постановку задачи;
              <LI>выбрать метод решения задачи, если это необходимо;
              <LI>разработать графическую схему алгоритма;
              <LI>записать разработанный алгоритм на языке С++;
              <LI>разработать контрольный тест к программе;
              <LI>отладить программу;
              <LI>представить отчет по работе.</LI></UL>
            <DIV id=mark_102 class=lecture_mark></DIV>
            <P id=id_111><B>Требования к отчету.</B></P>
            <DIV id=mark_111 class=lecture_mark></DIV>
            <P id=id_112>Отчет по лабораторной работе должен соответствовать 
            следующей структуре.</P>
            <DIV id=mark_112 class=lecture_mark></DIV>
            <UL id=id_113>
              <LI>Титульный лист.
              <LI>Словесная постановка задачи. В этом подразделе проводится 
              полное описание задачи. Описывается суть задачи, анализ входящих в 
              нее физических величин, область их допустимых значений, единицы их 
              измерения, возможные ограничения, анализ условий при которых 
              задача имеет решение (не имеет решения), анализ ожидаемых 
              результатов.
              <LI>Математическая модель. В этом подразделе вводятся 
              математические описания физических величин и математическое 
              описание их взаимодействий. Цель подраздела – представить решаемую 
              задачу в математической формулировке.
              <LI>Алгоритм решения задачи. В подразделе описывается разработка 
              структуры алгоритма, обосновывается абстракция данных, задача 
              разбивается на подзадачи. Схема алгоритма выполняется по ЕСПД 
              (ГОСТ 19.003-80 и ГОСТ 19.002-80).
              <LI>Листинг программы. Подраздел должен содержать текст программы 
              на языке программирования С++, реализованный в среде MS Visual 
              Studio 2010.
              <LI>Контрольный тест. Подраздел содержит наборы исходных данных и 
              полученные в ходе выполнения программы результаты.
              <LI>Выводы по лабораторной работе. 
              <LI>Ответы на контрольные вопросы.</LI></UL>
            <DIV id=mark_113 class=lecture_mark></DIV>
            <P id=id_122><B>Контрольные вопросы</B></P>
            <DIV id=mark_122 class=lecture_mark></DIV>
            <OL id=id_123>
              <LI>Почему существует большое количество алгоритмов сортировок?
              <LI>С какой целью используются простые сортировки, если они 
              характеризуются малой эффективностью?
              <LI>Чем отличается принцип сортировки по неубыванию 
              (невозрастанию) от сортировки по возрастанию (убыванию)?
              <LI>На каких наборах исходных данных проявляется эффективность 
              алгоритмов простых сортировок по сравнению друг с другом?
              <LI>В чем заключается улучшение метода шейкер-сортировки по 
              сравнению с пузырьковой сортировкой?</LI></OL>
            <DIV id=mark_123 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript 
src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/urchin.js">
</SCRIPT>

<SCRIPT 
type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
