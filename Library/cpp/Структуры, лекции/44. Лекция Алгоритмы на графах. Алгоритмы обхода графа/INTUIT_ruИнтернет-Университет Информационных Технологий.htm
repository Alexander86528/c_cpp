<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0071)http://www.intuit.ru/department/algorithms/staldata/44/staldata_44.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/printable.css">
<META name=GENERATOR content="MSHTML 9.00.8080.16413"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="COLOR: #000000; FONT-WEIGHT: bold">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD>
    <TD><!-- content -->
      <TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD class=head>Структуры и алгоритмы компьютерной обработки 
        данных</TD></TR>
        <TR>
          <TD height=4><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>44. Лекция: Алгоритмы на графах. Алгоритмы 
            обхода графа: версия для печати и PDA</SPAN> <BR><SPAN class=rtxt>В 
            лекции рассматриваются основные понятия из теории графов, модели 
            представления графов, на основе которых приводятся описания и 
            реализации алгоритмов поиска в глубину и в ширину. </SPAN></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3></H3>
            <P id=id_1><B>Цель лекции:</B> изучить основные алгоритмы обхода 
            графа и научиться решать задачи обхода графа на основе поиска в 
            ширину и поиска в глубину.</P>
            <DIV id=mark_1 class=lecture_mark></DIV>
            <P id=id_2>Теория графов в последнее время широко используется в 
            различных отраслях науки и техники. Быстрое развитие данная теория 
            получила с созданием электронно-вычислительной техники, которая 
            позволяла решить многие задачи алгоритмизации.</P>
            <DIV id=mark_2 class=lecture_mark></DIV>
            <P id=id_3><B>Граф</B> – это совокупность двух конечных множеств: 
            множества точек и множества линий, попарно соединяющих некоторые из 
            этих точек. Множество точек называется <SPAN 
            class=xml_em_italic>вершинами (узлами) графа</SPAN>. Множество 
            линий, соединяющих вершины графа, называются <SPAN 
            class=xml_em_italic>ребрами (дугами) графа</SPAN>.</P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <P id=id_4><SPAN class=xml_em_italic>Ориентированный граф 
            (орграф)</SPAN> – граф, у которого все ребра ориентированы, т.е. 
            ребрам которого присвоено направление.</P>
            <DIV id=mark_4 class=lecture_mark></DIV>
            <P id=id_5><SPAN class=xml_em_italic>Неориентированный граф 
            (неорграф)</SPAN> – граф, у которого все ребра неориентированы, т.е. 
            ребрам которого не задано направление.</P>
            <DIV id=mark_5 class=lecture_mark></DIV>
            <P id=id_6><SPAN class=xml_em_italic>Смешанный граф</SPAN> – граф, 
            содержащий как ориентированные, так и неориентированные ребра.</P>
            <DIV id=mark_6 class=lecture_mark></DIV>
            <P id=id_7><SPAN class=xml_em_italic>Петлей</SPAN> называется ребро, 
            соединяющее вершину саму с собой. Две вершины называются <SPAN 
            class=xml_em_italic>смежными</SPAN>, если существует соединяющее их 
            ребро. Ребра, соединяющие одну и ту же пару вершин, называются <SPAN 
            class=xml_em_italic>кратными</SPAN>.</P>
            <DIV id=mark_7 class=lecture_mark></DIV>
            <P id=id_8><SPAN class=xml_em_italic>Простой граф</SPAN> – это граф, 
            в котором нет ни петель, ни кратных ребер. </P>
            <DIV id=mark_8 class=lecture_mark></DIV>
            <P id=id_9><SPAN class=xml_em_italic>Мультиграф</SPAN> – это граф, у 
            которого любые две вершины соединены более чем одним ребром.</P>
            <DIV id=mark_9 class=lecture_mark></DIV>
            <P id=id_10><B>Маршрутом</B> в графе называется конечная 
            чередующаяся последовательность смежных вершин и ребер, соединяющих 
            эти вершины.</P>
            <DIV id=mark_10 class=lecture_mark></DIV>
            <P id=id_11>Маршрут называется <SPAN 
            class=xml_em_italic>открытым</SPAN>, если его начальная и конечная 
            вершины различны, в противном случае он называется замкнутым.</P>
            <DIV id=mark_11 class=lecture_mark></DIV>
            <P id=id_12>Маршрут называется <B>цепью</B>, если все его ребра 
            различны. Открытая цепь называется <B>путем</B>, если все ее вершины 
            различны.</P>
            <DIV id=mark_12 class=lecture_mark></DIV>
            <P id=id_13>Замкнутая цепь называется <B>циклом</B>, если различны 
            все ее вершины, за исключением концевых.</P>
            <DIV id=mark_13 class=lecture_mark></DIV>
            <P id=id_14>Граф называется <SPAN 
            class=xml_em_italic>связным</SPAN>, если для любой пары вершин 
            существует соединяющий их путь.</P>
            <DIV id=mark_14 class=lecture_mark></DIV>
            <P id=id_15><SPAN class=xml_em_italic>Вес вершины</SPAN> – число 
            (действительное, целое или рациональное), поставленное в 
            соответствие данной вершине (интерпретируется как стоимость, 
            пропускная способность и т. д.). <SPAN class=xml_em_italic>Вес 
            (длина) ребра</SPAN> – число или несколько чисел, которые 
            интерпретируются по отношению к ребру как длина, пропускная 
            способность и т. д.</P>
            <DIV id=mark_15 class=lecture_mark></DIV>
            <P id=id_16><SPAN class=xml_em_italic>Взвешенный граф</SPAN> – граф, 
            каждому ребру которого поставлено в соответствие некое значение (вес 
            ребра).</P>
            <DIV id=mark_16 class=lecture_mark></DIV>
            <P id=id_17>Выбор структуры данных для хранения графа в памяти 
            компьютера имеет принципиальное значение при разработке эффективных 
            алгоритмов. Рассмотрим несколько <B>способов представления 
            графа</B>.</P>
            <DIV id=mark_17 class=lecture_mark></DIV>
            <P id=id_18>Пусть задан граф (например, <A 
            href="http://www.intuit.ru/department/algorithms/staldata/44/staldata_44.html#image.44.1">рис. 
            44.1</A>), у которого количество вершин равно <SPAN 
            class=texample>n</SPAN>, а количество ребер – <SPAN 
            class=texample>m</SPAN>. Каждое ребро и каждая вершина имеют вес – 
            целое положительное число. Если граф не является помеченным, то 
            считается, что вес равен единице.</P>
            <DIV id=mark_18 class=lecture_mark></DIV>
            <P id=id_21 align=left><A name=image.44.1></A>
            <DIV><IMG alt=Граф 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/44_01.png" 
            width=219 height=163></DIV><BR><B>Рис. 44.1.</B>&nbsp; Граф
            <P></P>
            <DIV id=mark_21 class=lecture_mark></DIV>
            <OL id=id_22>
              <LI><SPAN class=xml_em_italic>Список ребер</SPAN> – это множество, 
              образованное парами смежных вершин (<A 
              href="http://www.intuit.ru/department/algorithms/staldata/44/staldata_44.html#image.44.2">рис. 
              44.2</A>). Для его хранения обычно используют одномерный массив 
              размером m, содержащий список пар вершин, смежных с одним ребром 
              графа. Список ребер более удобен для реализации различных 
              алгоритмов на графах по сравнению с другими способами. 
              <P id=id_24 align=left><A name=image.44.2></A>
              <DIV><IMG alt="Список ребер графа" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/44_02.png" 
              width=402 height=71></DIV><BR><B>Рис. 44.2.</B>&nbsp; Список ребер 
              графа
              <P></P>
              <DIV id=mark_24 class=lecture_mark></DIV>
              <LI><SPAN class=xml_em_italic>Матрица смежности</SPAN> – это 
              двумерный массив размерности <SPAN class=texample>n &#215; n</SPAN>, 
              значения элементов которого характеризуются смежностью вершин 
              графа (<A 
              href="http://www.intuit.ru/department/algorithms/staldata/44/staldata_44.html#image.44.3">рис. 
              44.3</A>). При этом значению элемента матрицы присваивается 
              количество ребер, которые соединяют соответствующие вершины. 
              Данный способ действенен, когда надо проверять смежность или 
              находить вес ребра по двум заданным вершинам. 
              <P id=id_27 align=left><A name=image.44.3></A>
              <DIV><IMG alt="Матрица смежности графа" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/44_03.png" 
              width=182 height=114></DIV><BR><B>Рис. 44.3.</B>&nbsp; Матрица 
              смежности графа
              <P></P>
              <DIV id=mark_27 class=lecture_mark></DIV>
              <LI><SPAN class=xml_em_italic>Матрица инцидентности</SPAN> – это 
              двумерный массив размерности <SPAN class=texample>n &#215; m</SPAN>, в 
              котором указываются связи между инцидентными элементами графа 
              (ребро и вершина). Столбцы матрицы соответствуют ребрам, строки – 
              вершинам (<A 
              href="http://www.intuit.ru/department/algorithms/staldata/44/staldata_44.html#image.44.4">рис. 
              44.4</A>). Ненулевое значение в ячейке матрицы указывает связь 
              между вершиной и ребром. Данный способ является самым емким для 
              хранения, но облегчает нахождение циклов в графе. 
              <P id=id_30 align=left><A name=image.44.4></A>
              <DIV><IMG alt="Матрица инцидентности графа" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/44_04.png" 
              width=209 height=178></DIV><BR><B>Рис. 44.4.</B>&nbsp; Матрица 
              инцидентности графа
              <P></P>
              <DIV id=mark_30 class=lecture_mark></DIV></LI></OL>
            <DIV id=mark_22 class=lecture_mark></DIV>
            <P id=id_31>Существует много алгоритмов на графах, в основе которых 
            лежит систематический перебор вершин графа, такой что каждая вершина 
            просматривается (посещается) в точности один раз. Поэтому важной 
            задачей является нахождение хороших методов поиска в графе.</P>
            <DIV id=mark_31 class=lecture_mark></DIV>
            <P id=id_32>Под <B>обходом графов (поиском на графах)</B> понимается 
            процесс систематического просмотра всех ребер или вершин графа с 
            целью отыскания ребер или вершин, удовлетворяющих некоторому 
            условию. </P>
            <DIV id=mark_32 class=lecture_mark></DIV>
            <P id=id_33>При решении многих задач, использующих графы, необходимы 
            эффективные методы регулярного обхода вершин и ребер графов. К 
            стандартным и наиболее распространенным методам относятся:</P>
            <DIV id=mark_33 class=lecture_mark></DIV>
            <UL id=id_34>
              <LI>поиск в глубину (Depth First Search, DFS);
              <LI>поиск в ширину (Breadth First Search, BFS).</LI></UL>
            <DIV id=mark_34 class=lecture_mark></DIV>
            <P id=id_37>Эти методы чаще всего рассматриваются на ориентированных 
            графах, но они применимы и для неориентированных, ребра которых 
            считаются двунаправленными. Алгоритмы обхода в глубину и в ширину 
            лежат в основе решения различных задач обработки графов, например, 
            построения остовного леса, проверки связности, ацикличности, 
            вычисления расстояний между вершинами и других.</P>
            <DIV id=mark_37 class=lecture_mark></DIV><A name=sect2></A>
            <H3>Поиск в глубину</H3>
            <P id=id_38>При поиске в глубину посещается первая вершина, затем 
            необходимо идти вдоль ребер графа, до попадания в тупик. Вершина 
            графа является <SPAN class=xml_em_italic>тупиком</SPAN>, если все 
            смежные с ней вершины уже посещены. После попадания в тупик нужно 
            возвращаться назад вдоль пройденного пути, пока не будет обнаружена 
            вершина, у которой есть еще не посещенная вершина, а затем 
            необходимо двигаться в этом новом направлении. Процесс оказывается 
            завершенным при возвращении в начальную вершину, причем все смежные 
            с ней вершины уже должны быть посещены.</P>
            <DIV id=mark_38 class=lecture_mark></DIV>
            <P id=id_39>Таким образом, основная идея поиска в глубину – когда 
            возможные пути по ребрам, выходящим из вершин, разветвляются, нужно 
            сначала полностью исследовать одну ветку и только потом переходить к 
            другим веткам (если они останутся нерассмотренными).</P>
            <DIV id=mark_39 class=lecture_mark></DIV>
            <P id=id_40><SPAN class=xml_em_italic>Алгоритм поиска в 
            глубину</SPAN></P>
            <DIV id=mark_40 class=lecture_mark></DIV>
            <P id=id_41>Шаг 1. Всем вершинам графа присваивается значение не 
            посещенная. Выбирается первая вершина и помечается как 
            посещенная.</P>
            <DIV id=mark_41 class=lecture_mark></DIV>
            <P id=id_42>Шаг 2. Для последней помеченной как посещенная вершины 
            выбирается смежная вершина, являющаяся первой помеченной как не 
            посещенная, и ей присваивается значение посещенная. Если таких 
            вершин нет, то берется предыдущая помеченная вершина.</P>
            <DIV id=mark_42 class=lecture_mark></DIV>
            <P id=id_43>Шаг 3. Повторить шаг 2 до тех пор, пока все вершины не 
            будут помечены как посещенные (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/44/staldata_44.html#image.44.5">рис. 
            44.5</A>).</P>
            <DIV id=mark_43 class=lecture_mark></DIV>
            <P id=id_44 align=left><A name=image.44.5></A>
            <DIV><IMG alt="Демонстрация алгоритма поиска в глубину" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/44_05.png" 
            width=547 height=264></DIV><BR><B>Рис. 44.5.</B>&nbsp; Демонстрация 
            алгоритма поиска в глубину
            <P></P>
            <DIV id=mark_44 class=lecture_mark></DIV>
            <DIV class=example><PRE>//Описание функции алгоритма поиска в глубину
void Depth_First_Search(int n, int **Graph, bool *Visited, 
                        int Node){
  Visited[Node] = true;
  cout &lt;&lt; Node + 1 &lt;&lt; endl;
  for (int i = 0 ; i &lt; n ; i++)
    if (Graph[Node][i] &amp;&amp; !Visited[i])
      Depth_First_Search(n,Graph,Visited,i);
}
</PRE></DIV>
            <P id=id_46>Также часто используется нерекурсивный алгоритм поиска в 
            глубину. В этом случае рекурсия заменяется на стек. Как только 
            вершина просмотрена, она помещается в стек, а использованной она 
            становится, когда больше нет новых вершин, смежных с ней.</P>
            <DIV id=mark_46 class=lecture_mark></DIV>
            <P id=id_47>Временная сложность зависит от представления графа. Если 
            применена матрица смежности, то временная сложность равна <SPAN 
            class=texample>O(n<SUP>2</SUP>)</SPAN>, а если нематричное 
            представление – <SPAN class=texample>O(n+m)</SPAN>: рассматриваются 
            все вершины и все ребра.</P>
            <DIV id=mark_47 class=lecture_mark></DIV><A name=sect3></A>
            <H3>Поиск в ширину</H3>
            <P id=id_50>При поиске в ширину, после посещения первой вершины, 
            посещаются все соседние с ней вершины. Потом посещаются все вершины, 
            находящиеся на расстоянии двух ребер от начальной. При каждом новом 
            шаге посещаются вершины, расстояние от которых до начальной на 
            единицу больше предыдущего. Чтобы предотвратить повторное посещение 
            вершин, необходимо вести список посещенных вершин. Для хранения 
            временных данных, необходимых для работы алгоритма, используется 
            очередь – упорядоченная последовательность элементов, в которой 
            новые элементы добавляются в конец, а старые удаляются из 
начала.</P>
            <DIV id=mark_50 class=lecture_mark></DIV>
            <P id=id_51>Таким образом, основная идея поиска в ширину заключается 
            в том, что сначала исследуется все вершины, смежные с начальной 
            вершиной (вершина с которой начинается обход). Эти вершины находятся 
            на расстоянии 1 от начальной. Затем исследуется все вершины на 
            расстоянии 2 от начальной, затем все на расстоянии 3 и т.д. Обратим 
            внимание, что при этом для каждой вершины сразу находятся длина 
            кратчайшего маршрута от начальной вершины.</P>
            <DIV id=mark_51 class=lecture_mark></DIV>
            <P id=id_52><SPAN class=xml_em_italic>Алгоритм поиска в 
            ширину</SPAN></P>
            <DIV id=mark_52 class=lecture_mark></DIV>
            <P id=id_53>Шаг 1. Всем вершинам графа присваивается значение не 
            посещенная. Выбирается первая вершина и помечается как посещенная (и 
            заносится в очередь).</P>
            <DIV id=mark_53 class=lecture_mark></DIV>
            <P id=id_54>Шаг 2. Посещается первая вершина из очереди (если она не 
            помечена как посещенная). Все ее соседние вершины заносятся в 
            очередь. После этого она удаляется из очереди.</P>
            <DIV id=mark_54 class=lecture_mark></DIV>
            <P id=id_55>Шаг 3. Повторяется шаг 2 до тех пор, пока очередь не 
            пуста (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/44/staldata_44.html#image.44.6">рис. 
            44.6</A>).</P>
            <DIV id=mark_55 class=lecture_mark></DIV>
            <P id=id_56 align=left><A name=image.44.6></A>
            <DIV><IMG alt="Демонстрация алгоритма поиска в ширину" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/44_06.png" 
            width=547 height=118></DIV><BR><B>Рис. 44.6.</B>&nbsp; Демонстрация 
            алгоритма поиска в ширину
            <P></P>
            <DIV id=mark_56 class=lecture_mark></DIV>
            <DIV class=example><PRE>//Описание функции алгоритма поиска в ширину
void Breadth_First_Search(int n, int **Graph, 
                          bool *Visited, int Node){
  int *List = new int[n]; //очередь
  int Count, Head;        // указатели очереди
  int i; 
  // начальная инициализация
  for (i = 0; i &lt; n ; i++)
    List[i] = 0;
  Count = Head = 0;
  // помещение в очередь вершины Node
  List[Count++] = Node;
  Visited[Node] = true;
  while ( Head &lt; Count ) {
    //взятие вершины из очереди
    Node = List[Head++];
    cout &lt;&lt; Node + 1 &lt;&lt; endl;
    // просмотр всех вершин, связанных с вершиной Node
    for (i = 0 ; i &lt; n ; i++)
      // если вершина ранее не просмотрена
      if (Graph[Node][i] &amp;&amp; !Visited[i]){
        // заносим ее в очередь
        List[Count++] = i;
        Visited[i] = true;
      }
  }
}
</PRE></DIV>
            <P id=id_58>Сложность поиска в ширину при нематричном представлении 
            графа равна <SPAN class=texample>O(n+m)</SPAN>, ибо рассматриваются 
            все <SPAN class=texample>n</SPAN> вершин и <SPAN 
            class=texample>m</SPAN> ребер. Использование матрицы смежности 
            приводит к оценке <SPAN class=texample>O(n<SUP>2</SUP>)</SPAN></P>
            <DIV id=mark_58 class=lecture_mark></DIV><A name=sect4></A>
            <H3>Ключевые термины</H3>
            <P id=id_63><B>Вес (длина) ребра</B> – это число или несколько 
            чисел, которые интерпретируются по отношению к ребру как длина, 
            пропускная способность.</P>
            <DIV id=mark_63 class=lecture_mark></DIV>
            <P id=id_64><B>Вес вершины</B> – это число (действительное, целое 
            или рациональное), поставленное в соответствие данной вершине. </P>
            <DIV id=mark_64 class=lecture_mark></DIV>
            <P id=id_65><B>Взвешенный граф</B> – это граф, каждому ребру 
            которого поставлено в соответствие его вес.</P>
            <DIV id=mark_65 class=lecture_mark></DIV>
            <P id=id_66><B>Граф</B> – это совокупность двух конечных множеств: 
            множества точек и множества линий, попарно соединяющих некоторые из 
            этих точек. </P>
            <DIV id=mark_66 class=lecture_mark></DIV>
            <P id=id_67><B>Вершины (узлы) графа</B> – это множество точек, 
            составляющих граф.</P>
            <DIV id=mark_67 class=lecture_mark></DIV>
            <P id=id_68><B>Замкнутый маршрут</B> – это маршрут в графе, у 
            которого начальная и конечная вершины совпадают.</P>
            <DIV id=mark_68 class=lecture_mark></DIV>
            <P id=id_69><B>Кратные ребра</B> – это ребра, соединяющие одну и ту 
            же пару вершин. </P>
            <DIV id=mark_69 class=lecture_mark></DIV>
            <P id=id_70><B>Маршрут в графе</B> – это конечная чередующаяся 
            последовательность смежных вершин и ребер, соединяющих эти 
            вершины.</P>
            <DIV id=mark_70 class=lecture_mark></DIV>
            <P id=id_71><B>Матрица инцидентности</B> – это двумерный массив, в 
            котором указываются связи между инцидентными элементами графа (ребро 
            и вершина). </P>
            <DIV id=mark_71 class=lecture_mark></DIV>
            <P id=id_72><B>Матрица смежности</B> – это двумерный массив, 
            значения элементов которого характеризуются смежностью вершин графа 
            </P>
            <DIV id=mark_72 class=lecture_mark></DIV>
            <P id=id_73><B>Мультиграф</B> – это граф, у которого любые две 
            вершины соединены более чем одним ребром.</P>
            <DIV id=mark_73 class=lecture_mark></DIV>
            <P id=id_74><B>Неориентированный граф (неорграф)</B> – это граф, у 
            которого все ребра неориентированы, то есть ребрам которого не 
            задано направление.</P>
            <DIV id=mark_74 class=lecture_mark></DIV>
            <P id=id_75><B>Обход графа (поиск на графе)</B> – это процесс 
            систематического просмотра всех ребер или вершин графа с целью 
            отыскания ребер или вершин, удовлетворяющих некоторому условию. </P>
            <DIV id=mark_75 class=lecture_mark></DIV>
            <P id=id_76><B>Ориентированный граф (орграф)</B> – это граф, у 
            которого все ребра ориентированы, то есть ребрам которого присвоено 
            направление.</P>
            <DIV id=mark_76 class=lecture_mark></DIV>
            <P id=id_77><B>Открытый маршрут</B> – это маршрут в графе, у 
            которого начальная и конечная вершины различны.</P>
            <DIV id=mark_77 class=lecture_mark></DIV>
            <P id=id_78><B>Петля</B> – это ребро, соединяющее вершину саму с 
            собой. </P>
            <DIV id=mark_78 class=lecture_mark></DIV>
            <P id=id_79><B>Поиск в глубину</B> – это обход графа по возможным 
            путям, когда нужно сначала полностью исследовать одну ветку и только 
            потом переходить к другим веткам (если они останутся 
            нерассмотренными).</P>
            <DIV id=mark_79 class=lecture_mark></DIV>
            <P id=id_80><B>Поиск в ширину</B> – это графа по возможным путям, 
            когда после посещения вершины, посещаются все соседние с ней 
            вершины.</P>
            <DIV id=mark_80 class=lecture_mark></DIV>
            <P id=id_81><B>Простой граф</B> – это граф, в котором нет ни петель, 
            ни кратных ребер. </P>
            <DIV id=mark_81 class=lecture_mark></DIV>
            <P id=id_82><B>Путь</B> – это открытая цепь, у которой все вершины 
            различны.</P>
            <DIV id=mark_82 class=lecture_mark></DIV>
            <P id=id_83><B>Ребра (дуги) графа</B> – это множество линий, 
            соединяющих вершины графа.</P>
            <DIV id=mark_83 class=lecture_mark></DIV>
            <P id=id_84><B>Связный граф</B> – это граф, у которого для любой 
            пары вершин существует соединяющий их путь.</P>
            <DIV id=mark_84 class=lecture_mark></DIV>
            <P id=id_85><B>Смежные вершины</B> – это вершины, соединенные общим 
            ребром. </P>
            <DIV id=mark_85 class=lecture_mark></DIV>
            <P id=id_86><B>Смешанный граф</B> – это граф, содержащий как 
            ориентированные, так и неориентированные ребра.</P>
            <DIV id=mark_86 class=lecture_mark></DIV>
            <P id=id_87><B>Список ребер</B> – это множество, образованное парами 
            смежных вершин </P>
            <DIV id=mark_87 class=lecture_mark></DIV>
            <P id=id_88><B>Тупик</B> – это вершина графа, для которой все 
            смежные с ней вершины уже посещены</P>
            <DIV id=mark_88 class=lecture_mark></DIV>
            <P id=id_89><B>Цепь</B> – это маршрут в графе, у которого все ребра 
            различны.</P>
            <DIV id=mark_89 class=lecture_mark></DIV>
            <P id=id_90><B>Цикл</B> – это замкнутая цепь, у которой различны все 
            ее вершины, за исключением концевых.</P>
            <DIV id=mark_90 class=lecture_mark></DIV><A name=sect5></A>
            <H3>Краткие итоги</H3>
            <OL id=id_91>
              <LI>Графы являются моделью представления данных, основанных на 
              отношениях между элементами множеств.
              <LI>Для представления графов используется несколько способов: 
              список ребер, матрица смежности, матрица инцидентности.
              <LI>Для организации поиска на графах используются обходы в глубину 
              и в ширину.
              <LI>Реализацию обходов можно осуществлять рекурсивными и 
              нерекурсивными алгоритмами.
              <LI>От вида графа и способа его представления зависит временная 
              сложность выполнения алгоритма.</LI></OL>
            <DIV id=mark_91 class=lecture_mark></DIV><A name=sect6></A>
            <H3>Лабораторная работа 44. Алгоритмы на графах. Алгоритмы обхода 
            графа</H3>
            <P id=id_97><B>Цель работы:</B> изучить основные алгоритмы обхода 
            графа и научиться решать задачи обхода графа на основе поиска в 
            ширину и поиска в глубину.</P>
            <DIV id=mark_97 class=lecture_mark></DIV>
            <P id=id_98>При выполнении лабораторной работы для каждого задания 
            требуется написать программу на языке С++, которая получает на входе 
            числовые данные, выполняет их обработку в соответствии с 
            требованиями задания и выводит результат на экран. Для обработки 
            данных необходимо реализовать алгоритмы обхода графа в соответствии 
            с постановкой задачи. Ввод данных осуществляется из файла с учетом 
            требований к входным данным, содержащихся в постановке задачи. 
            Ограничениями на входные данные является допустимый диапазон 
            значений используемых числовых типов в языке С++.</P>
            <DIV id=mark_98 class=lecture_mark></DIV>
            <P id=id_99><B>Теоретические сведения.</B></P>
            <DIV id=mark_99 class=lecture_mark></DIV>
            <P id=id_100>Ознакомьтесь с материалом лекции 44.</P>
            <DIV id=mark_100 class=lecture_mark></DIV>
            <P id=id_101><B>Задания к лабораторной работе.</B></P>
            <DIV id=mark_101 class=lecture_mark></DIV>
            <P id=id_102>Выполните приведенные ниже задания.</P>
            <DIV id=mark_102 class=lecture_mark></DIV>
            <OL id=id_103>
              <LI>На основании приведенной в лекции 44 функции реализуйте 
              программу, в которой выполняется алгоритм обхода графа на основе 
              поиска в глубину.
              <LI>На основании приведенной в лекции 44 функции реализуйте 
              программу, в которой выполняется алгоритм обхода графа на основе 
              поиска в ширину.
              <LI>Используйте обход графа в ширину для определения всех вершин 
              графа, находящихся на фиксированном расстоянии <SPAN 
              class=texample>d</SPAN> от данной вершины. 
              <LI>Перенумеруйте вершины графа в порядке обхода в глубину и 
              вычислите среднюю плотность графа как частное от деления 
              количества его ребер на число вершин. Можно ли оба эти действия 
              выполнить за один обход графа?
              <LI>В вершинах неориентированного графа хранятся положительные 
              целые числа. Подсчитайте количество пар дружественных чисел в 
              вершинах графа, которые соединены ребрами.</LI></OL>
            <DIV id=mark_103 class=lecture_mark></DIV>
            <P id=id_110><B>Указания к выполнению работы.</B></P>
            <DIV id=mark_110 class=lecture_mark></DIV>
            <P id=id_111>Каждое задание необходимо решить в соответствии с 
            изученными алгоритмами обхода графа, реализовав программный код на 
            языке С++. Рекомендуется воспользоваться материалами лекции 44, где 
            подробно рассматриваются описания алгоритмов обхода графа, примеры 
            разработки функций, реализующих алгоритмы обхода графа, на языке 
            С++. Программу для решения каждого задания необходимо разработать 
            методом процедурной абстракции, используя функции. Этапы решения 
            сопроводить комментариями в коде. В отчете следует отразить 
            разработку и обоснование математической модели решения задачи, 
            представить результаты тестирования программ. </P>
            <DIV id=mark_111 class=lecture_mark></DIV>
            <P id=id_112>Следует реализовать каждое задание в соответствии с 
            приведенными этапами:</P>
            <DIV id=mark_112 class=lecture_mark></DIV>
            <UL id=id_113>
              <LI>изучить словесную постановку задачи, выделив при этом все виды 
              данных;
              <LI>сформулировать математическую постановку задачи;
              <LI>выбрать метод решения задачи, если это необходимо;
              <LI>разработать графическую схему алгоритма;
              <LI>записать разработанный алгоритм на языке С++;
              <LI>разработать контрольный тест к программе;
              <LI>отладить программу;
              <LI>представить отчет по работе.</LI></UL>
            <DIV id=mark_113 class=lecture_mark></DIV>
            <P id=id_122><B>Требования к отчету.</B></P>
            <DIV id=mark_122 class=lecture_mark></DIV>
            <P id=id_123>Отчет по лабораторной работе должен соответствовать 
            следующей структуре.</P>
            <DIV id=mark_123 class=lecture_mark></DIV>
            <UL id=id_124>
              <LI>Титульный лист.
              <LI>Словесная постановка задачи. В этом подразделе проводится 
              полное описание задачи. Описывается суть задачи, анализ входящих в 
              нее физических величин, область их допустимых значений, единицы их 
              измерения, возможные ограничения, анализ условий при которых 
              задача имеет решение (не имеет решения), анализ ожидаемых 
              результатов.
              <LI>Математическая модель. В этом подразделе вводятся 
              математические описания физических величин и математическое 
              описание их взаимодействий. Цель подраздела – представить решаемую 
              задачу в математической формулировке.
              <LI>Алгоритм решения задачи. В подразделе описывается разработка 
              структуры алгоритма, обосновывается абстракция данных, задача 
              разбивается на подзадачи. Схема алгоритма выполняется по ЕСПД 
              (ГОСТ 19.003-80 и ГОСТ 19.002-80).
              <LI>Листинг программы. Подраздел должен содержать текст программы 
              на языке программирования С++, реализованный в среде MS Visual 
              Studio 2010.
              <LI>Контрольный тест. Подраздел содержит наборы исходных данных и 
              полученные в ходе выполнения программы результаты.
              <LI>Выводы по лабораторной работе. 
              <LI>Ответы на контрольные вопросы.</LI></UL>
            <DIV id=mark_124 class=lecture_mark></DIV>
            <P id=id_133><B>Контрольные вопросы</B></P>
            <DIV id=mark_133 class=lecture_mark></DIV>
            <OL id=id_134>
              <LI>Как связаны между собой различные способы представления 
графов?
              <LI>Как от вида или представления графа зависит временная 
              сложность алгоритмов поиска в глубину и в ширину?
              <LI>Как при реализации в коде выполняется возвращение из тупиковых 
              вершин при обходе графа?
              <LI>Как выполняется обход в несвязном графе? 
              <LI>Распространяются ли понятия "поиск в глубину" и "поиск в 
              ширину" на несвязный граф? Ответ обоснуйте.
              <LI>Охарактеризуйте трудоемкость рекурсивного и нерекурсивного 
              алгоритмов обхода графа.</LI></OL>
            <DIV id=mark_134 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript 
src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/urchin.js">
</SCRIPT>

<SCRIPT 
type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
