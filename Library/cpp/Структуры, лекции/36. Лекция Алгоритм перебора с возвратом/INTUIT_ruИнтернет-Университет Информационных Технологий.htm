<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0071)http://www.intuit.ru/department/algorithms/staldata/36/staldata_36.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/printable.css">
<META name=GENERATOR content="MSHTML 9.00.8080.16413"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="COLOR: #000000; FONT-WEIGHT: bold">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD>
    <TD><!-- content -->
      <TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD class=head>Структуры и алгоритмы компьютерной обработки 
        данных</TD></TR>
        <TR>
          <TD height=4><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>36. Лекция: Алгоритм перебора с возвратом: 
            версия для печати и PDA</SPAN> <BR><SPAN class=rtxt>В лекции 
            рассматривается общее и частное решения переборных задач, 
            организация возвратной рекурсии, трудоемкость алгоритмов возвратной 
            рекурсии, приводится пример решения задачи о расстановке ферзей на 
            шахматной доске методом рекурсии с возвратом. </SPAN></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3></H3>
            <P id=id_1><B>Цель лекции:</B> изучить рекурсивный алгоритм перебора 
            с возвратом, научиться разрабатывать рекурсивную триаду и алгоритм 
            перебора с возвратом при решении задач на языке C++.</P>
            <DIV id=mark_1 class=lecture_mark></DIV>
            <P id=id_2>Во многих практических задачах из различных предметных 
            областей требуется найти общее количество вариантов решения, число 
            элементов в полном наборе решений. Иногда, исходя из постановки 
            задачи, достаточно найти один из вариантов, соответствующих условию 
            задачи. В некоторых задачах изучается вопрос о существовании решения 
            как такового.</P>
            <DIV id=mark_2 class=lecture_mark></DIV>
            <P id=id_3>Ответы на поставленные вопросы, как правило, требуют 
            проведения <B>исчерпывающего поиска</B> в некотором множестве всех 
            возможных вариантов, среди которых находятся решения конкретной 
            задачи. Существуют два общих метода организации исчерпывающего 
            поиска: <B>перебор с возвратом</B> (backtracking) и его естественное 
            логическое дополнение - <B>метод решета</B>.</P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <P id=id_4>Решение задачи методом перебора с возвратом строится 
            конструктивно последовательным расширением частичного решения. Если 
            на конкретном шаге такое расширение провести не удается, то 
            происходит возврат к более короткому частичному решению, и попытки 
            его расширить продолжаются. Для ускорения перебора с возвратом 
            вычисления всегда стараются организовать так, чтобы была возможность 
            отказаться как можно раньше от как можно большего числа заведомо 
            неподходящих вариантов. Незначительные модификации метода перебора с 
            возвратом, связанные с представлением данных или особенностями 
            реализации, имеют и иные названия: метод ветвей и границ (branch and 
            bound), поиск в глубину (depth first search), метод проб и ошибок и 
            т. д. Перебор с возвратом практически одновременно и независимо был 
            изобретен многими исследователями еще до его формального описания. 
            Он находит применение при решении различных комбинаторных задач в 
            области искусственного интеллекта.</P>
            <DIV id=mark_4 class=lecture_mark></DIV>
            <P id=id_5>При использовании метода решета вместо конструктивного 
            построения решений задачи из множества возможных вариантов 
            исключаются все элементы, не являющиеся решениями. Методы решета 
            нашли широкое применение в теоретико-числовых задачах.</P>
            <DIV id=mark_5 class=lecture_mark></DIV>
            <P id=id_6>Метод перебора с возвратом и метод решета, строго говоря, 
            не являются ни методами, ни алгоритмами решения задач. Их следует 
            воспринимать как на некоторые общие схемы, которые применяются для 
            решения той или иной задачи. Реализация этих схем в виде конкретных 
            алгоритмов часто требует значительных дополнительных усилий в 
            представлении данных и описании зависимостей между ними.</P>
            <DIV id=mark_6 class=lecture_mark></DIV>
            <P id=id_7>Соединение метода перебора с возвратом и рекурсии 
            определяет специфический способ реализации рекурсивных вычислений и 
            называется <B>возвратной рекурсией</B>. Это соединение двух 
            эффективных методов реализации переборных алгоритмов. </P>
            <DIV id=mark_7 class=lecture_mark></DIV>
            <P id=id_8>При использовании возвратной рекурсии отпадает 
            необходимость непосредственно организовывать возвраты и отслеживать 
            правильность их осуществления. Они, как правило, становятся 
            встроенной частью механизма выполнения рекурсивных вызовов.</P>
            <DIV id=mark_8 class=lecture_mark></DIV><A name=sect2></A>
            <H3>Вычислительная схема перебора с возвратом</H3>
            <P id=id_9>Опишем общую постановку класса задач, к которым заведомо 
            применим алгоритм перебора с возвратом.</P>
            <DIV id=mark_9 class=lecture_mark></DIV>
            <P id=id_10>Пусть <SPAN class=texample>M<SUB>0</SUB>, M<SUB>1</SUB>, 
            ...,M<SUB>n-1</SUB></SPAN> - <SPAN class=texample>n</SPAN> конечных 
            линейно упорядоченных множеств и <SPAN class=texample>G</SPAN> - 
            совокупность ограничений (условий), ставящих в соответствие векторам 
            вида <SPAN 
            class=texample>v=(v<SUB>0</SUB>,v<SUB>1</SUB>,...,v<SUB>k</SUB>)<SUP>T</SUP>(v<SUB>j</SUB><IMG 
            style="POSITION: relative; TOP: 2px" border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/isin.gif" 
            width=8 height=18>M<SUB>j</SUB>; j=0,1,...,k; k<IMG 
            style="POSITION: relative; TOP: 2px" border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/le.gif" 
            width=8 height=18>n-1)</SPAN>, булево значение <SPAN 
            class=texample>G(v)<IMG style="POSITION: relative; TOP: 2px" 
            border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/isin.gif" 
            width=8 height=18></SPAN>{<SPAN 
            class=xml_em_italic>истина,ложь</SPAN>} . Векторы <SPAN 
            class=texample>v=(v<SUB>0</SUB>,v<SUB>1</SUB>,...,v<SUB>k</SUB>)<SUP>T</SUP></SPAN> 
            , для которых <SPAN class=texample>G(v)</SPAN>=<SPAN 
            class=xml_em_italic>истина</SPAN>, назовем <SPAN 
            class=xml_em_italic>частичными решениями</SPAN>. Пусть, далее, 
            существует конкретное правило <SPAN class=texample>P</SPAN>, в 
            соответствии с которым некоторые из частичных решений могут 
            объявляться полными решениями. Тогда возможна постановка следующих 
            поисковых задач.</P>
            <DIV id=mark_10 class=lecture_mark></DIV>
            <UL id=id_19>
              <LI>Найти все полные решения или установить отсутствие таковых.
              <LI>Найти хотя бы одно полное решение или установить его 
              отсутствие. </LI></UL>
            <DIV id=mark_19 class=lecture_mark></DIV>
            <P id=id_22>Общий метод решения приведенных задач состоит в 
            последовательном покомпонентном наращивании вектора <SPAN 
            class=texample>v</SPAN> слева направо, начиная с <SPAN 
            class=texample>v<SUB>0</SUB></SPAN> , и последующих проверках его 
            ограничениями <SPAN class=texample>G</SPAN> и правилом <SPAN 
            class=texample>P</SPAN>.</P>
            <DIV id=mark_22 class=lecture_mark></DIV>
            <P id=id_27>В общем случае этот метод приводит к алгоритмам с 
            экспоненциальной временной сложностью, а применяется он в основном к 
            классу так называемых <SPAN class=texample>Np</SPAN>-полных задач 
            (задача коммивояжера, задача о рюкзаке и т. д.). Задачи этого класса 
            эквивалентны друг другу в том смысле, что все они разрешимы 
            недетерминированными алгоритмами полиномиальной сложности. Для них 
            известно, что либо все они разрешимы, либо ни одна из них не 
            разрешима детерминированными алгоритмами полиномиальной сложности. 
            Иными словами, если хотя бы для одной из этих задач не существует 
            детерминированного алгоритма, имеющего в худшем случае 
            полиномиальную трудоемкость, то такие алгоритмы не должны 
            существовать и для остальных задач этого класса. Наоборот, если хотя 
            бы для одной из этих задач удалось найти детерминированный алгоритм, 
            имеющий в худшем случае полиномиальную трудоемкость, то подобные 
            алгоритмы существовали бы и для остальных задач этого класса и, 
            более того, их можно было бы построить.</P>
            <DIV id=mark_27 class=lecture_mark></DIV>
            <P id=id_29>Опишем схему выполнения недетерминированного алгоритма. 
            Пусть алгоритм выполняется до тех пор, пока не доходит до места, с 
            которого должен быть сделан выбор из нескольких альтернатив. 
            Детерминированный алгоритм однозначно осуществит выбор конкретной 
            альтернативы и продолжит работать в соответствии с эти выбором. 
            Недетерминированный алгоритм исследует все возможности одновременно, 
            как бы копируя себя для реализации вычислений по всем альтернативам 
            одновременно. Далее все копии работают независимо друг от друга и по 
            мере необходимости продолжают создавать новые копии. Копия, 
            сделавшая неправильный или безрезультатный выбор прекращает свою 
            работу. Копия, нашедшая решение задачи, объявляет об этом, давая тем 
            самым сигнал другим копиям о прекращении вычислений. 
            Недетерминированные алгоритмы, являясь весьма полезной и 
            продуктивной абстракцией, рекурсивны по сути, ибо при реализации 
            оператора выбора фактически обращаются сами к себе.</P>
            <DIV id=mark_29 class=lecture_mark></DIV>
            <P id=id_30>Возможно, что многие задачи, решаемые методом перебора с 
            возвратом, могут быть решены более эффективно другими способами. 
            Однако ценность метода перебора с возвратом в соединении с рекурсией 
            неоспорима. Во-первых, программы решения многих задач строятся по 
            единой схеме, а во-вторых, они компактны и тем самым просты для 
            понимания и усвоения соответствующих идей.</P>
            <DIV id=mark_30 class=lecture_mark></DIV>
            <P id=id_31><SPAN class=xml_em_italic>Пример 1. Задача о расстановке 
            ферзей на шахматной доске.</SPAN></P>
            <DIV id=mark_31 class=lecture_mark></DIV>
            <P id=id_32>Составьте рекурсивную функцию, находящую возможную 
            расстановку <SPAN class=texample>n</SPAN> ферзей на шахматной доске 
            размером <SPAN class=texample>n&#215;n</SPAN> так, чтобы они не били друг 
            друга (<SPAN class=texample>n</SPAN> – натуральное число). </P>
            <DIV id=mark_32 class=lecture_mark></DIV>
            <P id=id_36>В соответствии с общей схемой алгоритма перебора с 
            возвратом предложенную задачу можно решать по алгоритму "Все 
            расстановки", но завершить выполнение алгоритма при нахождении 
            первой требуемой расстановки или при получении вывода о 
            невозможности получить нужную комбинацию. Согласно алгоритму ферзи 
            расставляются последовательно на вертикалях с номерами от нуля и 
            далее. В процессе выполнения предписания возможны снятия ферзей с 
            доски (возвраты).</P>
            <DIV id=mark_36 class=lecture_mark></DIV>
            <P id=id_37><SPAN class=xml_em_italic>Алгоритм "Все 
            расстановки"</SPAN></P>
            <DIV id=mark_37 class=lecture_mark></DIV>
            <P id=id_38>Шаг 1. Полагаем <SPAN class=texample>D = <IMG 
            style="POSITION: relative; TOP: 2px" border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty(1).gif" 
            width=8 height=18>, j = 0</SPAN> (<SPAN class=texample>D</SPAN> - 
            множество решений, <SPAN class=texample>j</SPAN> - текущий столбец 
            для очередного ферзя).</P>
            <DIV id=mark_38 class=lecture_mark></DIV>
            <P id=id_42>Шаг 2. Пытаемся в столбце <SPAN class=texample>j</SPAN> 
            продвинуть вниз по вертикали или новый (если столбец <SPAN 
            class=texample>j</SPAN> пустой), или уже имеющийся там ферзь на 
            ближайшую допустимую строку. Если это сделать не удалось, то 
            переходим к шагу 4.</P>
            <DIV id=mark_42 class=lecture_mark></DIV>
            <P id=id_45>Шаг 3. Увеличиваем <SPAN class=texample>j</SPAN> на 1, 
            то есть переходим к следующему столбцу. Если <SPAN 
            class=texample>j&lt;n-1</SPAN>, то переходим к шагу 2. В противном 
            случае <SPAN class=texample>j=n-1</SPAN>, то есть все вертикали уже 
            заняты. Найденное частичное решение запоминаем в множестве <SPAN 
            class=texample>D</SPAN> и переходим к шагу 2. </P>
            <DIV id=mark_45 class=lecture_mark></DIV>
            <P id=id_50>Шаг 4. Уменьшаем <SPAN class=texample>j</SPAN> на 1, то 
            есть снимаем ферзь со столбца <SPAN class=texample>j</SPAN> и 
            переходим к предыдущему столбцу. Если <SPAN 
            class=texample>j&gt;0</SPAN> , то выполняем шаг 2. Иначе вычисления 
            прекращаем. Решения задачи находятся в множестве <SPAN 
            class=texample>D</SPAN>, которое, может быть и пустым.</P>
            <DIV id=mark_50 class=lecture_mark></DIV>
            <P id=id_55>Решение задачи для небольших размеров доски можно найти 
            "вручную", но для разработки алгоритма необходимо провести 
            моделирование условия и остановиться на каком-либо представлении 
            данных.</P>
            <DIV id=mark_55 class=lecture_mark></DIV>
            <P id=id_56>Проведем <SPAN class=xml_em_italic>параметризацию</SPAN> 
            задачи. Введем четыре вспомогательных вектора: <SPAN 
            class=texample>pos, ho, dd</SPAN> и <SPAN class=texample>du</SPAN> c 
            длинами <SPAN class=texample>n, n, 2n-1</SPAN> и <SPAN 
            class=texample>2n-1</SPAN> соответственно. Использовать их будем 
            следующим образом (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/36/staldata_36.html#image.36.1">рис. 
            36.1</A>):</P>
            <DIV id=mark_56 class=lecture_mark></DIV>
            <UL id=id_61>
              <LI><SPAN class=texample>ho<SUB>i</SUB>=1</SPAN>, если на 
              горизонтали с номером <SPAN class=texample>i (i=0,1,...n-1)</SPAN> 
              имеется ферзь, и <SPAN class=texample>ho<SUB>i</SUB>=0</SPAN> - в 
              противном случае;
              <LI><SPAN class=texample>du<SUB>s</SUB>=1</SPAN>, если на 
              диагонали с номером <SPAN class=texample>s (s=0,1,...2n-2)</SPAN>, 
              идущей слева направо и снизу вверх, имеется ферзь, и <SPAN 
              class=texample>du<SUB>s</SUB>=0</SPAN> - в противном случае;
              <LI><SPAN class=texample>dd<SUB>s</SUB>=1</SPAN>, если на 
              диагонали с номером <SPAN class=texample>s (s=0,1,...2n-1)</SPAN>, 
              идущей слева направо и сверху вниз, имеется ферзь, и <SPAN 
              class=texample>dd<SUB>s+1</SUB>=0</SPAN> - в противном случае;
              <LI><SPAN class=texample>pos<SUB>j</SUB>=i</SPAN>, если в позиции 
              <SPAN class=texample>(i,j) (i,j=0,1,...n-1)</SPAN> стоит 
              ферзь.</LI></UL>
            <DIV id=mark_61 class=lecture_mark></DIV>
            <P id=id_77 align=left><A name=image.36.1></A>
            <DIV><IMG 
            alt="Схема использования вспомогательных массивов в задаче" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/36_01.png" 
            width=488 height=446></DIV><BR><B>Рис. 36.1.</B>&nbsp; Схема 
            использования вспомогательных массивов в задаче
            <P></P>
            <DIV id=mark_77 class=lecture_mark></DIV>
            <P id=id_78>Использование этих соглашений позволяет получить такие 
            утверждения:</P>
            <DIV id=mark_78 class=lecture_mark></DIV>
            <UL id=id_79>
              <LI>В позицию <SPAN class=texample>(i,j)</SPAN> можно поставить 
              ферзь, если <SPAN 
              class=texample>ho<SUB>i</SUB>+du<SUB>i+j</SUB>+dd<SUB>n+i-j</SUB>=0</SPAN>.
              <LI>Поставить ферзь в позицию <SPAN class=texample>(i,j)</SPAN> 
              равносильно присваиваниям: <SPAN class=texample>ho<SUB>i</SUB>=1, 
              du<SUB>i+j</SUB>=1, dd<SUB>n+i-j</SUB>=1</SPAN>.
              <LI>Убрать ферзь из позиции <SPAN class=texample>(i,j)</SPAN> 
              равносильно присваиваниям: <SPAN class=texample>ho<SUB>i</SUB>=0, 
              du<SUB>i+j</SUB>=0, dd<SUB>n+i-j</SUB>=0</SPAN>.</LI></UL>
            <DIV id=mark_79 class=lecture_mark></DIV>
            <P id=id_89>Данное описание алгоритма является моделью решения общей 
            задачи о нахождении всех вариантов расстановок. Рекурсия здесь 
            осуществляется по не совсем стандартной схеме. В каждом рекурсивном 
            вызове глубины <SPAN class=texample>j</SPAN> делается попытка 
            поместить ферзь в некоторую позицию <SPAN class=texample>i</SPAN> 
            столбца <SPAN class=texample>j (i,j=0,1,...n-1)</SPAN>, а сам вызов 
            соответствует переходу от работы с текущим столбцом к работе со 
            следующим столбцом. При этом в начале вычислений и при переходах к 
            любому <SPAN class=xml_em_italic>последующему</SPAN> рекурсивному 
            вызову параметр <SPAN class=texample>i</SPAN> меняется от нуля и 
            далее с шагом, равным единице, пытаясь принять значение наименьшего 
            номера поля, допустимого для установки ферзя. При переходах к любому 
            <SPAN class=xml_em_italic>предыдущему</SPAN> рекурсивному вызову 
            параметр <SPAN class=texample>i</SPAN> продолжает изменяться от 
            своего текущего на данном уровне значения с шагом, равным единице, 
            также пытаясь принять значение наименьшего номера поля, допустимого 
            для установки ферзя. Если в текущем столбце ферзь установить уже не 
            удается, то создавшуюся ситуацию назовем <SPAN 
            class=xml_em_italic>тупиком</SPAN>. Попадание в тупик приводит к 
            завершению текущего рекурсивного вызова, то есть к возврату к 
            предыдущему столбцу и продолжению работы с ним. Иных случаев 
            завершения рекурсивных вызовов не существует. Поэтому <SPAN 
            class=xml_em_italic>базой рекурсии</SPAN> мы должны считать 
            совокупность всех тупиков. Заметим, что в данном случае элементы 
            базы заранее до вычислений неизвестны.</P>
            <DIV id=mark_89 class=lecture_mark></DIV>
            <P id=id_95>После установки ферзя в одну из строк <SPAN 
            class=texample>i</SPAN> последнего столбца <SPAN 
            class=texample>i=n-1</SPAN> формируется одно из решений задачи – при 
            поиске одного варианта расстановки на этом этапе следует завершить 
            выполнение алгоритма. При поиске всех расстановок вычисления 
            прекращаются, когда мы попадаем в тупик при работе со столбцом 0. 
            Полученные решения задачи, если они есть, возвращаются в виде 
            столбцов матрицы <SPAN class=texample>otv</SPAN>, начиная от первого 
            и далее. </P>
            <DIV id=mark_95 class=lecture_mark></DIV>
            <P id=id_99>Рассмотрим, как реализуется <SPAN 
            class=xml_em_italic>декомпозиция</SPAN>. Для этого вместо исходной 
            задачи удобно решать ее следующее обобщение.</P>
            <DIV id=mark_99 class=lecture_mark></DIV>
            <P id=id_100>На доске размера <SPAN class=texample>n&#215;m 
            (m=n,n-1,...,0)</SPAN> требуется установить <SPAN 
            class=texample>m</SPAN> ферзей так, чтобы они не били друг друга. 
            При этом имеются некоторые клетки доски, на которые ферзь заведомо 
            ставить нельзя. Множество этих "запретных" клеток обозначим через 
            <SPAN class=texample>&#969;</SPAN>.</P>
            <DIV id=mark_100 class=lecture_mark></DIV>
            <P id=id_104>Исходная задача есть <SPAN class=texample>E (n, n, <IMG 
            style="POSITION: relative; TOP: 2px" border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty(1).gif" 
            width=8 height=18>)</SPAN>. Проведем ее декомпозицию. Представим 
            доску в виде двух частей: нулевого столбца <SPAN 
            class=texample>(A)</SPAN> и оставшейся части <SPAN 
            class=texample>(B)</SPAN>. Соответственно этому разбиению будем 
            решать задачи <SPAN class=texample>E (n, 1, <IMG 
            style="POSITION: relative; TOP: 2px" border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty(1).gif" 
            width=8 height=18>)</SPAN> и <SPAN class=texample>E (n, n-1, 
            &#969;)</SPAN>. Каждое из <SPAN class=texample>n</SPAN> возможных решений 
            <SPAN class=texample>i</SPAN> (ферзь установлен в строке <SPAN 
            class=texample>i=0,1,...n-1</SPAN>) первой задачи однозначно 
            определяет множество <SPAN class=texample>&#969;=&#969;(i)</SPAN> запретных 
            клеток для второй задачи. При этом в <SPAN 
            class=texample>&#969;(i)</SPAN> попадают те клетки <SPAN 
            class=texample>B</SPAN>, которые в "объединенной" доске бьет ферзь, 
            установленный в строке <SPAN class=texample>i</SPAN> доски <SPAN 
            class=texample>A</SPAN>. Пусть <SPAN class=texample>i</SPAN> 
            зафиксировано и найдено множество <SPAN class=texample>d(i)</SPAN> 
            решений второй задачи <SPAN class=texample>E (n, n-1, &#969;(i))</SPAN> 
            для доски <SPAN class=texample>B</SPAN>. Тогда расположение ферзя в 
            строке <SPAN class=texample>i</SPAN> доски <SPAN 
            class=texample>A</SPAN> и любое из полученных решений <SPAN 
            class=texample>x<IMG style="POSITION: relative; TOP: 2px" border=0 
            alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/isin.gif" 
            width=8 height=18>d(i)</SPAN> на <SPAN class=texample>B</SPAN> в 
            совокупности дают различные решения <SPAN 
            class=texample>otv(i)</SPAN> исходной задачи <SPAN class=texample>E 
            (n, n, <IMG style="POSITION: relative; TOP: 2px" border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty(1).gif" 
            width=8 height=18>)</SPAN>. Для получения всех решений этой задачи 
            остается лишь взять объединение по <SPAN class=texample>i</SPAN> 
            множеств <SPAN class=texample>otv(i)</SPAN>.</P>
            <DIV id=mark_104 class=lecture_mark></DIV>
            <P id=id_130>При анализе трудоемкости алгоритма получаем, что 
            глубина рекурсии равна <SPAN class=texample>n<SUP>2</SUP></SPAN> - 
            при каждом рекурсивном вызове по <SPAN class=texample>j 
            (j=0,1,...n-1)</SPAN> происходит <SPAN class=texample>n</SPAN> 
            рекурсивных вызовов по <SPAN class=texample>i 
            (i=0,1,...n-1)</SPAN>.</P>
            <DIV id=mark_130 class=lecture_mark></DIV><A></A>
            <DIV class=example><PRE>//нахождение одного варианта расстановки
#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
void Initialization(int n, int ***x);
void Destruction(int n, int **x);
bool Queen(int n, int **x);
void Placement(int n, int **a, int *p, int *h, int *du, 
               int *dd, int i=0, int j=0);

int _tmain(int argc, _TCHAR* argv[]){
  int n, i, j;
  bool otv;
  int **mas;
  printf("Введите размер шахматной доски n : ");
  scanf ("%d",&amp;n);
  Initialization(n,&amp;mas);
  otv = Queen(n,mas);
  if ( otv ) printf("Правильное размещение найдено\n");
  else printf("Правильного размещения не найдено\n");
  Destruction(n,mas);
  system("pause");
  return 0;
}

//инициализация поля шахматной доски
void Initialization(int n, int ***x){ 
  *x = new int*[n]; 
  for (int i = 0 ; i &lt; n; i++ ){
    (*x)[i] = new int[n];
    for (int j = 0 ; j &lt; n ; j++ )
      (*x)[i][j] = 0;
  }
} 

//вывод найденной расстановки в файл
void Destruction(int n, int **x){ 
  FILE *f;
  if( ( f = fopen("out.txt","w") ) == NULL ){
    printf("Файл out.txt не может быть открыт для записи");
  }
    else{
      fprintf(f,"%d\n",n);
      for (int i = 0 ; i &lt; n; i++ ){
        for (int j = 0 ; j &lt; n ; j++ )
          fprintf(f,"%2d",x[i][j]);
        fprintf(f,"\n");
      }
    }
  for (int i = 0 ; i &lt; n; i++ )
    delete [] x[i];
  delete [] x;
} 

//проверка возможности постановки ферзя
bool Queen(int n, int **x){
  bool rez = false;
  int *p, *h, *du, *dd;
  p = new int[n];
  h = new int[n];
  du = new int[2 * n - 1];
  dd = new int[2 * n - 1];
  for ( int i = 0 ; i &lt; n ; i++ )
    p[i] = h[i] = 0;
  for ( int i = 0 ; i &lt; (2 * n - 1) ; i++ )
    du[i] = dd[i] = 0;
  Placement(n,x,p,h,du,dd);
  if ( h[0] != 0 ) rez = true;
  delete [] dd, du, h, p;
  return rez;
}

//описание функции расстановки ферзей
void Placement(int n, int **a, int *p, int *h, int *du, 
               int *dd, int i, int j){
  if ( j &gt;= 0 &amp;&amp; j &lt; n )
    if ( i &lt; n )
      if (h[i]==0 &amp;&amp; du[i+j] == 0 &amp;&amp; dd[n+i-j-1] == 0 ) {
        h[i] = 1;
        du[i+j] = 1;
        dd[n+i-j-1] = 1;
        p[j] = i;
        a[i][j] = 1;
        Placement(n,a,p,h,du,dd,0,j+1);
      }
      else
        Placement(n,a,p,h,du,dd,i+1,j);
    else
      if ( j &gt; 0 ) {
        h[p[j-1]] = 0;
        du[p[j-1]+j-1] = 0;
        dd[n+p[j-1]-(j-1)-1] = 0;
        a[p[j-1]][j-1] = 0;
        Placement(n,a,p,h,du,dd,p[j-1]+1,j-1);
      }
}
</PRE><SPAN class=objectName>Листинг . </SPAN></DIV>
            <P id=id_136><SPAN class=xml_em_italic>Пример 2. Задача о количестве 
            расстановок ферзей на шахматной доске.</SPAN></P>
            <DIV id=mark_136 class=lecture_mark></DIV>
            <P id=id_137>Составить рекурсивную функцию, находящую количество 
            возможных расстановок n ферзей на шахматной доске размером <SPAN 
            class=texample>n&#215;n</SPAN> так, чтобы они не били друг друга.</P>
            <DIV id=mark_137 class=lecture_mark></DIV>
            <P id=id_139>Предложенную задачу можно решать по приведенным в <SPAN 
            class=xml_em_italic>Примере 1</SPAN> функциям, упростив их следующим 
            образом. Вместо запоминания найденных решений будем подсчитывать в 
            переменной <SPAN class=texample>otv</SPAN> их количество.</P>
            <DIV id=mark_139 class=lecture_mark></DIV>
            <P id=id_141><SPAN class=xml_em_italic>Пример 3. Задача об основных 
            расстановках.</SPAN></P>
            <DIV id=mark_141 class=lecture_mark></DIV>
            <P id=id_142>Для формулировки следующей задачи введем понятие. Среди 
            всех расстановок <SPAN class=texample>n</SPAN> ферзей на доске <SPAN 
            class=texample>n&#215;n</SPAN> выделим отдельные непересекающиеся классы 
            <SPAN class=texample>H<SUB>s</SUB> (s=0,1,...,q)</SPAN> расстановок 
            так, что все элементы данного класса можно получить из любого его 
            представителя какими-либо <SPAN class=xml_em_italic>элементарными 
            преобразованиями</SPAN> типа:</P>
            <DIV id=mark_142 class=lecture_mark></DIV>
            <UL id=id_146>
              <LI>поворот доски в ее плоскости вокруг центра на 90°, 180° и 
270°;
              <LI>преобразования симметрии относительно диагоналей;
              <LI>преобразования симметрии относительно прямых, проходящих через 
              центр доски по границам клеток.</LI></UL>
            <DIV id=mark_146 class=lecture_mark></DIV>
            <P id=id_150>Взяв по одному представителю из каждого класса <SPAN 
            class=texample>H<SUB>s</SUB> (s=0,1,...,q)</SPAN>, получим некоторое 
            множество, называемое <SPAN class=xml_em_italic>основными</SPAN> 
            расстановками. Составить рекурсивную функцию, находящую какое-либо 
            множество основных расстановок <SPAN class=texample>n</SPAN> ферзей 
            на шахматной доске размера <SPAN class=texample>n&#215;n</SPAN>.</P>
            <DIV id=mark_150 class=lecture_mark></DIV>
            <P id=id_154>Эта задача решается с помощью рекурсивных функций 
            практически аналогично задаче из <SPAN class=xml_em_italic>Примера 
            1</SPAN>. Отличия здесь такие. Рекурсивная функция последовательно 
            формирует каждую из возможных расстановок ферзей на доске, но не все 
            из них запоминаются в матрице ответа <SPAN 
            class=texample>otv</SPAN>. Очередная полученная расстановка 
            подвергается проверке - включать или не включать ее в матрицу <SPAN 
            class=texample>otv</SPAN>. Делается это следующим образом. Из 
            вектора pos описанными выше элементарными преобразованиями 
            формируются еще семь расстановок (некоторые из них могут оказаться 
            совпадающими). Если ни одна из них не входит в текущую матрицу 
            ответов <SPAN class=texample>otv</SPAN>, то <SPAN 
            class=texample>otv</SPAN> дополняется новым решением и так далее. 
            Следовательно, по завершении вычислений <SPAN 
            class=texample>otv</SPAN> будет содержать некоторое множество 
            основных расстановок.</P>
            <DIV id=mark_154 class=lecture_mark></DIV><A name=sect3></A>
            <H3>Ключевые термины</H3>
            <P id=id_160><B>Возвратная рекурсия</B> – это соединение метода 
            перебора с возвратом и рекурсии.</P>
            <DIV id=mark_160 class=lecture_mark></DIV>
            <P id=id_161><B>Детерминированный алгоритм</B> – это алгоритм, 
            который однозначно осуществит выбор конкретной альтернативы и 
            продолжит работать в соответствии с эти выбором.</P>
            <DIV id=mark_161 class=lecture_mark></DIV>
            <P id=id_162><B>Исчерпывающий поиск</B> – это процесс нахождения в 
            некотором множестве всех возможных вариантов, среди которых имеется 
            решение конкретной задачи. </P>
            <DIV id=mark_162 class=lecture_mark></DIV>
            <P id=id_163><B>Метод решета</B> – это один из методов организации 
            исчерпывающего поиска, при котором из множества возможных вариантов 
            исключаются все элементы, не являющиеся решениями.</P>
            <DIV id=mark_163 class=lecture_mark></DIV>
            <P id=id_164><B>Недетерминированный алгоритм</B> – это алгоритм, 
            который исследует все возможности одновременно, как бы копируя себя 
            для реализации вычислений по всем альтернативам одновременно.</P>
            <DIV id=mark_164 class=lecture_mark></DIV>
            <P id=id_165><B>Перебор с возвратом (backtracking)</B> – это один из 
            методов организации исчерпывающего поиска, который строится 
            конструктивно последовательным расширением частичного решения.</P>
            <DIV id=mark_165 class=lecture_mark></DIV>
            <P id=id_166><B>Полное решение</B> – это набор вариантов, образующий 
            хотя бы одно решение в целом.</P>
            <DIV id=mark_166 class=lecture_mark></DIV>
            <P id=id_167><B>Частичное решение</B> – это неполный набор 
            вариантов, который входит в одно или несколько полных решений.</P>
            <DIV id=mark_167 class=lecture_mark></DIV><A name=sect4></A>
            <H3>Краткие итоги</H3>
            <OL id=id_168>
              <LI>Решение переборных задач сводится к определению наличия 
              решения, всех различных вариантов решения или к нахождению одного 
              решения.
              <LI>В зависимости от постановки задачи переборные алгоритмы 
              реализуются методами перебора с возвратом или методом решета.
              <LI>Возвратная рекурсия – это соединение метода перебора с 
              возвратом и рекурсии.
              <LI>Детерминированный алгоритм однозначно осуществит выбор 
              конкретной альтернативы и продолжит работать в соответствии с эти 
              выбором. Недетерминированный алгоритм исследует все возможности 
              одновременно, как бы копируя себя для реализации вычислений по 
              всем альтернативам одновременно.
              <LI>Для решения задачи о расстановке ферзей на шахматной доске как 
              альтернативный используется метод возвратной рекурсии.
              <LI>При разработке триады для решения задачи о расстановке ферзей 
              вводятся дополнительные параметры при описании процесса 
              расстановки.
              <LI>Базой в данной задаче считается совокупность всех тупиковых 
              ситуаций.
              <LI>Декомпозиция проводится от частичного к полному решению или к 
              снятию ферзя с вертикали (возврат).</LI></OL>
            <DIV id=mark_168 class=lecture_mark></DIV><A name=sect5></A>
            <H3>Лабораторная работа 36. Алгоритм перебора с возвратом</H3>
            <P id=id_177><B>Цель работы:</B> изучить рекурсивный алгоритм 
            перебора с возвратом, научиться разрабатывать рекурсивную триаду и 
            алгоритм перебора с возвратом при решении задач на языке C++.</P>
            <DIV id=mark_177 class=lecture_mark></DIV>
            <P id=id_178>При выполнении лабораторной работы для каждого задания 
            требуется написать программу на языке С++, которая получает на входе 
            числовые данные, выполняет их обработку в соответствии с 
            требованиями задания и выводит результат на экран. Для обработки 
            данных необходимо реализовать рекурсивную функцию алгоритма перебора 
            с возвратом. Ввод данных осуществляется с клавиатуры или из файла с 
            учетом требований к входным данным, содержащихся в постановке 
            задачи. Ограничениями на входные данные является допустимый диапазон 
            значений используемых числовых типов в языке С++.</P>
            <DIV id=mark_178 class=lecture_mark></DIV>
            <P id=id_179><B>Теоретические сведения.</B></P>
            <DIV id=mark_179 class=lecture_mark></DIV>
            <P id=id_180>Ознакомьтесь с материалом лекции 36.</P>
            <DIV id=mark_180 class=lecture_mark></DIV>
            <P id=id_181><B>Задания к лабораторной работе.</B></P>
            <DIV id=mark_181 class=lecture_mark></DIV>
            <P id=id_182>Выполните приведенные ниже задания.</P>
            <DIV id=mark_182 class=lecture_mark></DIV>
            <OL id=id_183>
              <LI>На основе описания из <SPAN class=xml_em_italic>Примера 
              1</SPAN> лекции 36 решите задачу о нахождении всех расстановок 
              <SPAN class=texample>n</SPAN> ферзей на шахматной доске размером 
              <SPAN class=texample>n&#215;n</SPAN>.
              <LI>Найдите количество всех расстановок ферзей на шахматной доске 
              размером <SPAN class=texample>n&#215;n</SPAN>.
              <LI>Найдите все основные расстановки ферзей на шахматной доске 
              размером <SPAN class=texample>n&#215;n</SPAN>.
              <LI>Решите задачу о рюкзаке. Имеется <SPAN class=texample>n</SPAN> 
              предметов, пронумерованных числами от 0 до <SPAN 
              class=texample>n-1</SPAN>, для каждого из которых известен набор 
              масс <SPAN class=texample>m<SUB>0</SUB>,...,m<SUB>n-1</SUB></SPAN> 
              и набор стоимостей <SPAN 
              class=texample>s<SUB>0</SUB>,...,s<SUB>n-1</SUB></SPAN>. 
              Определите, какой набор предметов необходимо положить в рюкзак, 
              чтобы его масса не превышала <SPAN class=texample>Q</SPAN>, а 
              стоимость предметов была бы наибольшей.</LI></OL>
            <DIV id=mark_183 class=lecture_mark></DIV>
            <P id=id_197><B>Указания к выполнению работы</B>.</P>
            <DIV id=mark_197 class=lecture_mark></DIV>
            <P id=id_198>Каждое задание необходимо решить в соответствии с 
            изученным рекурсивным алгоритмом перебора с возвратом, реализовав 
            программный код на языке С++. Перед реализацией кода каждой задачи 
            необходимо разработать рекурсивную триаду в соответствии с 
            постановкой задачи: выполнить параметризацию, выделить базу и 
            оформить декомпозицию рекурсии. Рекомендуется воспользоваться 
            материалами лекции 36, где подробно рассматриваются описание метода 
            перебора с возвратом, примеры разработки рекурсивной триады и 
            обоснование декомпозиции. Этапы рекурсивной триады необходимо 
            отразить в математической модели к отчету, выполнив обоснование 
            декомпозиции. Программу для решения каждого задания необходимо 
            разработать методом процедурной абстракции, используя рекурсивные 
            функции. Этапы сопроводить комментариями в коде. В отчете следует 
            отразить результаты тестирования программ.</P>
            <DIV id=mark_198 class=lecture_mark></DIV>
            <P id=id_199>Следует реализовать каждое задание в соответствии с 
            приведенными этапами:</P>
            <DIV id=mark_199 class=lecture_mark></DIV>
            <UL id=id_200>
              <LI>изучить словесную постановку задачи, выделив при этом все виды 
              данных;
              <LI>сформулировать математическую постановку задачи;
              <LI>выбрать метод решения задачи, если это необходимо;
              <LI>разработать графическую схему алгоритма;
              <LI>записать разработанный алгоритм на языке С++;
              <LI>разработать контрольный тест к программе;
              <LI>отладить программу;
              <LI>представить отчет по работе.</LI></UL>
            <DIV id=mark_200 class=lecture_mark></DIV>
            <P id=id_209><B>Требования к отчету.</B></P>
            <DIV id=mark_209 class=lecture_mark></DIV>
            <P id=id_210>Отчет по лабораторной работе должен соответствовать 
            следующей структуре.</P>
            <DIV id=mark_210 class=lecture_mark></DIV>
            <UL id=id_211>
              <LI>Титульный лист.
              <LI>Словесная постановка задачи. В этом подразделе проводится 
              полное описание задачи. Описывается суть задачи, анализ входящих в 
              нее физических величин, область их допустимых значений, единицы их 
              измерения, возможные ограничения, анализ условий при которых 
              задача имеет решение (не имеет решения), анализ ожидаемых 
              результатов.
              <LI>Математическая модель. В этом подразделе вводятся 
              математические описания физических величин и математическое 
              описание их взаимодействий. Цель подраздела – представить решаемую 
              задачу в математической формулировке.
              <LI>Алгоритм решения задачи. В подразделе описывается разработка 
              структуры алгоритма, обосновывается абстракция данных, задача 
              разбивается на подзадачи. Схема алгоритма выполняется по ЕСПД 
              (ГОСТ 19.003-80 и ГОСТ 19.002-80).
              <LI>Листинг программы. Подраздел должен содержать текст программы 
              на языке программирования С++, реализованный в среде MS Visual 
              Studio 2010.
              <LI>Контрольный тест. Подраздел содержит наборы исходных данных и 
              полученные в ходе выполнения программы результаты.
              <LI>Выводы по лабораторной работе. 
              <LI>Ответы на контрольные вопросы.</LI></UL>
            <DIV id=mark_211 class=lecture_mark></DIV>
            <P id=id_220><B>Контрольные вопросы</B></P>
            <DIV id=mark_220 class=lecture_mark></DIV>
            <OL id=id_221>
              <LI>В чем проявляется рекурсивность метода перебора с возвратом?
              <LI>Почему полный метод перебора с возвратом гарантирует отыскание 
              всех решений задачи?
              <LI>Как формируется рекурсивная база метода возвратной рекурсии?
              <LI>Какие классы задач сводятся к разработке детерминированных 
              алгоритмов, а какие – к недетерминированным? Поясните примерами.
              <LI>Поясните, почему данные описания характеризуют описание 
              действий над ферзем в контексте модели шахматной доски: 
              <UL id=id_227>
                <LI>В позицию <SPAN class=texample>(i,j)</SPAN> можно поставить 
                ферзь, если <SPAN 
                class=texample>ho<SUB>i</SUB>+du<SUB>i+j</SUB>+dd<SUB>n+i-j</SUB>=0</SPAN>.
                <LI>Поставить ферзь в позицию <SPAN class=texample>(i,j)</SPAN> 
                равносильно присваиваниям: <SPAN 
                class=texample>ho<SUB>i</SUB>=1, du<SUB>i+j</SUB>=1, 
                dd<SUB>n+i-j</SUB>=1</SPAN>.
                <LI>Убрать ферзь из позиции <SPAN class=texample>(i,j)</SPAN> 
                равносильно присваиваниям: <SPAN 
                class=texample>ho<SUB>i</SUB>=0, du<SUB>i+j</SUB>=0, 
                dd<SUB>n+i-j</SUB>=0</SPAN>.</LI></UL>
              <DIV id=mark_227 class=lecture_mark></DIV></LI></OL>
            <DIV id=mark_221 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript 
src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/urchin.js">
</SCRIPT>

<SCRIPT 
type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
