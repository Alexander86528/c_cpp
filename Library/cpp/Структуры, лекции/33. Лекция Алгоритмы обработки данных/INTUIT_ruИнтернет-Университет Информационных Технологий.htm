<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0071)http://www.intuit.ru/department/algorithms/staldata/33/staldata_33.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/printable.css">
<META name=GENERATOR content="MSHTML 9.00.8080.16413"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="COLOR: #000000; FONT-WEIGHT: bold">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD>
    <TD><!-- content -->
      <TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD class=head>Структуры и алгоритмы компьютерной обработки 
        данных</TD></TR>
        <TR>
          <TD height=4><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>33. Лекция: Алгоритмы обработки данных: 
            версия для печати и PDA</SPAN> <BR><SPAN class=rtxt>В лекции 
            рассматриваются понятие ресурсной эффективности алгоритмов 
            посредством анализа асимптотических функций временной и емкостной 
            сложности, приводится классификация алгоритмов на основе функции 
            временной сложности, рассматриваются общие методы оценки 
            трудоемкости алгоритмов. </SPAN></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3></H3>
            <P id=id_1><B>Цель лекции:</B> изучить понятие и классификации 
            алгоритмов обработки данных, трудоемкости алгоритмов и методов ее 
            оценки, научиться выработке критериев и оценке трудоемкости 
            алгоритмов с учетом критериев на примере реализаций и задач на языке 
            C++.</P>
            <DIV id=mark_1 class=lecture_mark></DIV>
            <P id=id_2>Понятие <SPAN class=xml_em_italic>"алгоритм обработки 
            данных"</SPAN> в компьютерных науках используется для описания 
            метода решения задачи, который в дальнейшем возможно реализовать в 
            выбранной среде программирования. Тщательная разработка алгоритма 
            является весьма эффективной частью процесса решения задачи в любой 
            области применения. При разработке алгоритма для реальной задачи 
            значительные усилия должны быть потрачены на осознание степени ее 
            сложности, выяснение ограничений на входные данные, разбиение задачи 
            на менее трудоемкие подзадачи.</P>
            <DIV id=mark_2 class=lecture_mark></DIV>
            <P id=id_3>Алгоритм не должен быть привязан к конкретной реализации. 
            В силу разнообразия используемых средств программирования, их 
            требований к аппаратным ресурсам и платформенной зависимости сходные 
            по структуре, но различные в реализации, алгоритмы могут выдавать 
            отличающиеся по эффективности результаты. При этом некоторые среды 
            программирования содержат встроенные библиотечные функции, 
            реализующие базовые алгоритмы обработки данных (например, в MS 
            Visual Studio 2010 в библиотеки С++ входит функция быстрой 
            сортировки массивов данных). Чтобы решения были переносимыми и 
            оставались актуальными, не рекомендуется их ориентировать на 
            процедурную реализацию среды. Поэтому главным в рассматриваемом 
            подходе является выбор метода решения с учетом специфики задачи. 
            Адаптация к среде осуществляется позднее.</P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <P id=id_4>Выбор того или иного метода обработки данных определяется 
            не только сложностью задачи. Учитывать необходимо и массовость 
            применения разработанного кода: при однократном или редком обращении 
            к реализации предпочтительнее бывают простые алгоритмы, которые 
            несложны в разработке. При этом, однако, допускается возможным 
            увеличение времени работы программы.</P>
            <DIV id=mark_4 class=lecture_mark></DIV>
            <P id=id_5>Массовое использование алгоритмов обработки данных 
            требует поиска наилучшего алгоритма решения. Такой процесс бывает 
            весьма сложен, так как требует выработки критериев оценки и 
            применения математических методов для получения количественных 
            характеристик. Направление компьютерных наук, занимающееся изучением 
            оценки эффективности алгоритмов, называется <SPAN 
            class=xml_em_italic>анализом алгоритмов</SPAN>.</P>
            <DIV id=mark_5 class=lecture_mark></DIV><A name=sect2></A>
            <H3>Ресурсная эффективность алгоритмов</H3>
            <P id=id_6>Определение ресурсной эффективности алгоритмов – 
            необходимая составляющая этапа анализа разработанного программного 
            обеспечения. Повышение ресурсной эффективности вычислительных 
            алгоритмов актуально при обработке больших объемов данных, когда 
            аппаратных и/или программных ресурсов может быть недостаточно для 
            корректного завершения работы программного кода.</P>
            <DIV id=mark_6 class=lecture_mark></DIV>
            <P id=id_7>Наиболее значимыми характеристиками ресурсной 
            эффективности алгоритмов являются оценки временной и емкостной 
            сложности, отражающие ресурсы процессора, оперативной памяти, а 
            также внешних носителей данных (при использовании).</P>
            <DIV id=mark_7 class=lecture_mark></DIV>
            <P id=id_8>Под <B>трудоемкостью алгоритма</B> <SPAN 
            class=texample>А</SPAN> на входе <SPAN class=texample>D</SPAN> будем 
            понимать количество элементарных операций, которые учитываются при 
            анализе алгоритма. Под <SPAN class=xml_em_italic>худшим 
            случаем</SPAN> трудоемкости понимают наибольшее количество операций, 
            задаваемых алгоритмом <SPAN class=texample>А</SPAN> на всех входах 
            <SPAN class=texample>D</SPAN> определенной размерности <SPAN 
            class=texample>n</SPAN>. Определим <SPAN class=xml_em_italic>лучший 
            случай</SPAN> трудоемкости, как наименьшее количество операций в 
            аналогичном алгоритме и при той же размерности входа. <SPAN 
            class=xml_em_italic>Средний случай</SPAN> трудоемкости определяется 
            средним количеством операций рассматриваемого алгоритма и входных 
            данных. Зависимость трудоемкости алгоритма <SPAN 
            class=texample>А</SPAN> от значения параметров на входе <SPAN 
            class=texample>D</SPAN> определяет <SPAN class=xml_em_italic>функцию 
            трудоемкости алгоритма</SPAN> <SPAN class=texample>А</SPAN> для 
            входа <SPAN class=texample>D</SPAN>.</P>
            <DIV id=mark_8 class=lecture_mark></DIV>
            <P id=id_18>Классический анализ алгоритмов в данном контексте 
            связан, прежде всего, с оценкой временной сложности. Большинство 
            алгоритмов имеют основной параметр, который в значительной степени 
            влияет на время выполнения операций. Если же определяющих параметров 
            несколько, то, как правило, один их них выражается как функция от 
            остальных. Иногда используют и такой подход: рассматривают только 
            один параметр, считая остальные константами.</P>
            <DIV id=mark_18 class=lecture_mark></DIV>
            <P id=id_19>Результатом анализа является <SPAN 
            class=xml_em_italic>асимптотическая оценка</SPAN> выполняемых 
            алгоритмом операций в зависимости от длины входа, которая указывает 
            порядок роста функции и результаты сравнения работы алгоритмов для 
            больших данных. При этом оценка на реальных данных отличается от 
            асимптотической тем, что она ориентирована на конкретные длины 
            входов и число выполняемых алгоритмом операций. </P>
            <DIV id=mark_19 class=lecture_mark></DIV>
            <P id=id_20><SPAN class=xml_em_italic>Временная сложность 
            алгоритма</SPAN> определяется асимптотической оценкой функции 
            трудоемкости алгоритма для худшего случая, обозначается <SPAN 
            class=texample>O(f(n))</SPAN> и читается как "О большое" или 
            "О-нотация". Асимптотический класс функций <SPAN 
            class=texample>О</SPAN> включает в себя как средний, так и лучший 
            случай, потому что запись <SPAN class=texample>O(f(n))</SPAN> 
            обозначает класс функций, скорость роста которых не более, чем <SPAN 
            class=texample>f(n)</SPAN> с точностью до некоторой положительной 
            константы. В зависимости от вида функции <SPAN 
            class=texample>f(n)</SPAN> выделяют следующие классы сложности 
            алгоритмов.</P>
            <DIV id=mark_20 class=lecture_mark></DIV>
            <DIV id=id_26 class=xml_table_env><A></A>
            <TABLE class=xml_table border=0 cellSpacing=1 cellPadding=2>
              <CAPTION>Классы сложности алгоритмов в зависимости от функции 
              трудоемкости</CAPTION>
              <TBODY>
              <TR>
                <TH bgColor=#d8d8d8>Вид <SPAN class=texample>f(n)</SPAN></TH>
                <TH bgColor=#d8d8d8>Характеристика класса алгоритмов</TH></TR>
              <TR>
                <TD bgColor=#eaeaea vAlign=top><SPAN 
class=texample>1</SPAN></TD>
                <TD bgColor=#eaeaea vAlign=top>Большинство инструкций 
                  большинства функций запускается один или несколько раз. Если 
                  все инструкции программы обладают таким свойством, то время 
                  выполнения программы <SPAN 
                  class=xml_em_italic>постоянно</SPAN>.</TD></TR>
              <TR>
                <TD bgColor=#eaeaea vAlign=top><SPAN 
                  class=texample>log&nbsp;N</SPAN></TD>
                <TD bgColor=#eaeaea vAlign=top>Когда время выполнения 
                  программы является <SPAN 
                  class=xml_em_italic>логарифмическим</SPAN>, программа 
                  становится медленнее с ростом <SPAN class=texample>N</SPAN>. 
                  Такое время выполнения обычно присуще программам, которые 
                  сводят большую задачу к набору меньших подзадач, уменьшая на 
                  каждом шаге размер задачи на некоторый постоянный фактор. 
                  Будем рассматривать время выполнения, являющееся небольшой по 
                  величине константой. Изменение основания не сильно сказывается 
                  на изменении значения логарифма: при <SPAN class=texample>N=1 
                  000, log N = 3</SPAN>, если основание равно 10, или порядка 
                  10, если основание равно 2; когда <SPAN class=texample>N=1 000 
                  000</SPAN>, значения <SPAN class=texample>log N</SPAN> 
                  увеличивается в два раза. При удвоении значения параметра 
                  <SPAN class=texample>log N</SPAN> растет на постоянную 
                  величину, а удваивается лишь тогда, когда <SPAN 
                  class=texample>N</SPAN> достигает <SPAN 
                  class=texample>N<SUP>2</SUP></SPAN>.</TD></TR>
              <TR>
                <TD bgColor=#eaeaea vAlign=top><SPAN 
class=texample>N</SPAN></TD>
                <TD bgColor=#eaeaea vAlign=top>Когда время выполнения 
                  программы является <SPAN class=xml_em_italic>линейным</SPAN>, 
                  это обычно значит, что каждый входной элемент подвергается 
                  небольшой обработке. Когда <SPAN class=texample>N</SPAN> равно 
                  миллиону, таким же и является время выполнения. Когда <SPAN 
                  class=texample>N</SPAN> удваивается, то же происходит и со 
                  временем выполнения. Эта ситуация оптимальна для алгоритма, 
                  который должен обработать <SPAN class=texample>N</SPAN> вводов 
                  (или произвести <SPAN class=texample>N</SPAN> выводов).</TD></TR>
              <TR>
                <TD bgColor=#eaeaea vAlign=top><SPAN 
                  class=texample>N&nbsp;log&nbsp;N</SPAN></TD>
                <TD bgColor=#eaeaea vAlign=top>Время выполнения, 
                  пропорциональное <SPAN class=texample>N log N</SPAN>, 
                  возникает тогда, когда алгоритм решает задачу, разбивая ее на 
                  меньшие подзадачи, решая их независимо и затем объединяя 
                  решения. Время выполнения такого алгоритма равно <SPAN 
                  class=texample>N log N</SPAN>. Когда <SPAN class=texample>N=1 
                  000 000</SPAN>, <SPAN class=texample>N log N &#8776; 20 000 
                  000</SPAN>. Когда <SPAN class=texample>N</SPAN> удваивается, 
                  тогда время выполнения более чем удваивается. </TD></TR>
              <TR>
                <TD bgColor=#eaeaea vAlign=top><SPAN 
                  class=texample>N<SUP>2</SUP></SPAN></TD>
                <TD bgColor=#eaeaea vAlign=top>Когда время выполнения 
                  алгоритма является <SPAN 
                  class=xml_em_italic>квадратичным</SPAN>, он полезен для 
                  практического использования при решении относительно небольших 
                  задач. Квадратичное время выполнения обычно появляется в 
                  алгоритмах, которые обрабатывают все пары элементов данных 
                  (возможно, в цикле двойного уровня вложенности). Когда <SPAN 
                  class=texample>N=1 000</SPAN>, время выполнения равно одному 
                  миллиону. Когда <SPAN class=texample>N</SPAN> удваивается, 
                  время выполнения увеличивается вчетверо.</TD></TR>
              <TR>
                <TD bgColor=#eaeaea vAlign=top><SPAN 
                  class=texample>N<SUP>3</SUP></SPAN></TD>
                <TD bgColor=#eaeaea vAlign=top>Похожий алгоритм, который 
                  обрабатывает тройки элементов данных (возможно, в цикле 
                  тройного уровня вложенности), имеет <SPAN 
                  class=xml_em_italic>кубическое</SPAN> время выполнения и 
                  практически применим лишь для малых задач. Когда <SPAN 
                  class=texample>N=100</SPAN>, время выполнения равно одному 
                  миллиону. Когда <SPAN class=texample>N</SPAN> удваивается, 
                  время выполнения увеличивается в восемь раз.</TD></TR>
              <TR>
                <TD bgColor=#eaeaea vAlign=top><SPAN 
                  class=texample>2<SUP>N</SUP></SPAN></TD>
                <TD bgColor=#eaeaea vAlign=top>Лишь несколько алгоритмов с 
                  <SPAN class=xml_em_italic>экспоненциальным</SPAN> временем 
                  выполнения имеет практическое применение, хотя такие алгоритмы 
                  возникают естественным образом при попытках прямого решения 
                  задачи, например полного перебора. Когда <SPAN 
                  class=texample>N=20</SPAN>, время выполнения имеет порядок 
                  одного миллиона. Когда <SPAN class=texample>N</SPAN> 
                  удваивается, время выполнения увеличивается 
              экспоненциально.</TD></TR></TBODY></TABLE></DIV>
            <DIV id=mark_26 class=lecture_mark></DIV>
            <P id=id_57>На основании математических методов исследования 
            асимптотических функций трудоемкости на бесконечности выделены пять 
            классов алгоритмов.</P>
            <DIV id=mark_57 class=lecture_mark></DIV>
            <P id=id_58><SPAN class=xml_em_italic>Класс <IMG 
            style="POSITION: relative; TOP: 2px" border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/pi.gif" 
            width=8 height=18>0</SPAN> – это класс быстрых алгоритмов с 
            постоянным временем выполнения, их функция трудоемкости <SPAN 
            class=texample>O(1)</SPAN>. Промежуточное состояние занимают 
            алгоритмы со сложностью <SPAN class=texample>O(log N)</SPAN>, 
            которые также относят к данному классу.</P>
            <DIV id=mark_58 class=lecture_mark></DIV>
            <P id=id_61><SPAN class=xml_em_italic>Класс <IMG 
            style="POSITION: relative; TOP: 2px" border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/pi.gif" 
            width=8 height=18>Р</SPAN> – это класс рациональных или 
            полиномиальных алгоритмов, функция трудоемкости которых определяется 
            полиномиально от входных параметров. Например, <SPAN 
            class=texample>O(N), O(N<SUP>2</SUP>, O(N<SUP>3</SUP>)</SPAN>.</P>
            <DIV id=mark_61 class=lecture_mark></DIV>
            <P id=id_63><SPAN class=xml_em_italic>Класс <IMG 
            style="POSITION: relative; TOP: 2px" border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/pi.gif" 
            width=8 height=18>L</SPAN> – это класс субэкспоненциальных 
            алгоритмов со степенью трудоемкости <SPAN 
            class=texample>O(N&nbsp;log&nbsp;N)</SPAN>.</P>
            <DIV id=mark_63 class=lecture_mark></DIV>
            <P id=id_65><SPAN class=xml_em_italic>Класс <IMG 
            style="POSITION: relative; TOP: 2px" border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/pi.gif" 
            width=8 height=18>E</SPAN> – это класс собственно экспоненциальных 
            алгоритмов со степенью трудоемкости <SPAN 
            class=texample>O(2<SUP>N</SUP></SPAN>.</P>
            <DIV id=mark_65 class=lecture_mark></DIV>
            <P id=id_67><SPAN class=xml_em_italic>Класс <IMG 
            style="POSITION: relative; TOP: 2px" border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/pi.gif" 
            width=8 height=18>F</SPAN> – это класс собственно 
            надэкспоненциальных алгоритмов. Существуют алгоритмы с факториальной 
            трудоемкостью, но они в основном не имеют практического 
            применения.</P>
            <DIV id=mark_67 class=lecture_mark></DIV>
            <P id=id_68>Состояние памяти при выполнении алгоритма определяется 
            значениями, требующими для размещения определенных участков. При 
            этом в ходе решения задачи может быть задействовано дополнительное 
            количество ячеек. Под <SPAN class=xml_em_italic>объемом 
            памяти</SPAN>, требуемым алгоритмом <SPAN class=texample>А</SPAN> 
            для входа <SPAN class=texample>D</SPAN>, понимаем максимальное 
            количество ячеек памяти, задействованных в ходе выполнения 
            алгоритма. <SPAN class=xml_em_italic>Емкостная сложность 
            алгоритма</SPAN> определяется как асимптотическая оценка функции 
            объема памяти алгоритма для худшего случая.</P>
            <DIV id=mark_68 class=lecture_mark></DIV>
            <P id=id_71>Таким образом, <SPAN class=xml_em_italic>ресурсная 
            сложность алгоритма</SPAN> в худшем, среднем и лучшем случаях 
            определяется как упорядоченная пара классов функций временной и 
            емкостной сложности, заданных асимптотическими обозначениями и 
            соответствующих рассматриваемому случаю.</P>
            <DIV id=mark_71 class=lecture_mark></DIV><A name=sect3></A>
            <H3>Методы оценки ресурсной эффективности алгоритмов</H3>
            <P id=id_72>Основными алгоритмическими конструкциями в процедурном 
            программировании являются следование, ветвление и цикл. Для 
            получения функций трудоемкости для лучшего, среднего и худшего 
            случаев при фиксированной размерности входа необходимо учесть 
            различия в оценке основных алгоритмических конструкций.</P>
            <DIV id=mark_72 class=lecture_mark></DIV>
            <UL id=id_73>
              <LI>Трудоемкость конструкции <SPAN 
              class=xml_em_italic>"Следование"</SPAN> есть сума трудоемкостей 
              блоков, следующих друг за другом: <SPAN 
              class=texample>f=f<SUB>1</SUB>+f<SUB>2</SUB>+...+f<SUB>n</SUB></SPAN>.
              <LI>Трудоемкость конструкции <SPAN 
              class=xml_em_italic>"Ветвление"</SPAN> определяется через 
              вероятность перехода к каждой из инструкций, определяемой 
              условием. При этом проверка условия также имеет определенную 
              трудоемкость. Для вычисления трудоемкости худшего случая может 
              быть выбран тот блок ветвления, который имеет большую 
              трудоемкость, для лучшего случая – блок с меньшей трудоемкостью. 
              <SPAN 
              class=texample>f<SUB>if</SUB>=f<SUB>1</SUB>+f<SUB>then</SUB>·p<SUB>then</SUB>+f<SUB>else</SUB>·(1-p<SUB>then</SUB>)</SPAN>
              <LI>Трудоемкость конструкции <SPAN 
              class=xml_em_italic>"Цикл"</SPAN> зависит от вида цикла. Для цикла 
              с параметрами будет справедливой формула: <SPAN 
              class=texample>f<SUB>for</SUB>=1+3n+nf</SPAN>, где <SPAN 
              class=texample>n</SPAN> – количество повторений тела цикла, <SPAN 
              class=texample>f</SPAN> – трудоемкость тела цикла. 
              <P id=id_82>Реализация цикла с предусловием и с постусловием не 
              меняет методики оценки его трудоемкости. На каждом проходе 
              выполняется оценка трудоемкости условия, изменения параметров (при 
              наличии) и тела цикла. Общие рекомендации для оценки циклов с 
              условиями затруднительны. Так как в значительной степени зависят 
              от исходных данных.</P>
              <DIV id=mark_82 class=lecture_mark></DIV>
              <LI>В случае использования вложенных циклов их трудоемкости 
              перемножаются.</LI></UL>
            <DIV id=mark_73 class=lecture_mark></DIV>
            <P id=id_84>Таким образом, для оценки трудоемкости алгоритма может 
            быть сформулирован общий метод получения функции трудоемкости.</P>
            <DIV id=mark_84 class=lecture_mark></DIV>
            <OL id=id_85>
              <LI>Декомпозиция алгоритма предполагает выделение в алгоритме 
              базовых конструкций и оценку и трудоемкости. При этом 
              рассматривается следование основных алгоритмических конструкций. 
              <LI>Построчный анализ трудоемкости по базовым операциям языка 
              подразумевает либо совокупный анализ (учет всех операций), либо 
              пооперационный анализ (учет трудоемкости каждой операции).
              <LI>Обратная композиция функции трудоемкости на основе методики 
              анализа базовых алгоритмических конструкций для лучшего, среднего 
              и худшего случаев.</LI></OL>
            <DIV id=mark_85 class=lecture_mark></DIV>
            <P id=id_89>Особенностью оценки ресурсной эффективности рекурсивных 
            алгоритмов является необходимость учета дополнительных затрат памяти 
            и механизма организации рекурсии. Поэтому трудоемкость рекурсивных 
            реализаций алгоритмов связана с количеством операций, выполняемых 
            при оном рекурсивном вызове, а также с количеством таких вызовов. 
            Учитываются также затраты на возвращения значений и передачу 
            управления в точку вызова. Для анализа трудоемкости механизма 
            рекурсивного вызова-возврата будем учитывать следующие параметры: 
            <SPAN class=texample>p</SPAN> – количество передаваемых фактических 
            параметров, <SPAN class=texample>r</SPAN> – количество сохраняемых в 
            стеке регистров, <SPAN class=texample>k</SPAN> – количество 
            возвращаемых по адресной ссылке значений, <SPAN 
            class=texample>l</SPAN> – количество локальных ячеек функции. Тогда 
            функция трудоемкости на одни вызов-возврат примет вид:</P>
            <DIV id=mark_89 class=lecture_mark></DIV>
            <DIV class=example><PRE>f=2(p+k+r+l+1),
</PRE></DIV>
            <P id=id_95>где дополнительная единица учитывает операции с адресом 
            возврата.</P>
            <DIV id=mark_95 class=lecture_mark></DIV>
            <P id=id_96>Оценка требуемой памяти стека может быть получена 
            следующим образом: так как рекурсивные вызовы обрабатываются 
            последовательно, то в конкретный момент времени в стеке хранится не 
            фрагмент дерева рекурсии, а цепочка рекурсивных вызовов – унарный 
            фрагмент дерева. Поэтому объем стека определяется максимально 
            возможным числом одновременно полученных рекурсивных вызовов.</P>
            <DIV id=mark_96 class=lecture_mark></DIV>
            <P id=id_97>Анализ совокупной трудоемкости рекурсивного алгоритма 
            можно выполнять разными способами в зависимости от формирования 
            итоговой суммы базовых операций: по цепочкам рекурсивных вызовов и 
            возвратов, по вершинам рекурсивного дерева.</P>
            <DIV id=mark_97 class=lecture_mark></DIV>
            <P id=id_98><SPAN class=xml_em_italic>Пример 1</SPAN>. Оценка 
            временной сложности функции пузырьковой сортировки.</P>
            <DIV id=mark_98 class=lecture_mark></DIV>
            <DIV class=example><PRE>//Описание функции сортировки методом "пузырька"
void BubbleSort (int k,int x[max]) {
  int i,j,buf;
  for (i=k-1;i&gt;0;i--)
    for (j=0;j&lt;i;j++)
    if (x[j]&gt;x[j+1]) {
      buf=x[j];
      x[j]=x[j+1];
      x[j+1]=buf;
     }    
}
</PRE></DIV>
            <P id=id_100>Оценим временную сложность функции пузырьковой 
            сортировки в худшем случае, т.е. когда исходные данные отсортированы 
            в обратном порядке. В этом случае внутренний цикл для каждого <SPAN 
            class=texample>i</SPAN> выполнится <SPAN class=texample>i-1</SPAN> 
            раз и произойдет <IMG 
            style="POSITION: relative; DISPLAY: inline; TOP: 7px" 
            alt=\frac{k(k-1)}{2} 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/bd30fdbf9b3c866ddf378c4d9c512d37.png" 
            width=49 height=27> обменов. Соответственно сложность алгоритма в 
            худшем случае составит <SPAN class=texample>O(k<SUP>2</SUP>)</SPAN> 
            обменов.</P>
            <DIV id=mark_100 class=lecture_mark></DIV>
            <P id=id_105>Оценим временную сложность алгоритма пузырьковой 
            сортировки в среднем случае, т.е. когда исходные данные имеют 
            произвольный порядок. В этом случае условие во внутреннем цикле 
            может выполниться <SPAN class=texample>1,2,...,i-1</SPAN> раз. 
            Складывая, получим <IMG 
            style="POSITION: relative; DISPLAY: inline; TOP: 7px" 
            alt=\frac{i(i-1)}{2} 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/ed0fe1a0f57a8656a53ea7e7f924d112.png" 
            width=43 height=27> и, соответственно, условие во внутреннем цикле 
            для каждого <SPAN class=texample>i</SPAN> выполнится в среднем <IMG 
            style="POSITION: relative; DISPLAY: inline; TOP: 7px" 
            alt=\frac{i}{2} 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/cbbcd9ee02033b3f4691f117bb42329f.png" 
            width=13 height=25> раз и произойдет <IMG 
            style="POSITION: relative; DISPLAY: inline; TOP: 7px" 
            alt=\frac{k(k-1)}{4} 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/1de11735e5812062e123c3d80383c933.png" 
            width=49 height=27> обменов. Соответственно сложность алгоритма в 
            среднем случае составит <SPAN 
            class=texample>O(k<SUP>2</SUP>)</SPAN>.</P>
            <DIV id=mark_105 class=lecture_mark></DIV>
            <P id=id_112><SPAN class=xml_em_italic>Пример 2</SPAN>. Оценка 
            временной сложности функции вычисления биномиального коэффициента 
            <IMG style="POSITION: relative; DISPLAY: inline; TOP: 8px" 
            alt="C_n^m=\frac{n!}{m!(n-m)!}(n\geq m)" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/daa294ff4e3472811ec80d751cd19e6f.png" 
            width=190 height=29>.</P>
            <DIV id=mark_112 class=lecture_mark></DIV>
            <DIV class=example><PRE>//Описание функции вычисления биномиального коэффициента
int Binom (int n,int m) {
  if (m==0) return 1; //база рекурсии
  return Binom(n-1,m-1)*n/m; //декомпозиция
}
</PRE></DIV>
            <P id=id_115>Оценим временную сложность функции в худшем случае, 
            т.е. когда <SPAN class=texample>m=n</SPAN>. Будет выполнено (<SPAN 
            class=texample>n+1</SPAN>) обращений к функции, которая выполнит в 
            <SPAN class=texample>n</SPAN> случаях три операции, а в одном 
            возвратит значение. Функция при каждом обращении передает два 
            параметра, не использует локальных переменных, а при возвращении 
            (<SPAN class=texample>n+1</SPAN>) раз передает управление в точку 
            вызова. Соответственно сложность алгоритма в худшем случае составит 
            <SPAN class=texample>O(n)</SPAN> или <SPAN 
            class=texample>O(m)</SPAN>.</P>
            <DIV id=mark_115 class=lecture_mark></DIV>
            <P id=id_122>Оценим временную сложность функции в среднем случае, 
            т.е. когда <SPAN class=texample>m&lt;n</SPAN>. При этом выполняются 
            рассуждения, аналогичные худшему случаю, только количество 
            рекурсивных вызовов составит (<SPAN class=texample>m+1</SPAN>). 
            Соответственно сложность алгоритма в среднем случае составит <SPAN 
            class=texample>O(m)</SPAN>.</P>
            <DIV id=mark_122 class=lecture_mark></DIV>
            <P id=id_126>Лучший случай достигается при m=0, когда выполняется 
            единственный вызов функции, передача двух параметров и возвращение в 
            точку вызова, то есть оценка лучшего случая <SPAN 
            class=texample>O(1)</SPAN>.</P>
            <DIV id=mark_126 class=lecture_mark></DIV><A name=sect4></A>
            <H3>Базовые алгоритмы обработки данных</H3>
            <P id=id_128>Базовые алгоритмы обработки данных являются результатом 
            исследований и разработок, проводившихся на протяжении десятков лет. 
            Но они, как и прежде, продолжают играть важную роль во все 
            расширяющемся применении вычислительных процессов.</P>
            <DIV id=mark_128 class=lecture_mark></DIV>
            <P id=id_129>К базовым алгоритмам процедурного программирования 
            можно отнести:</P>
            <DIV id=mark_129 class=lecture_mark></DIV>
            <UL id=id_130>
              <LI><SPAN class=xml_em_italic>Алгоритмы работы со структурами 
              данных</SPAN>. Они определяют базовые принципы и методологию, 
              используемые для реализации, анализа и сравнения алгоритмов. 
              Позволяют получить представление о методах представления данных. К 
              таким структурам относятся связные списки и строки, деревья, 
              абстрактные типы данных, такие как стеки и очереди.
              <LI><SPAN class=xml_em_italic>Алгоритмы сортировки</SPAN>, 
              предназначенные для упорядочения массивов и файлов, имеют особую 
              важность. С алгоритмами сортировки связаны, в частности, очереди 
              по приоритету, задачи выбора и слияния.
              <LI><SPAN class=xml_em_italic>Алгоритмы поиска</SPAN>, 
              предназначенные для поиска конкретных элементов в больших 
              коллекциях элементов. К ним относятся основные и расширенные 
              методы поиска с использованием деревьев и преобразований цифровых 
              ключей, в том числе деревья цифрового поиска, сбалансированные 
              деревья, хеширование, а также методы, которые подходят для работы 
              с очень крупными файлами.
              <LI><SPAN class=xml_em_italic>Алгоритмы на графах</SPAN> полезны 
              при решении ряда сложных и важных задач. Общая стратегия поиска на 
              графах разрабатывается и применяется к фундаментальным задачам 
              связности, в том числе к задаче отыскания кратчайшего пути, 
              построения минимального остовного дерева, к задаче о потоках в 
              сетях и задаче о паросочетаниях. Унифицированный подход к этим 
              алгоритмам показывает, что в их основе лежит одна и та же функция, 
              и что эта функция базируется на основном абстрактном типе данных 
              очереди по приоритету.
              <LI><SPAN class=xml_em_italic>Алгоритмы обработки строк</SPAN> 
              включают ряд методов обработки последователей символов. Поиск в 
              строке приводит к сопоставлению с эталоном, что, в свою очередь, 
              ведет к синтаксическому анализу. К этому же классу задач можно 
              отнести и технологии сжатия файлов.
              <LI><SPAN class=xml_em_italic>Геометрические алгоритмы</SPAN> – 
              это методы решения задач с использованием точек и линий (и других 
              простых геометрических объектов), которые вошли в употребление 
              достаточно недавно. К ним относятся алгоритмы построения выпуклых 
              оболочек, заданных набором точек, определения пересечений 
              геометрических объектов, решения задач отыскания ближайших точек и 
              алгоритма многомерного поиска. Многие из этих методов дополняют 
              простые методы сортировки и поиска.</LI></UL>
            <DIV id=mark_130 class=lecture_mark></DIV><A name=sect5></A>
            <H3>Ключевые термины</H3>
            <P id=id_137><B>Алгоритм обработки данных</B> – это описание метода 
            решения задачи в компьютерных науках, который в дальнейшем возможно 
            реализовать в выбранной среде программирования.</P>
            <DIV id=mark_137 class=lecture_mark></DIV>
            <P id=id_138><B>Анализ алгоритмов</B> – это направление компьютерных 
            наук, занимающееся изучением оценки эффективности алгоритмов.</P>
            <DIV id=mark_138 class=lecture_mark></DIV>
            <P id=id_139><B>Трудоемкость алгоритма</B> – это количество 
            элементарных операций, которые учитываются при анализе алгоритма. 
            </P>
            <DIV id=mark_139 class=lecture_mark></DIV>
            <P id=id_140><B>Худший случай трудоемкости</B> – это наибольшее 
            количество операций, задаваемых алгоритмом <SPAN 
            class=texample>А</SPAN> на всех входах <SPAN class=texample>D</SPAN> 
            определенной размерности <SPAN class=texample>n</SPAN>.</P>
            <DIV id=mark_140 class=lecture_mark></DIV>
            <P id=id_144><B>Лучший случай трудоемкости</B> – это наименьшее 
            количество операций в алгоритме <SPAN class=texample>А</SPAN> на 
            всех входах <SPAN class=texample>D</SPAN> определенной размерности 
            <SPAN class=texample>n</SPAN>.</P>
            <DIV id=mark_144 class=lecture_mark></DIV>
            <P id=id_148><B>Средний случай трудоемкости</B> – это среднее 
            количество операций в алгоритме <SPAN class=texample>А</SPAN> на 
            всех входах <SPAN class=texample>D</SPAN> определенной размерности 
            <SPAN class=texample>n</SPAN>.</P>
            <DIV id=mark_148 class=lecture_mark></DIV>
            <P id=id_152><B>Функция трудоемкости алгоритма</B> – это зависимость 
            трудоемкости алгоритма <SPAN class=texample>А</SPAN> от значения 
            параметров на входе <SPAN class=texample>D</SPAN>.</P>
            <DIV id=mark_152 class=lecture_mark></DIV>
            <P id=id_155><B>Временная сложность алгоритма</B> – это 
            асимптотическая оценка функции трудоемкости алгоритма для худшего 
            случая.</P>
            <DIV id=mark_155 class=lecture_mark></DIV>
            <P id=id_156><B>Объем памяти</B> – это максимальное количество ячеек 
            памяти, задействованных в ходе выполнения алгоритма <SPAN 
            class=texample>А</SPAN> для входа <SPAN class=texample>D</SPAN>.</P>
            <DIV id=mark_156 class=lecture_mark></DIV>
            <P id=id_159><B>Емкостная сложность алгоритма</B> – это 
            асимптотическая оценка функции объема памяти алгоритма для худшего 
            случая.</P>
            <DIV id=mark_159 class=lecture_mark></DIV>
            <P id=id_160><B>Ресурсная сложность алгоритма в худшем, среднем и 
            лучшем случаях</B> – это упорядоченная пара классов функций 
            временной и емкостной сложности, заданных асимптотическими 
            обозначениями и соответствующих рассматриваемому случаю.</P>
            <DIV id=mark_160 class=lecture_mark></DIV>
            <P id=id_161><B>Алгоритмы работы со структурами данных</B> – это 
            алгоритмы, которые определяют базовые принципы и методологию, 
            используемые для получения представление о методах обработки данных. 
            </P>
            <DIV id=mark_161 class=lecture_mark></DIV>
            <P id=id_162><B>Алгоритмы сортировки</B> – это алгоритмы, 
            предназначенные для упорядочения массивов и файлов.</P>
            <DIV id=mark_162 class=lecture_mark></DIV>
            <P id=id_163><B>Алгоритмы поиска</B> – это алгоритмы, 
            предназначенные для поиска конкретных элементов в больших коллекциях 
            данных. </P>
            <DIV id=mark_163 class=lecture_mark></DIV>
            <P id=id_164><B>Алгоритмы на графах</B> – это алгоритмы, 
            предназначенные для реализации стратегий обходов и поиска на 
            графах.</P>
            <DIV id=mark_164 class=lecture_mark></DIV>
            <P id=id_165><B>Алгоритмы обработки строк</B> – это алгоритмы, 
            которые включают ряд методов обработки последователей символов. </P>
            <DIV id=mark_165 class=lecture_mark></DIV>
            <P id=id_166><B>Геометрические алгоритмы</B> – это алгоритмы решения 
            задач с использованием геометрических объектов.</P>
            <DIV id=mark_166 class=lecture_mark></DIV><A name=sect6></A>
            <H3>Краткие итоги</H3>
            <OL id=id_167>
              <LI>Определение ресурсной эффективности алгоритмов – необходимая 
              составляющая этапа анализа разработанного программного 
обеспечения.
              <LI>Наиболее значимыми характеристиками ресурсной эффективности 
              алгоритмов являются оценки их временной и емкостной сложности.
              <LI>Временная сложность алгоритма определяется асимптотической 
              оценкой функции трудоемкости алгоритма для худшего случая.
              <LI>В зависимости от вида функции временной сложности алгоритма 
              выделяют пять основных классов сложности алгоритмов.
              <LI>Емкостная сложность алгоритма определяется как асимптотическая 
              оценка функции объема памяти алгоритма для худшего случая.
              <LI>Ресурсная сложность алгоритма в худшем, среднем и лучшем 
              случаях определяется как упорядоченная пара классов функций 
              временной и емкостной сложности, заданных асимптотическими 
              обозначениями и соответствующих рассматриваемому случаю.
              <LI>Для получения функций трудоемкости для лучшего, среднего и 
              худшего случаев при фиксированной размерности входа необходимо 
              учесть особенности в оценке основных алгоритмических конструкций.
              <LI>Особенностью оценки ресурсной эффективности рекурсивных 
              алгоритмов является необходимость учета дополнительных затрат 
              памяти и механизма организации рекурсии.
              <LI>В зависимости от структур обработки данных в процедурном 
              программировании выделяются классы базовых алгоритмов.</LI></OL>
            <DIV id=mark_167 class=lecture_mark></DIV><A name=sect7></A>
            <H3>Лабораторная работа 33. Алгоритмы обработки данных</H3>
            <P id=id_177><B>Цель работы:</B> изучить понятие и классификации 
            алгоритмов обработки данных, трудоемкости алгоритмов и методов ее 
            оценки, научиться выработке критериев и оценке трудоемкости 
            алгоритмов с учетом критериев на примере реализаций и задач на языке 
            C++.</P>
            <DIV id=mark_177 class=lecture_mark></DIV>
            <P id=id_178>При выполнении лабораторной работы для каждого задания 
            требуется написать программу на языке С++, которая используется для 
            достижения основной цели работы – научиться классифицировать 
            алгоритмы в соответствии с их функцией трудоемкости. При выполнении 
            работы возможно использование программных кодов к ранее оформленным 
            лабораторным работам. Ввод данных осуществляется с клавиатуры с 
            учетом требований к входным данным, содержащихся в постановке 
            задачи. Ограничениями на входные данные является максимальный размер 
            строковых данных и диапазоны числовых типов в языке С++.</P>
            <DIV id=mark_178 class=lecture_mark></DIV>
            <P id=id_179><B>Теоретические сведения.</B></P>
            <DIV id=mark_179 class=lecture_mark></DIV>
            <P id=id_180>Ознакомьтесь с материалом лекции 33.</P>
            <DIV id=mark_180 class=lecture_mark></DIV>
            <P id=id_181><B>Задания к лабораторной работе.</B></P>
            <DIV id=mark_181 class=lecture_mark></DIV>
            <P id=id_182>Выполните приведенные ниже задания.</P>
            <DIV id=mark_182 class=lecture_mark></DIV>
            <OL id=id_183>
              <LI>Выполните анализ временной сложности алгоритмов простых 
              сортировок. Проведите сравнительный анализ полученных результатов. 
              Определите классы этих алгоритмов в зависимости от функции 
              трудоемкости.
              <LI>Выполните анализ временной трудоемкости алгоритма решения 
              задачи о Ханойских башнях. Определите класс этого алгоритма в 
              зависимости от функции трудоемкости.
              <LI>Выполните анализ трудоемкости конструкций вложенных циклов для 
              <SPAN class=texample>n=100, n=10<SUP>6</SUP>, 
              n=10<SUP>9</SUP></SPAN>. Составьте функцию временной трудоемкости 
              алгоритма и определите его класс сложности. Считать, что все 
              указанные операции корректны. Возможное переполнение разрядов не 
              учитывать. 
              <DIV class=example><PRE>k=0;
for (a=0; a&lt;n; a++)
  for (b=0; b&lt;n; b++)
    for (c=0; c&lt;n; c++)
      k++;
</PRE></DIV>
              <LI>Составьте функцию нахождения наибольшего общего делителя двух 
              натуральных чисел по алгоритму Евклида. Выполните анализ временной 
              трудоемкости алгоритма. Определите класс этого алгоритма в 
              зависимости от функции трудоемкости.
              <LI>Составьте функцию нахождения наибольшего общего делителя <SPAN 
              class=texample>n</SPAN> натуральных чисел, используя алгоритм 
              Евклида для двух чисел. Выполните анализ временной трудоемкости 
              алгоритма. Определите класс этого алгоритма в зависимости от 
              функции трудоемкости.</LI></OL>
            <DIV id=mark_183 class=lecture_mark></DIV>
            <P id=id_192><B>Указания к выполнению работы.</B></P>
            <DIV id=mark_192 class=lecture_mark></DIV>
            <P id=id_193>Лабораторная работа носит одновременно теоретический и 
            исследовательский характер, поэтому для ее выполнения сначала 
            необходимо очень внимательно изучить материал лекции 33. Каждое 
            задание необходимо решить в соответствии с изученными в предыдущих 
            лабораторных работах алгоритмами обработки данных в языке С++. В 
            отчете следует отразить тестовые материалы проведения анализа 
            трудоемкости алгоритмов и сделать выводы о принадлежности каждого 
            алгоритма к определенному классу сложности с обоснованием 
            результата.</P>
            <DIV id=mark_193 class=lecture_mark></DIV>
            <P id=id_194>Следует реализовать каждое задание в соответствии с 
            приведенными этапами:</P>
            <DIV id=mark_194 class=lecture_mark></DIV>
            <UL id=id_195>
              <LI>изучить словесную постановку задачи, выделив при этом все виды 
              данных;
              <LI>сформулировать математическую постановку задачи;
              <LI>выбрать метод решения задачи, если это необходимо;
              <LI>разработать графическую схему алгоритма;
              <LI>записать разработанный алгоритм на языке С++;
              <LI>разработать контрольный тест к программе;
              <LI>отладить программу;
              <LI>представить отчет по работе.</LI></UL>
            <DIV id=mark_195 class=lecture_mark></DIV>
            <P id=id_204><B>Требования к отчету.</B></P>
            <DIV id=mark_204 class=lecture_mark></DIV>
            <P id=id_205>Отчет по лабораторной работе должен соответствовать 
            следующей структуре.</P>
            <DIV id=mark_205 class=lecture_mark></DIV>
            <UL id=id_206>
              <LI>Титульный лист.
              <LI>Словесная постановка задачи. В этом подразделе проводится 
              полное описание задачи. Описывается суть задачи, анализ входящих в 
              нее физических величин, область их допустимых значений, единицы их 
              измерения, возможные ограничения, анализ условий при которых 
              задача имеет решение (не имеет решения), анализ ожидаемых 
              результатов.
              <LI>Математическая модель. В этом подразделе вводятся 
              математические описания физических величин и математическое 
              описание их взаимодействий. Цель подраздела – представить решаемую 
              задачу в математической формулировке.
              <LI>Алгоритм решения задачи. В подразделе описывается разработка 
              структуры алгоритма, обосновывается абстракция данных, задача 
              разбивается на подзадачи. Схема алгоритма выполняется по ЕСПД 
              (ГОСТ 19.003-80 и ГОСТ 19.002-80).
              <LI>Листинг программы. Подраздел должен содержать текст программы 
              на языке программирования С++, реализованный в среде MS Visual 
              Studio 2010.
              <LI>Контрольный тест. Подраздел содержит наборы исходных данных и 
              полученные в ходе выполнения программы результаты.
              <LI>Выводы по лабораторной работе. 
              <LI>Ответы на контрольные вопросы.</LI></UL>
            <DIV id=mark_206 class=lecture_mark></DIV>
            <P id=id_215><B>Контрольные вопросы</B></P>
            <DIV id=mark_215 class=lecture_mark></DIV>
            <OL id=id_216>
              <LI>С какой целью проводится оценка ресурсной эффективности 
              алгоритмов?
              <LI>Почему в теории анализа алгоритмов нет привязки к конкретной 
              реализации?
              <LI>Могут ли оценки временной сложности для худшего и лучшего 
              случаев совпадать? Подтвердите вывод примерами.
              <LI>Охарактеризуйте область применения алгоритмов классов 
              сложности <SPAN class=texample><IMG 
              style="POSITION: relative; TOP: 2px" border=0 alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/pi.gif" 
              width=8 height=18>E</SPAN> и <SPAN class=texample><IMG 
              style="POSITION: relative; TOP: 2px" border=0 alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/pi.gif" 
              width=8 height=18>F</SPAN>.
              <LI>В чем особенность оценки трудоемкости рекурсивных алгоритмов?
              <LI>Оцените временную трудоемкость рекурсивного и итерационного 
              способов вычисления факториала целого неотрицательного числа. 
              Определите класс сложности алгоритмов в каждом случае. Объясните 
              результат.</LI></OL>
            <DIV id=mark_216 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript 
src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/urchin.js">
</SCRIPT>

<SCRIPT 
type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
