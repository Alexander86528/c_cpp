<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0071)http://www.intuit.ru/department/algorithms/staldata/25/staldata_25.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/printable.css">
<META name=GENERATOR content="MSHTML 9.00.8080.16413"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="COLOR: #000000; FONT-WEIGHT: bold">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD>
    <TD><!-- content -->
      <TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD class=head>Структуры и алгоритмы компьютерной обработки 
        данных</TD></TR>
        <TR>
          <TD height=4><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>25. Лекция: Одномерные динамические массивы: 
            версия для печати и PDA</SPAN> <BR><SPAN class=rtxt>В лекции 
            рассматриваются определение, объявления, инициализация одномерных 
            динамических массивов, способы выделения и освобождения динамической 
            памяти под одномерный массив, доступ к элементам одномерного 
            динамического массива. </SPAN></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3></H3>
            <P id=id_1><B>Цель лекции:</B> изучить объявления, выделения и 
            освобождения памяти для одномерных динамических массивов, обращения 
            к элементам, научиться решать задачи с использованием одномерных 
            динамических массивов в языке C++.</P>
            <DIV id=mark_1 class=lecture_mark></DIV>
            <P id=id_2>При использовании многих структур данных достаточно часто 
            бывает, что они должны иметь переменный размер во время выполнения 
            программы. В этих случаях необходимо применять динамическое 
            выделение памяти. Одной из самых распространенных таких структур 
            данных являются массивы, в которых изначально размер не определен и 
            не зафиксирован.</P>
            <DIV id=mark_2 class=lecture_mark></DIV>
            <P id=id_3>В соответствии со стандартом языка массив представляет 
            собой совокупность элементов, каждый из которых имеет одни и те же 
            атрибуты. Все эти элементы размещаются в смежных участках памяти 
            подряд, начиная с адреса, соответствующего началу массива. То есть 
            общее количество элементов массива и размер памяти, выделяемой для 
            него, получаются полностью и однозначно заданными определением 
            массива. Но это не всегда удобно. Иногда требуется, чтобы выделяемая 
            память для массива имела размеры для решения конкретной задачи, 
            причем ее объем заранее не известен и не может быть фиксирован. 
            Формирование массивов с переменными размерами (динамических 
            массивов) можно организовать с помощью указателей и средств 
            динамического распределения памяти.</P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <P id=id_4><B>Динамический массив</B> – это массив, размер которого 
            заранее не фиксирован и может меняться во время исполнения 
            программы. Для изменения размера динамического массива язык 
            программирования С++, поддерживающий такие массивы, предоставляет 
            специальные встроенные функции или операции. Динамические массивы 
            дают возможность более гибкой работы с данными, так как позволяют не 
            прогнозировать хранимые объемы данных, а регулировать размер массива 
            в соответствии с реально необходимыми объемами.</P>
            <DIV id=mark_4 class=lecture_mark></DIV><A name=sect2></A>
            <H3>Объявление одномерных динамических массивов</H3>
            <P id=id_5>Под объявлением одномерного динамического массива 
            понимают объявление указателя на переменную заданного типа для того, 
            чтобы данную переменную можно было использовать как динамический 
            массив.</P>
            <DIV id=mark_5 class=lecture_mark></DIV>
            <P id=id_6>Синтаксис:</P>
            <DIV id=mark_6 class=lecture_mark></DIV>
            <DIV class=example><PRE>Тип * ИмяМассива;
</PRE></DIV>
            <P id=id_8><SPAN class=texample>ИмяМассива</SPAN> – идентификатор 
            массива, то есть имя указателя для выделяемого блока памяти.</P>
            <DIV id=mark_8 class=lecture_mark></DIV>
            <P id=id_10><SPAN class=texample>Тип</SPAN> – тип элементов 
            объявляемого динамического массива. Элементами динамического массива 
            не могут быть функции и элементы типа <SPAN 
            class=texample>void</SPAN>.</P>
            <DIV id=mark_10 class=lecture_mark></DIV>
            <P id=id_13>Например:</P>
            <DIV id=mark_13 class=lecture_mark></DIV>
            <DIV class=example><PRE>int *a; 
double *d;
</PRE></DIV>
            <P id=id_15>В данных примерах <SPAN class=texample>a</SPAN> и <SPAN 
            class=texample>d</SPAN> являются указателями на начало выделяемого 
            участка памяти. Указатели принимают значение адреса выделяемой 
            области памяти для значений типа <SPAN class=texample>int</SPAN> и 
            типа <SPAN class=texample>double</SPAN> соответственно.</P>
            <DIV id=mark_15 class=lecture_mark></DIV>
            <P id=id_20>Таким образом, при динамическом распределении памяти для 
            динамических массивов следует описать соответствующий указатель, 
            которому будет присвоено значение адреса начала области выделенной 
            памяти.</P>
            <DIV id=mark_20 class=lecture_mark></DIV><A name=sect3></A>
            <H3>Выделение памяти под одномерный динамический массив</H3>
            <P id=id_21>Для того чтобы выделить память под одномерный 
            динамический массив в языке С++ существует 2 способа.</P>
            <DIV id=mark_21 class=lecture_mark></DIV>
            <P id=id_22>1) <SPAN class=xml_em_italic>при помощи операции</SPAN> 
            <SPAN class=texample>new</SPAN>, которая выделяет для размещения 
            массива участок динамической памяти соответствующего размера и не 
            позволяет инициализировать элементы массива.</P>
            <DIV id=mark_22 class=lecture_mark></DIV>
            <P id=id_24>Синтаксис:</P>
            <DIV id=mark_24 class=lecture_mark></DIV>
            <DIV class=example><PRE>ИмяМассива = new Тип [ВыражениеТипаКонстанты];
</PRE></DIV>
            <P id=id_26><SPAN class=texample>ИмяМассива</SPAN> – идентификатор 
            массива, то есть имя указателя для выделяемого блока памяти.</P>
            <DIV id=mark_26 class=lecture_mark></DIV>
            <P id=id_28><SPAN class=texample>Тип</SPAN> – тип указателя на 
            массив. </P>
            <DIV id=mark_28 class=lecture_mark></DIV>
            <P id=id_30><SPAN class=texample>ВыражениеТипаКонстанты</SPAN> – 
            задает количество элементов (размерность) массива. Выражение 
            константного типа вычисляется на этапе компиляции.</P>
            <DIV id=mark_30 class=lecture_mark></DIV>
            <P id=id_32>Например:</P>
            <DIV id=mark_32 class=lecture_mark></DIV>
            <DIV class=example><PRE>int *mas; 
mas = new int [100]; /*выделение динамической памяти 
                       размером 100*sizeof(int) байтов*/
double *m = new double [n]; /*выделение динамической 
                 памяти размером n*sizeof(double) байтов*/
long (*lm)[4]; 
lm = new long [2] [4]; /*выделение динамической памяти 
                    размером 2*4*sizeof(long) байтов*/
</PRE></DIV>
            <P id=id_34>При выделении динамической памяти размеры массива должны 
            быть полностью определены.</P>
            <DIV id=mark_34 class=lecture_mark></DIV>
            <P id=id_35>2) <SPAN class=xml_em_italic>при помощи библиотечной 
            функции</SPAN> <SPAN class=texample>malloc (calloc)</SPAN>, которая 
            служит для выделения динамической памяти.</P>
            <DIV id=mark_35 class=lecture_mark></DIV>
            <P id=id_37>Синтаксис:</P>
            <DIV id=mark_37 class=lecture_mark></DIV>
            <DIV class=example><PRE>ИмяМассива = (Тип *) malloc(N*sizeof(Тип));
</PRE></DIV>
            <P id=id_39>или</P>
            <DIV id=mark_39 class=lecture_mark></DIV>
            <DIV class=example><PRE>ИмяМассива = (Тип *) calloc(N, sizeof(Тип));
</PRE></DIV>
            <P id=id_41><SPAN class=texample>ИмяМассива</SPAN> – идентификатор 
            массива, то есть имя указателя для выделяемого блока памяти.</P>
            <DIV id=mark_41 class=lecture_mark></DIV>
            <P id=id_43><SPAN class=texample>Тип</SPAN> – тип указателя на 
            массив. </P>
            <DIV id=mark_43 class=lecture_mark></DIV>
            <P id=id_45><SPAN class=texample>N</SPAN> – количество элементов 
            массива.</P>
            <DIV id=mark_45 class=lecture_mark></DIV>
            <P id=id_47>Например:</P>
            <DIV id=mark_47 class=lecture_mark></DIV>
            <DIV class=example><PRE>float *a;
a=(float *)malloc(10*sizeof(float));
// или
a=(float *)calloc(10,sizeof(float));
/*выделение динамической памяти размером 10*sizeof(float) байтов*/
</PRE></DIV>
            <P id=id_49>Так как функция <SPAN class=texample>malloc 
            (calloc)</SPAN> возвращает нетипизированный указатель <SPAN 
            class=texample>void *</SPAN>, то необходимо выполнять преобразование 
            полученного нетипизированного указатель в указатель объявленного 
            типа.</P>
            <DIV id=mark_49 class=lecture_mark></DIV><A name=sect4></A>
            <H3>Освобождение памяти, выделенной под одномерный динамический 
            массив</H3>
            <P id=id_52>Освобождение памяти, выделенной под одномерный 
            динамический массив, также осуществляется 2 способами.</P>
            <DIV id=mark_52 class=lecture_mark></DIV>
            <P id=id_53>1) <SPAN class=xml_em_italic>при помощи операции</SPAN> 
            <SPAN class=texample>delete</SPAN>, которая освобождает участок 
            памяти ранее выделенной операцией <SPAN 
            class=texample>new</SPAN>.</P>
            <DIV id=mark_53 class=lecture_mark></DIV>
            <P id=id_56>Синтаксис:</P>
            <DIV id=mark_56 class=lecture_mark></DIV>
            <DIV class=example><PRE>delete [] ИмяМассива;
</PRE></DIV>
            <P id=id_58><SPAN class=texample>ИмяМассива</SPAN> – идентификатор 
            массива, то есть имя указателя для выделяемого блока памяти.</P>
            <DIV id=mark_58 class=lecture_mark></DIV>
            <P id=id_60>Например:</P>
            <DIV id=mark_60 class=lecture_mark></DIV>
            <DIV class=example><PRE>delete [] mas; /*освобождает память, выделенную под 
                 массив, если mas адресует его начало*/
delete [] m;
delete [] lm;
</PRE></DIV>
            <P id=id_62>Квадратные скобки [] сообщают оператору, что требуется 
            освободить память, занятую всеми элементами, а не только первым.</P>
            <DIV id=mark_62 class=lecture_mark></DIV>
            <P id=id_63>2) <SPAN class=xml_em_italic>при помощи библиотечной 
            функции</SPAN> <SPAN class=texample>free</SPAN>, которая служит для 
            освобождения динамической памяти.</P>
            <DIV id=mark_63 class=lecture_mark></DIV>
            <P id=id_65>Синтаксис:</P>
            <DIV id=mark_65 class=lecture_mark></DIV>
            <DIV class=example><PRE>free (ИмяМассива);
</PRE></DIV>
            <P id=id_67><SPAN class=texample>ИмяМассива</SPAN> – идентификатор 
            массива, то есть имя указателя для выделяемого блока памяти.</P>
            <DIV id=mark_67 class=lecture_mark></DIV>
            <P id=id_69>Например:</P>
            <DIV id=mark_69 class=lecture_mark></DIV>
            <DIV class=example><PRE>free (a); //освобождение динамической памяти
</PRE></DIV><A name=sect5></A>
            <H3>Обращение к элементам одномерного динамического массива</H3>
            <P id=id_71>Адресация элементов динамического массива осуществляется 
            аналогично адресация элементов статического массива, то есть с 
            помощью индексированного имени.</P>
            <DIV id=mark_71 class=lecture_mark></DIV>
            <P id=id_72>Синтаксис:</P>
            <DIV id=mark_72 class=lecture_mark></DIV>
            <DIV class=example><PRE>ИмяМассива[ВыражениеТипаКонстанты];
</PRE></DIV>
            <P id=id_74>или</P>
            <DIV id=mark_74 class=lecture_mark></DIV>
            <P id=id_75>ИмяМассива[ЗначениеИндекса];</P>
            <DIV id=mark_75 class=lecture_mark></DIV>
            <P id=id_76>Например:</P>
            <DIV id=mark_76 class=lecture_mark></DIV>
            <P id=id_77><SPAN class=texample>mas[5]</SPAN> – индекс задается как 
            константа,</P>
            <DIV id=mark_77 class=lecture_mark></DIV>
            <P id=id_79><SPAN class=texample>sl[i]</SPAN> – индекс задается как 
            переменная,</P>
            <DIV id=mark_79 class=lecture_mark></DIV>
            <P id=id_81><SPAN class=texample>array[4*p]</SPAN> – индекс задается 
            как выражение.</P>
            <DIV id=mark_81 class=lecture_mark></DIV>
            <P id=id_83><SPAN class=xml_em_italic>Пример 1</SPAN>. Сформировать 
            динамический одномерный массив, заполнить его случайными числами. 
            Преобразовать массив таким образом, чтобы в первой его половине 
            располагались элементы, стоявшие в чётных позициях, а во второй 
            половине – элементы, стоявшие в нечётных позициях.</P>
            <DIV id=mark_83 class=lecture_mark></DIV>
            <DIV class=example><PRE>#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;

int _tmain(int argc, _TCHAR* argv[]){
  int *a, n, i; 
  cout &lt;&lt; "Введите n: "; 
  cin &gt;&gt; n;
  cout &lt;&lt; ' ';
  a = new int [n];  //Выделение памяти под массив
  for (i=0; i&lt;n; i++) {
    cout &lt;&lt; "Введите a[" &lt;&lt; i &lt;&lt; "]: ";
    cin &gt;&gt; a[i];
    cout &lt;&lt; ' ';
  }

  int *buf = new int [n]; 
  //Выделение памяти под вспомогательный массив
  int j = 0; //Индекс вспомогательного массива
  for (i=0; i&lt;n; i+=2) {  
  //Переписываем элементы с чётным индексом в новый массив
    buf[j] = a[i];
    j++;
  }
  for (i=1; i&lt;n; i+=2) { 
  //Переписываем элементы с нечётным индексом в новый массив
    buf[j] = a[i];
    j++;
  }
  cout &lt;&lt; "Преобразованный: " &lt;&lt; ' ';
  for (i=0; i&lt;n; i++) 
    cout &lt;&lt; buf[i] &lt;&lt; ' ';
  delete [] a;  //Освобождаем память
  delete [] buf;
  system("pause");
  return 0;
}
</PRE></DIV>
            <P id=id_85>Отметим, что указатель на массив не обязательно должен 
            показывать на начальный элемент некоторого массива. Он может быть 
            сдвинут так, что начальный элемент будет иметь индекс, отличный от 
            нуля, причем он может быть как положительным, так и 
            отрицательным.</P>
            <DIV id=mark_85 class=lecture_mark></DIV>
            <P id=id_86><SPAN class=xml_em_italic>Пример 2.</SPAN></P>
            <DIV id=mark_86 class=lecture_mark></DIV>
            <DIV class=example><PRE>#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
int _tmain(int argc, _TCHAR* argv[]){
  float *mas;
  int m;
  scanf("%d",&amp;m);
  mas=(float *)calloc(m,sizeof(float));
  //сейчас указатель q показывает на начало массива
  mas[0]=22.3;
  mas-=5;
  /*теперь начальный элемент массива имеет индекс 5, 
    а конечный элемент индекс n-5*/
  mas[5]=1.5;
  /*сдвиг индекса не приводит к перераспределению массива 
    в памяти и изменится начальный элемент*/
  mas[6]=2.5; // это второй элемент 
  mas[7]=3.5; // это третий элемент 
  mas+=5;
  /*теперь начальный элемент вновь имеет индекс 0, 
    а значения элементов q[0], q[1], q[2] равны 
    соответственно 1.5, 2.5, 3.5*/
  mas+=2;
  /*теперь начальный элемент имеет индекс -2, следующий -1, 
    затем 0 и т.д. по порядку*/
  mas[-2]=8.2;
  mas[-1]=4.5;
  mas-=2;
  /*возвращаем начальную индексацию, три первых элемента 
    массива q[0],q[1],q[2], имеют значения 8.2, 4.5, 3.5*/
  mas--;
  /*вновь изменим индексацию. Для освобождения области 
    памяти, в которой размещен массив q используется 
    функция free(q), но поскольку значение указателя q   
    смещено, то выполнение функции free(q) приведет к 
    непредсказуемым последствиям. 
    Для правильного выполнения этой функции указатель q 
    должен быть возвращен в первоначальное положение */
  free(++mas);
  system("pause");
  return 0;
}
</PRE></DIV>
            <P id=id_88><SPAN class=xml_em_italic>Пример 3</SPAN>. Задача Иосифа 
            Флавия или считалка Джозефуса.</P>
            <DIV id=mark_88 class=lecture_mark></DIV>
            <P id=id_89>Задача в своей основе имеет легенду. Отряд из 41-го 
            сикария, защищавший галилейскую крепость Массада, не пожелал 
            сдаваться в плен блокировавшим его превосходящим силам римлян. 
            Сикарии стали в круг и договорились, что каждые два воина будут 
            убивать третьего, пока не погибнут все. Самоубийство – тяжкий грех, 
            но тот, кто в конце концов останется последним, должен будет его 
            совершить. Иосиф Флавий, командовавший этим отрядом, якобы быстро 
            рассчитал, где нужно стать ему и его другу, чтобы остаться 
            последними. Но не для того, чтобы убить друг друга, а чтобы сдать 
            крепость римлянам. В современной формулировке задачи участвует <SPAN 
            class=texample>n</SPAN> воинов и убивают каждого <SPAN 
            class=texample>k</SPAN>-го. Требуется определить номера <SPAN 
            class=texample>m</SPAN> и <SPAN class=texample>t</SPAN> начальных 
            позиций двоих воинов, которые должны будут остаться последними.</P>
            <DIV id=mark_89 class=lecture_mark></DIV>
            <DIV class=example><PRE>#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;

void kill(int *mass,int n,int i);
void krug(int *mass,int n,int k, int i=0);

int _tmain(int argc, _TCHAR* argv[]){
  int n,k,*mass,i;
  FILE *f;
  f=fopen("input.txt","r");
  fscanf(f,"%d %d",&amp;n,&amp;k);
  fclose(f);
  mass=(int *)malloc(n*sizeof(int));
  for (i=0;i&lt;n;i++) mass[i]=i+1;
  f=fopen("output.txt","w");
  fprintf(f,"Исходная нумерация: \n");
  for (i=0;i&lt;n;i++) fprintf(f,"%d ",mass[i]);
  fclose(f);
  krug(mass,n,k);
  f=fopen("output.txt","a+");
  fprintf(f,"\nОставшиеся в живых: \n");
  for (i=0;i&lt;k;i++) fprintf(f,"%d ",mass[i]);
  fclose(f);  
  free(mass);
  system("pause");
  return 0;
}

void kill(int *mass,int n,int i) {
  int j;
  for (j=i;j&lt;n-1;j++) 
    mass[j]=mass[j+1];
}

void krug(int *mass,int n,int k,int i) {
  int ii;
  if (n&gt;k) {
    ii=i+k-1;
    if (ii&gt;=n) ii=ii%n;
    kill(mass,n,ii);
    krug(mass,n-1,k,ii);
  }
}
</PRE></DIV><A name=sect6></A>
            <H3>Ключевые термины</H3>
            <P id=id_95><B>Динамический массив</B> – это массив, размер которого 
            заранее не фиксирован и может меняться во время исполнения 
            программы.</P>
            <DIV id=mark_95 class=lecture_mark></DIV>
            <P id=id_96><B>Значение указателя на одномерный динамический 
            массив</B> – это адрес выделяемой области динамической памяти.</P>
            <DIV id=mark_96 class=lecture_mark></DIV>
            <P id=id_97><B>Одномерный динамический массив</B> – это одномерный 
            массив, расположенный в динамической памяти.</P>
            <DIV id=mark_97 class=lecture_mark></DIV>
            <P id=id_98><B>Тип одномерного динамического массива</B> – это тип 
            элементов массива.</P>
            <DIV id=mark_98 class=lecture_mark></DIV>
            <P id=id_99><B>Указатель на одномерный динамический массив</B> – это 
            указатель на начало выделяемого участка динамической памяти.</P>
            <DIV id=mark_99 class=lecture_mark></DIV><A name=sect7></A>
            <H3>Краткие итоги</H3>
            <OL id=id_100>
              <LI>При работе с массивами, размер которых заранее не известен, 
              используют динамические массивы.
              <LI>Под объявлением одномерного динамического массива понимают 
              объявление указателя на переменную заданного типа для того, чтобы 
              данную переменную можно было использовать как динамический массив.
              <LI>Работа с одномерными динамическими массивами начинается с 
              выделения участка памяти, а завершается освобождением ранее 
              выделенного участка.
              <LI>Выделение и освобождение памяти под одномерный динамический 
              массив выполняется с помощью операций или функций для работы с 
              динамической памятью.
              <LI>Адресация элементов динамического массива осуществляется с 
              помощью индексированного имени.
              <LI>Указатель на одномерный динамический массив не обязательно 
              должен показывать на начальный элемент некоторого массива.</LI></OL>
            <DIV id=mark_100 class=lecture_mark></DIV><A name=sect8></A>
            <H3>Лабораторная работа 25. Одномерные динамические массивы</H3>
            <P id=id_107><B>Цель работы:</B> изучить объявления, выделения и 
            освобождения памяти для одномерных динамических массивов, обращения 
            к элементам, научиться решать задачи с использованием одномерных 
            динамических массивов в языке C++.</P>
            <DIV id=mark_107 class=lecture_mark></DIV>
            <P id=id_108>При выполнении лабораторной работы для каждого задания 
            требуется написать программу на языке С++, которая получает на входе 
            числовые данные (в зависимости от постановки задачи), выполняет 
            генерацию, вывод одномерного массива указанного типа. Для хранения 
            оговоренных в условии массивов следует использовать ресурсы 
            динамической памяти. Ввод данных осуществляется с клавиатуры с 
            учетом требований к входным данным, содержащихся в постановке 
            задачи. Ограничениями на входные данные является диапазон 
            используемого числового типа данных в языке С++ и максимально 
            допустимый размер динамической памяти.</P>
            <DIV id=mark_108 class=lecture_mark></DIV>
            <P id=id_109><B>Теоретические сведения.</B></P>
            <DIV id=mark_109 class=lecture_mark></DIV>
            <P id=id_110>Ознакомьтесь с материалом лекции 25.</P>
            <DIV id=mark_110 class=lecture_mark></DIV>
            <P id=id_111><B>Задания к лабораторной работе.</B></P>
            <DIV id=mark_111 class=lecture_mark></DIV>
            <P id=id_112>Выполните приведенные ниже задания.</P>
            <DIV id=mark_112 class=lecture_mark></DIV>
            <OL id=id_113>
              <LI>Задан массив. Определить сколько раз меняется знак в данной 
              последовательности чисел, запомнить номера позиций, в которых 
              меняется знак.
              <LI>Задана последовательность из <SPAN class=texample>N</SPAN> 
              вещественных чисел. Вычислить сумму чисел, порядковые номера 
              которых являются числами Фибоначчи.
              <LI>Задана последовательность из <SPAN class=texample>N</SPAN> 
              вещественных чисел. Найти частное средних арифметических значений 
              элементов с нечетными и четными индексами.
              <LI>Напишите программу, оформив её в виде функций генерации, 
              вывода и обработки массивов. Сформируйте динамический одномерный 
              массив, заполните его случайными числами и выведите на печать. 
              Добавьте после каждого отрицательного элемента его модуль и 
              выведите массив на печать. Реализуйте данную программу двумя 
              способами: 1) с помощью операций <SPAN class=texample>new</SPAN> и 
              <SPAN class=texample>delete</SPAN>; 2) с помощью библиотечных 
              функций <SPAN class=texample>malloc (calloc)</SPAN> и <SPAN 
              class=texample>free</SPAN>.</LI></OL>
            <DIV id=mark_113 class=lecture_mark></DIV>
            <P id=id_124><SPAN class=texample>Указания к выполнению 
            работы.</SPAN></P>
            <DIV id=mark_124 class=lecture_mark></DIV>
            <P id=id_126>Каждое задание необходимо решить в соответствии с 
            изученными методами работы с динамической памятью и алгоритмами 
            обработки одномерных массивов в языке С++. В задачах количество 
            входных данных заранее не определено, однако, при реализации следует 
            считать, что их размер не превышает максимально допустимого объема 
            динамической памяти. Вывод входных данных и результатов их обработки 
            следует осуществить на экран. Программу для решения каждого задания 
            необходимо разработать методом процедурной абстракции, оформив 
            комментарии к коду.</P>
            <DIV id=mark_126 class=lecture_mark></DIV>
            <P id=id_127>Следует реализовать каждое задание в соответствии с 
            приведенными этапами:</P>
            <DIV id=mark_127 class=lecture_mark></DIV>
            <UL id=id_128>
              <LI>изучить словесную постановку задачи, выделив при этом все виды 
              данных;
              <LI>сформулировать математическую постановку задачи;
              <LI>выбрать метод решения задачи, если это необходимо;
              <LI>разработать графическую схему алгоритма;
              <LI>записать разработанный алгоритм на языке С++;
              <LI>разработать контрольный тест к программе;
              <LI>отладить программу;
              <LI>представить отчет по работе.</LI></UL>
            <DIV id=mark_128 class=lecture_mark></DIV>
            <P id=id_137><B>Требования к отчету.</B></P>
            <DIV id=mark_137 class=lecture_mark></DIV>
            <P id=id_138>Отчет по лабораторной работе должен соответствовать 
            следующей структуре.</P>
            <DIV id=mark_138 class=lecture_mark></DIV>
            <UL id=id_139>
              <LI>Титульный лист.
              <LI>Словесная постановка задачи. В этом подразделе проводится 
              полное описание задачи. Описывается суть задачи, анализ входящих в 
              нее физических величин, область их допустимых значений, единицы их 
              измерения, возможные ограничения, анализ условий при которых 
              задача имеет решение (не имеет решения), анализ ожидаемых 
              результатов.
              <LI>Математическая модель. В этом подразделе вводятся 
              математические описания физических величин и математическое 
              описание их взаимодействий. Цель подраздела – представить решаемую 
              задачу в математической формулировке.
              <LI>Алгоритм решения задачи. В подразделе описывается разработка 
              структуры алгоритма, обосновывается абстракция данных, задача 
              разбивается на подзадачи. Схема алгоритма выполняется по ЕСПД 
              (ГОСТ 19.003-80 и ГОСТ 19.002-80).
              <LI>Листинг программы. Подраздел должен содержать текст программы 
              на языке программирования С++, реализованный в среде MS Visual 
              Studio 2010.
              <LI>Контрольный тест. Подраздел содержит наборы исходных данных и 
              полученные в ходе выполнения программы результаты.
              <LI>Выводы по лабораторной работе. 
              <LI>Ответы на контрольные вопросы.</LI></UL>
            <DIV id=mark_139 class=lecture_mark></DIV>
            <P id=id_148><B>Контрольные вопросы</B></P>
            <DIV id=mark_148 class=lecture_mark></DIV>
            <OL id=id_149>
              <LI>В каких ситуациях в программировании целесообразно 
              использовать динамические массивы?
              <LI>Что будет возвращено при попытке объявить динамический массив 
              недопустимо большого размера?
              <LI>Как размещаются в памяти элементы одномерного динамического 
              массива?
              <LI>С какой целью используется первая пара скобок при объявлении 
              (<SPAN class=texample>Тип*</SPAN>) <SPAN class=texample>malloc(N* 
              sizeof(Тип))</SPAN>?
              <LI>С какой целью выполняется явное преобразование типов значений 
              функций <SPAN class=texample>malloc (сalloc)</SPAN> при объявлении 
              массивов?
              <LI>Почему указатель на одномерный динамический массив не всегда 
              показывает на его начальный элемент?
              <LI>Какими способами можно обратиться к элементам одномерного 
              динамического массива?
              <LI>С какой целью используются квадратные скобки в операции 
              освобождения динамической памяти, выделенной под массив: <SPAN 
              class=texample>delete [] mass;</SPAN>?</LI></OL>
            <DIV id=mark_149 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript 
src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/urchin.js">
</SCRIPT>

<SCRIPT 
type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
