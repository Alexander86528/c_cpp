<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0069)http://www.intuit.ru/department/algorithms/staldata/3/staldata_3.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/printable.css">
<META name=GENERATOR content="MSHTML 9.00.8080.16413"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="COLOR: #000000; FONT-WEIGHT: bold">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD>
    <TD><!-- content -->
      <TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD class=head>Структуры и алгоритмы компьютерной обработки 
        данных</TD></TR>
        <TR>
          <TD height=4><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>3. Лекция: Рекурсивные функции: версия для 
            печати и PDA</SPAN> <BR><SPAN class=rtxt>В лекции рассматриваются 
            понятие, определения и виды рекурсии, рекурсивные функции, этапы 
            решения задач рекурсивными способами через разработку рекурсивной 
            триады, приводятся примеры решения задач рекурсивными способами. 
            </SPAN></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3></H3>
            <P id=id_1><B>Цель лекции:</B> изучить понятия рекурсии, рекурсивные 
            функции в программировании, приемы построения рекурсивной триады при 
            решении задач, научиться применять рекурсивные методы в решении 
            задач на языке С++.</P>
            <DIV id=mark_1 class=lecture_mark></DIV>
            <P id=id_2>В окружающем нас мире часто можно встретить объекты, 
            обладающие самоподобием. То есть часть большого объекта в чем-то 
            сходна с самим объектом. Например, ветка дерева повторяет форму и 
            характер ветвления, схожие с самим деревом. Приведенные ниже 
            графические объекты также обладают самоподобием (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/3/staldata_3.html#image.3.1">рис. 
            3.1</A>). Такие объекты называются рекурсивными.</P>
            <DIV id=mark_2 class=lecture_mark></DIV>
            <P id=id_3 align=left><A name=image.3.1></A>
            <DIV><IMG alt="Рекурсивные графические объекты" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/03_01.png" 
            width=750 height=403></DIV><BR><B>Рис. 3.1.</B>&nbsp; Рекурсивные 
            графические объекты
            <P></P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <P id=id_4>При первичном осмыслении понятие рекурсии достаточно 
            просто и не требует специальных знаний. Иногда на рекурсию смотрят 
            как на наличие в определении объекта ссылки на сам объект или 
            проявление свойств самоповторения (при этом сколь угодно малая часть 
            объекта подобна всему объекту в целом). Общий случай проявления 
            рекурсивности может быть сформулирован как наличие циклических 
            взаимных обращений в определении объекта, которые в итоге замыкаются 
            на сам объект.</P>
            <DIV id=mark_4 class=lecture_mark></DIV>
            <P id=id_5>В технике процедурного программирования рекурсивность в 
            построении подпрограмм проявляется в разработке управляющих 
            структур, которые при выполнении обращаются сами к себе 
            непосредственно или через цепочку других аналогичных структур. 
            Бесконечность и незавершенность таких обращений кажущаяся, так как 
            при достижении определенных условий самовызовы завершаются. Во 
            многих конкретных случаях простыми рассуждениями путем отслеживания 
            значений одной или нескольких управляющих величин удается провести 
            доказательство завершимости рекурсивных вычислений за конечное число 
            шагов.</P>
            <DIV id=mark_5 class=lecture_mark></DIV>
            <P id=id_6>Рекурсивность в постановке задачи проявляется, если 
            решение для общего случая сводится к аналогичным задачам для 
            меньшего количества входных данных. В таком контексте под рекурсией 
            понимают прием последовательного сведения решения некоторой задачи к 
            решению совокупности "более простых" задач такого же класса и 
            получению на этой основе решения исходной задачи.</P>
            <DIV id=mark_6 class=lecture_mark></DIV>
            <P id=id_7><B>Рекурсия в широком смысле</B> – это определение 
            объекта посредством ссылки на себя. <B>Рекурсия в 
            программировании</B> – это пошаговое разбиение задачи на подзадачи, 
            подобные исходной. </P>
            <DIV id=mark_7 class=lecture_mark></DIV>
            <P id=id_8><B>Рекурсивный алгоритм</B> – это алгоритм, в определении 
            которого содержится прямой или косвенный вызов этого же алгоритма. 
            </P>
            <DIV id=mark_8 class=lecture_mark></DIV>
            <P id=id_9>В языках программирования процедурной парадигмы 
            предусмотрено использование рекурсивных функций в решении задач.</P>
            <DIV id=mark_9 class=lecture_mark></DIV>
            <P id=id_10>Функция называется <B>рекурсивной</B>, если в своем теле 
            она содержит обращение к самой себе с измененным набором параметров. 
            При этом количество обращений конечно, так как в итоге решение 
            сводится к базовому случаю, когда ответ очевиден.</P>
            <DIV id=mark_10 class=lecture_mark></DIV>
            <P id=id_11><SPAN class=xml_em_italic>Пример 1</SPAN>. В 
            арифметической прогрессии найдите <SPAN 
            class=texample>a<SUB>n</SUB></SPAN>, если известны <SPAN 
            class=texample>а<SUB>1</SUB></SPAN> = -2.5, <SPAN 
            class=texample>d</SPAN>=0.4, не используя формулу <SPAN 
            class=texample>n</SPAN>-го члена прогрессии.</P>
            <DIV id=mark_11 class=lecture_mark></DIV>
            <P id=id_16>По определению арифметической прогрессии, <SPAN 
            class=texample>a<SUB>n</SUB>=a<SUB>n</SUB>-1+d</SPAN>, при этом</P>
            <DIV id=mark_16 class=lecture_mark></DIV>
            <DIV class=example><PRE>a<SUB>n-1</SUB>=a<SUB>n-2</SUB>+d, a<SUB>n-2</SUB>=a<SUB>n-3</SUB>+d,... a<SUB>2</SUB>=a<SUB>1</SUB>+d.
</PRE></DIV>
            <P id=id_19>Таким образом, нахождение <SPAN 
            class=texample>a<SUB>n</SUB></SPAN> для номера <SPAN 
            class=texample>n</SPAN> сводится к решению аналогичной задачи, но 
            только для номера <SPAN class=texample>n</SPAN>-1, что в свою 
            очередь сводится к решению для номера <SPAN 
            class=texample>n</SPAN>-2, и так далее, пока не будет достигнут 
            номер 1 (значение <SPAN class=texample>а<SUB>1</SUB></SPAN> дано по 
            условию задачи).</P>
            <DIV id=mark_19 class=lecture_mark></DIV>
            <DIV class=example><PRE>float arifm (int n, float a, float d) {
  if (n&lt;1) return 0;       // для неположительных номеров
  if (n==1) return a;      // базовый случай: n=1
  return arifm(n-1,a,d)+d; // общий случай
} 
</PRE></DIV>
            <P id=id_26>В рекурсивных функциях несколько раз используется <SPAN 
            class=texample>return</SPAN>. В базовом случае возвращается 
            конкретный результат (в примере – значение <SPAN 
            class=texample>а</SPAN>), а общий случай предусматривает вызов 
            функцией себя же, но с меняющимися значениями отдельных параметров 
            (в примере изменяется только номер члена последовательности, при 
            этом не меняются разность и первый член прогрессии). </P>
            <DIV id=mark_26 class=lecture_mark></DIV>
            <P id=id_29>В программировании выделяют прямую и косвенную рекурсию. 
            <SPAN class=xml_em_italic>Прямая рекурсия</SPAN> предусматривает 
            непосредственное обращение рекурсивной функции к себе, но с иным 
            набором входных данных. <SPAN class=xml_em_italic>Косвенная 
            (взаимная) рекурсия</SPAN> представляет собой последовательность 
            взаимных вызовов нескольких функций, организованная в виде 
            циклического замыкания на тело первоначальной функции, но с иным 
            набором параметров.</P>
            <DIV id=mark_29 class=lecture_mark></DIV>
            <P id=id_30>Для решения задач рекурсивными методами разрабатывают 
            следующие этапы, образующие <B>рекурсивную триаду</B>:</P>
            <DIV id=mark_30 class=lecture_mark></DIV>
            <UL id=id_31>
              <LI>параметризация – выделяют параметры, которые используются для 
              описания условия задачи, а затем в решении;
              <LI>база рекурсии – определяют тривиальный случай, при котором 
              решение очевидно, то есть не требуется обращение функции к себе;
              <LI>декомпозиция – выражают общий случай через более простые 
              подзадачи с измененными параметрами.</LI></UL>
            <DIV id=mark_31 class=lecture_mark></DIV>
            <P id=id_35><SPAN class=xml_em_italic>Целесообразность применения 
            рекурсии</SPAN> в программировании обусловлена спецификой задач, в 
            постановке которых явно или опосредовано указывается на возможность 
            сведения задачи к подзадачам, аналогичным самой задаче. При этом 
            эффективность рекурсивного или итерационного способов решения одной 
            и той же задачи определяется в ходе анализа работоспособности 
            программы на различных наборах данных. Таким образом, рекурсия не 
            является универсальным способом в программировании. Ее следует 
            рассматривать как альтернативный вариант при разработке алгоритмов 
            решения задач. </P>
            <DIV id=mark_35 class=lecture_mark></DIV>
            <P id=id_36>Повысить эффективность рекурсивных алгоритмов часто 
            представляется возможным за счет пересмотра этапов триады. Например, 
            введение дополнительных параметров, не оговоренных в условии задачи, 
            в реализации декомпозиции могут быть применены другие соотношения, а 
            также можно организовать расширение базовых случаев с сохранением 
            промежуточных результатов.</P>
            <DIV id=mark_36 class=lecture_mark></DIV>
            <P id=id_37>Область памяти, предназначенная для хранения всех 
            промежуточных значений локальных переменных при каждом следующем 
            рекурсивном обращении, образует <SPAN 
            class=xml_em_italic>рекурсивный стек</SPAN>. Для каждого текущего 
            обращения формируется локальный слой данных стека (при этом 
            совпадающие идентификаторы разных слоев стека независимы друг от 
            друга и не отождествляются). Завершение вычислений происходит 
            посредством восстановления значений данных каждого слоя в порядке, 
            обратном рекурсивным обращениям. В силу подобной организации 
            количество рекурсивных обращений ограничено размером области памяти, 
            выделяемой под программный код. При заполнении всей предоставленной 
            области памяти попытка вызова следующего рекурсивного обращения 
            приводит к ошибке переполнения стека.</P>
            <DIV id=mark_37 class=lecture_mark></DIV>
            <P id=id_38><SPAN class=xml_em_italic>Пример 2</SPAN>. Для целого 
            неотрицательного числа <SPAN class=texample>n</SPAN> найдите его 
            факториал.</P>
            <DIV id=mark_38 class=lecture_mark></DIV>
            <P id=id_40>Разработаем рекурсивную триаду.</P>
            <DIV id=mark_40 class=lecture_mark></DIV>
            <P id=id_41>Параметризация: <SPAN class=texample>n</SPAN> – 
            неотрицательное целое число.</P>
            <DIV id=mark_41 class=lecture_mark></DIV>
            <P id=id_43>База рекурсии: для <SPAN class=texample>n</SPAN>=0 
            факториал равен 1.</P>
            <DIV id=mark_43 class=lecture_mark></DIV>
            <P id=id_45>Декомпозиция: <SPAN 
            class=texample>n!=(n-1)!·n</SPAN>.</P>
            <DIV id=mark_45 class=lecture_mark></DIV>
            <DIV class=example><PRE>long factor (int n) {
  if (n&lt;0) return 0;        // для отрицательных чисел
  if (n==0) return 1;       // базовый случай: n=0
  return factor(n-1)*n;     // общий случай (декомпозиция)
} 
</PRE></DIV>
            <P id=id_48>Рассмотрим задачи, для которых можно предложить 
            рекурсивные алгоритмы решения, в то время как итерационные алгоритмы 
            были бы сложными и искусственными.</P>
            <DIV id=mark_48 class=lecture_mark></DIV>
            <P id=id_49><SPAN class=xml_em_italic>Пример 3. Задача о 
            коэффициентах Безу</SPAN></P>
            <DIV id=mark_49 class=lecture_mark></DIV>
            <P id=id_50>Для любых натуральных чисел <SPAN 
            class=texample>n</SPAN> и <SPAN class=texample>m</SPAN> найдите 
            коэффициенты Безу, то есть такие целые <SPAN class=texample>a</SPAN> 
            и <SPAN class=texample>b</SPAN>, что выполняется равенство: <SPAN 
            class=texample>nod(n,m)=a·n+b·m</SPAN> (где <SPAN 
            class=texample>nod(n,m)</SPAN> – наибольший общий делитель <SPAN 
            class=texample>n</SPAN> и <SPAN class=texample>m</SPAN>).</P>
            <DIV id=mark_50 class=lecture_mark></DIV>
            <P id=id_59><SPAN class=xml_em_italic>Параметризация.</SPAN></P>
            <DIV id=mark_59 class=lecture_mark></DIV>
            <P id=id_60><SPAN class=texample>m, n</SPAN> – данные натуральные 
            числа, неизменяемые параметры;</P>
            <DIV id=mark_60 class=lecture_mark></DIV>
            <P id=id_62><SPAN class=texample>d</SPAN> – наибольший общий 
            делитель данных чисел, неизменяемый параметр;</P>
            <DIV id=mark_62 class=lecture_mark></DIV>
            <P id=id_64><SPAN class=texample>bm, bn</SPAN> – коэффициенты Безу 
            при <SPAN class=texample>n</SPAN> и <SPAN class=texample>m</SPAN> 
            соответственно, эти параметры меняются при очередном рекурсивном 
            вызове функции.</P>
            <DIV id=mark_64 class=lecture_mark></DIV>
            <P id=id_68><SPAN class=xml_em_italic>База рекурсии</SPAN>. Если при 
            очередном обращении к функции с передаваемыми параметрами 
            выполняется равенство <SPAN class=texample>d=m·bm–n·bn</SPAN>, то 
            коэффициенты Безу найдены. Требуется вывести линейную 
комбинацию.</P>
            <DIV id=mark_68 class=lecture_mark></DIV>
            <P id=id_70><SPAN class=xml_em_italic>Декомпозиция</SPAN>. Если 
            равенство не выполняется, то инкрементно увеличиваем коэффициент при 
            меньшем из чисел (<SPAN class=texample>n</SPAN> или <SPAN 
            class=texample>m</SPAN>). Следующий вызов рекурсивной функции 
            выполняется с измененным набором отдельных параметров. При этом 
            снова проверяется база рекурсии, и рекурсивный алгоритм повторяется 
            (либо достигается база и функция завершает работу, либо выполняется 
            декомпозиционный переход).</P>
            <DIV id=mark_70 class=lecture_mark></DIV>
            <DIV class=example><PRE>//Коэффициенты Безу
#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
int nod(int m, int n);
void bezu(int d, int m, int n, int bm, int bn);

int _tmain(int argc, _TCHAR* argv[]){
  int x,y,del,buf;
  printf("Задача нахождения коэффициентов Безу");
  printf("\nВведите два натуральных числа:"); 
  printf("\nX= "); 
  scanf("%d",&amp;x);
  printf("Y= "); 
  scanf("%d",&amp;y);
  if (x &lt; y) {buf = x; x = y; y = buf;} 
  del=nod(x,y);
  printf("\nЛинейная комбинация:\n");
  bezu(del,x,y,1,1);
  system("pause");
  return 0;
}

//функция нахождения наибольшего общего делителя двух чисел
int nod(int m, int n){
  if (m%n==0) return n;
  return nod(n,m%n);
}
//функция нахождения и вывода на экран коэффициентов Безу
void bezu(int d, int m, int n, int bm, int bn){ 
  int pm,pn;
  pm = m * bm;
  pn = n * bn;
  //проверка базы рекурсии (выполнение линейной комбинации)
  if (d == pm - pn) 
    printf ("%d = %d*%d - %d*%d", d, bm, m, bn, n);
  //декомпозиция
  else {
    bn++;
    pn=n*bn;
    /*если произведение pm больше, чем pn, то порядок 
    параметров сохраняется*/
    if (pm &gt; pn) bezu(d, m, n, bm, bn);
    /*если произведение pm меньше, чем pn, то порядок 
    параметров изменятеся*/
    else  bezu(d, n, m, bn, bm); 
  }
}
</PRE></DIV>
            <P id=id_74><SPAN class=xml_em_italic>Пример 4. Задача о Ханойских 
            башнях</SPAN></P>
            <DIV id=mark_74 class=lecture_mark></DIV>
            <P id=id_75>Ханойская башня является одной из популярных головоломок 
            XIX века. Даны три стержня, на один из которых нанизаны n колец, 
            причем кольца отличаются размером и лежат меньшее на большем. Задача 
            состоит в том, чтобы перенести пирамиду из <SPAN 
            class=texample>n</SPAN> колец за наименьшее число ходов с одного 
            стержня на другой. За один раз разрешается переносить только одно 
            кольцо, причём нельзя класть большее кольцо на меньшее.</P>
            <DIV id=mark_75 class=lecture_mark></DIV>
            <P id=id_77>Существует древнеиндийская легенда, согласно которой в 
            городе Бенаресе под куполом главного храма, в том месте, где 
            находится центр Земли, на бронзовой площадке стоят три алмазных 
            стержня. В день сотворения мира на один из этих стержней было надето 
            64 кольца. Бог поручил жрецам перенести кольца с одного стержня на 
            другой, используя третий в качестве вспомогательного. Жрецы обязаны 
            соблюдать условия:</P>
            <DIV id=mark_77 class=lecture_mark></DIV>
            <OL id=id_78>
              <LI>переносить за один раз только одно кольцо; 
              <LI>кольцо можно класть только на кольцо большего размера или на 
              пустой стержень. </LI></OL>
            <DIV id=mark_78 class=lecture_mark></DIV>
            <P id=id_81>Согласно легенде, когда, соблюдая все условия, жрецы 
            перенесут все 64 кольца, наступит конец света. Для 64 колец это 18 
            446 744 073 709 551 615 перекладываний, и, если учесть скорость одно 
            перекладывание в секунду, получится около 584 542 046 091 лет, то 
            есть апокалипсис наступит нескоро.</P>
            <DIV id=mark_81 class=lecture_mark></DIV>
            <P id=id_82>На рисунке (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/3/staldata_3.html#image.3.2">рис. 
            3.2</A>) изображена ситуация, иллюстрирующая перекладывание 7 колец 
            со стержня <SPAN class=texample>А</SPAN> на <SPAN 
            class=texample>В</SPAN> через вспомогательный <SPAN 
            class=texample>С</SPAN>.</P>
            <DIV id=mark_82 class=lecture_mark></DIV>
            <P id=id_86 align=left><A name=image.3.2></A>
            <DIV><IMG alt="Ситуация при переносе семи колец" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/03_02.png" 
            width=324 height=117></DIV><BR><B>Рис. 3.2.</B>&nbsp; Ситуация при 
            переносе семи колец
            <P></P>
            <DIV id=mark_86 class=lecture_mark></DIV>
            <P id=id_87>Кольцо со стержня <SPAN class=texample>А</SPAN> можно 
            перенести на стержень <SPAN class=texample>В</SPAN> или <SPAN 
            class=texample>С</SPAN>, кольцо со стержня <SPAN 
            class=texample>В</SPAN> можно перенести на стержень <SPAN 
            class=texample>С</SPAN>, однако, нельзя перенести его на стержень 
            <SPAN class=texample>А</SPAN>.</P>
            <DIV id=mark_87 class=lecture_mark></DIV>
            <P id=id_94>Задача состоит в том, чтобы определить 
            последовательность минимальной длины переноса колец. Решением задачи 
            будем считать последовательность допустимых переносов, каждый из 
            которых имеет вид: <SPAN class=texample>A<IMG 
            style="POSITION: relative; TOP: 2px" border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/srarr.gif" 
            width=15 height=18>B, A<IMG style="POSITION: relative; TOP: 2px" 
            border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/srarr.gif" 
            width=15 height=18>C, B<IMG style="POSITION: relative; TOP: 2px" 
            border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/srarr.gif" 
            width=15 height=18>A, B<IMG style="POSITION: relative; TOP: 2px" 
            border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/srarr.gif" 
            width=15 height=18>C, C<IMG style="POSITION: relative; TOP: 2px" 
            border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/srarr.gif" 
            width=15 height=18>A, C<IMG style="POSITION: relative; TOP: 2px" 
            border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/srarr.gif" 
            width=15 height=18>B</SPAN>. Если кольцо всего одно, то задача 
            решается за один перенос <SPAN class=texample>A<IMG 
            style="POSITION: relative; TOP: 2px" border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/srarr.gif" 
            width=15 height=18>В</SPAN>. Для перемещения двух колец требуется 
            выполнить три действия: <SPAN class=texample>A<IMG 
            style="POSITION: relative; TOP: 2px" border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/srarr.gif" 
            width=15 height=18>C, A<IMG style="POSITION: relative; TOP: 2px" 
            border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/srarr.gif" 
            width=15 height=18>В, C<IMG style="POSITION: relative; TOP: 2px" 
            border=0 alt="" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/srarr.gif" 
            width=15 height=18>B</SPAN>. Решение задачи для трех колец содержит 
            семь действий, для четырех – 15.</P>
            <DIV id=mark_94 class=lecture_mark></DIV>
            <P id=id_98>Напишем рекурсивную функцию, которая находит решение для 
            произвольного числа колец.</P>
            <DIV id=mark_98 class=lecture_mark></DIV>
            <P id=id_99><SPAN class=xml_em_italic>Параметризация</SPAN>. Функция 
            имеет четыре параметра, первый параметр – число переносимых колец, 
            второй параметр – стрежень, на который первоначально нанизаны 
            кольца. Третий параметр функции – стержень, на который требуется 
            перенести кольца, и, наконец, четвертый параметр – стержень, который 
            разрешено использовать в качестве вспомогательного. </P>
            <DIV id=mark_99 class=lecture_mark></DIV>
            <P id=id_100><SPAN class=xml_em_italic>База рекурсии</SPAN>. Перенос 
            одного стержня.</P>
            <DIV id=mark_100 class=lecture_mark></DIV>
            <P id=id_101><SPAN class=xml_em_italic>Декомпозиция</SPAN>. 
            Последовательность переноса колец изображена на рисунке (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/3/staldata_3.html#image.3.3">рис. 
            3.3</A>).</P>
            <DIV id=mark_101 class=lecture_mark></DIV>
            <P id=id_102 align=left><A name=image.3.3></A>
            <DIV><IMG 
            alt="Схема решения задачи о Ханойских башнях для четырех колец" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/03_03.png" 
            width=366 height=458></DIV><BR><B>Рис. 3.3.</B>&nbsp; Схема решения 
            задачи о Ханойских башнях для четырех колец
            <P></P>
            <DIV id=mark_102 class=lecture_mark></DIV>
            <P id=id_103>Чтобы перенести <SPAN class=texample>n</SPAN> колец со 
            стержня <SPAN class=texample>A</SPAN> на стержень <SPAN 
            class=texample>B</SPAN>, используя стрежень <SPAN 
            class=texample>C</SPAN> в качестве вспомогательного, можно поступить 
            следующим образом:</P>
            <DIV id=mark_103 class=lecture_mark></DIV>
            <UL id=id_108>
              <LI>перенести <SPAN class=texample>n</SPAN>–1 кольцо со стержня 
              <SPAN class=texample>A</SPAN> на <SPAN class=texample>C</SPAN>, 
              используя стержень <SPAN class=texample>B</SPAN> в качестве 
              вспомогательного стержня;
              <LI>перенести последнее кольцо со стержня <SPAN 
              class=texample>A</SPAN> на стержень <SPAN class=texample>B</SPAN>;
              <LI>перенести <SPAN class=texample>n</SPAN>–1 кольцо со стержня 
              <SPAN class=texample>C</SPAN> на <SPAN class=texample>B</SPAN>, 
              используя стержень <SPAN class=texample>A</SPAN> в качестве 
              вспомогательного стержня.</LI></UL>
            <DIV id=mark_108 class=lecture_mark></DIV>
            <P id=id_122>При переносе <SPAN class=texample>n</SPAN>–1 кольца 
            можно воспользоваться тем же алгоритмом, т.к. на нижнее кольцо с 
            самым большим диаметром можно просто не обращать внимания. Перенос 
            одного кольца в программе выражается в том, что выводится 
            соответствующий ход. </P>
            <DIV id=mark_122 class=lecture_mark></DIV>
            <DIV class=example><PRE>//Ханойские башни
#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
int hanoj(int n, char A, char B, char C); 
//Объявление функции перемещения колец с A на C через B

int _tmain(int argc, _TCHAR* argv[]){
  char x='A',y='B',z='C';
  int k,h;
  printf("Задача о Ханойских башнях");
  printf("\nВведите количество колец: "); 
  scanf("%d",&amp;k); 
  h=hanoj(k,x,z,y);
  printf("\nКоличество перекладываний равно %d",h);
  system("pause");
  return 0;
}

//Описание функции перемещения колец с A на C через B
int hanoj(int n, char A, char B, char C){  
  int num;
  if (n == 1) {printf("\n   %c -&gt; %c", A, C); num = 1;}
  else {
    num=hanoj(n-1, A, C, B);
    printf("\n   %c -&gt; %c", A, C);
    num++;
    num+=hanoj(n-1, B, A, C);
    }
  return num;
}
</PRE></DIV><A name=sect2></A>
            <H3>Ключевые термины</H3>
            <P id=id_125><B>База рекурсии</B> – это тривиальный случай, при 
            котором решение задачи очевидно, то есть не требуется обращение 
            функции к себе.</P>
            <DIV id=mark_125 class=lecture_mark></DIV>
            <P id=id_126><B>Декомпозиция</B> – это выражение общего случая через 
            более простые подзадачи с измененными параметрами.</P>
            <DIV id=mark_126 class=lecture_mark></DIV>
            <P id=id_127><B>Косвенная (взаимная) рекурсия</B> – это 
            последовательность взаимных вызовов нескольких функций, 
            организованная в виде циклического замыкания на тело первоначальной 
            функции, но с иным набором параметров.</P>
            <DIV id=mark_127 class=lecture_mark></DIV>
            <P id=id_128><B>Параметризация</B> – это выделение из постановки 
            задачи параметров, которые используются для описания условия задачи 
            и решения.</P>
            <DIV id=mark_128 class=lecture_mark></DIV>
            <P id=id_129><B>Прямая рекурсия</B> – это непосредственное обращение 
            рекурсивной функции к себе, но с иным набором входных данных. </P>
            <DIV id=mark_129 class=lecture_mark></DIV>
            <P id=id_130><B>Рекурсивная триада</B> – это этапы решения задач 
            рекурсивным методом.</P>
            <DIV id=mark_130 class=lecture_mark></DIV>
            <P id=id_131><B>Рекурсивная функция</B> – это функция, которая в 
            своем теле содержит обращение к самой себе с измененным набором 
            параметров.</P>
            <DIV id=mark_131 class=lecture_mark></DIV>
            <P id=id_132><B>Рекурсивный алгоритм</B> – это алгоритм, в 
            определении которого содержится прямой или косвенный вызов этого же 
            алгоритма.</P>
            <DIV id=mark_132 class=lecture_mark></DIV>
            <P id=id_133><B>Рекурсивный стек</B> – это область памяти, 
            предназначенная для хранения всех промежуточных значений локальных 
            переменных при каждом следующем рекурсивном обращении.</P>
            <DIV id=mark_133 class=lecture_mark></DIV>
            <P id=id_134><B>Рекурсия в программировании</B> – это пошаговое 
            разбиение задачи на подзадачи, подобные исходной.</P>
            <DIV id=mark_134 class=lecture_mark></DIV>
            <P id=id_135><B>Рекурсия в широком смысле</B> – это определение 
            объекта посредством ссылки на себя.</P>
            <DIV id=mark_135 class=lecture_mark></DIV><A name=sect3></A>
            <H3>Краткие итоги</H3>
            <OL id=id_136>
              <LI>Свойством рекурсивности характеризуются объекты окружающего 
              мира, обладающие самоподобием.
              <LI>Рекурсия в широком смысле характеризуется определением объекта 
              посредством ссылки на себя.
              <LI>Рекурсивные функции содержат в своем теле обращение к самим 
              себе с измененным набором параметров. При этом обращение к себе 
              может быть организовано через цепочку взаимных обращений функций.
              <LI>Решение задач рекурсивными способами проводится посредством 
              разработки рекурсивной триады.
              <LI>Целесообразность применения рекурсии в программировании 
              обусловлена спецификой задач, в постановке которых явно или 
              опосредовано указывается на возможность сведения задачи к 
              подзадачам, аналогичным самой задаче.
              <LI>Область памяти, предназначенная для хранения всех 
              промежуточных значений локальных переменных при каждом следующем 
              рекурсивном обращении, образует рекурсивный стек.
              <LI>Рекурсивные методы решения задач нашли широкое применение в 
              процедурном программировании.</LI></OL>
            <DIV id=mark_136 class=lecture_mark></DIV><A name=sect4></A>
            <H3>Лабораторная работа 3. Рекурсивные функции.</H3>
            <P id=id_144><B>Цель работы:</B> изучить понятия рекурсии, 
            рекурсивные функции в программировании, приемы построения 
            рекурсивной триады при решении задач, научиться применять 
            рекурсивные методы в решении задач на языке С++.</P>
            <DIV id=mark_144 class=lecture_mark></DIV>
            <P id=id_145>При выполнении лабораторной работы для каждого задания 
            требуется написать программу на языке С++, которая получает на входе 
            числовые данные, выполняет их обработку в соответствии с 
            требованиями задания и выводит результат на экран. Ввод данных 
            осуществляется с клавиатуры с учетом требований к входным данным, 
            содержащихся в постановке задачи (ввод данных сопровождайте 
            диалогом). Ограничениями на входные данные является допустимый 
            диапазон значений используемых числовых типов в языке С++.</P>
            <DIV id=mark_145 class=lecture_mark></DIV>
            <P id=id_146><B>Теоретические сведения.</B></P>
            <DIV id=mark_146 class=lecture_mark></DIV>
            <P id=id_147>Ознакомьтесь с материалом лекции 3.</P>
            <DIV id=mark_147 class=lecture_mark></DIV>
            <P id=id_148><B>Задания к лабораторной работе.</B></P>
            <DIV id=mark_148 class=lecture_mark></DIV>
            <P id=id_149>Выполните приведенные ниже задания.</P>
            <DIV id=mark_149 class=lecture_mark></DIV>
            <OL id=id_150>
              <LI>Определите закономерность формирования членов 
              последовательности. Найдите <SPAN class=texample>n</SPAN>-ый член 
              последовательности: 1, 1, 2, 3, 5, 8, 13, ...
              <LI>Составьте программу вычисления биномиального коэффициента <IMG 
              style="POSITION: relative; DISPLAY: inline; TOP: 5px" alt=C_m^n 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/a0863793ff8f68b0588333a54f47c7dc.png" 
              width=31 height=20> для данных неотрицательных целых <IMG 
              style="POSITION: relative; DISPLAY: inline; TOP: 8px" 
              alt="m, n (m\geq n): C_m^n=\frac{m!}{n!\cdot (m-n)!}" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/4844c1498ee338f571a0ea4126ebe8bc.png" 
              width=237 height=29>. Решите задачу двумя способами: 1 – 
              используйте функцию вычисления факториала; 2 – выразите вычисление 
              <IMG style="POSITION: relative; DISPLAY: inline; TOP: 5px" 
              alt=C_m^n 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/a0863793ff8f68b0588333a54f47c7dc.png" 
              width=31 height=20> через <IMG 
              style="POSITION: relative; DISPLAY: inline; TOP: 7px" 
              alt=C_{m-1}^{n-1} 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/d6b8159ac3d6cb4a647230f7e82acce1.png" 
              width=47 height=25>.
              <LI>Исполнитель умеет выполнять два действия: "+1", "*2". 
              Составьте программу получения из числа 1 числа 100 за наименьшее 
              количество операций.
              <LI>Найдите наибольший общий делитель двух натуральных чисел с 
              помощью алгоритма Евклида.
              <LI>Дано натуральное число, кратное 3. Получите сумму кубов этого 
              числа, затем сумму кубов получившегося числа и т.д. Проверьте на 
              нескольких примерах, действительно ли в конечном итоге получится 
              153.
              <LI>Разработайте программу вычисления <SPAN 
              class=texample>a<SUP>n</SUP></SPAN> натуральной степени <SPAN 
              class=texample>n</SPAN> вещественного числа <SPAN 
              class=texample>a</SPAN> за наименьшее число операций.</LI></OL>
            <DIV id=mark_150 class=lecture_mark></DIV>
            <P id=id_165><B>Указания к выполнению работы.</B></P>
            <DIV id=mark_165 class=lecture_mark></DIV>
            <P id=id_166>Каждое задание необходимо решить в соответствии с 
            изученными рекурсивными методами решения задач и методами обработки 
            числовых данных в языке С++. Перед реализацией кода каждой задачи 
            необходимо разработать рекурсивную триаду в соответствии с 
            постановкой задачи. Программу для решения каждого задания необходимо 
            разработать методом процедурной абстракции, используя рекурсивные 
            функции. Этапы сопроводить комментариями в коде.</P>
            <DIV id=mark_166 class=lecture_mark></DIV>
            <P id=id_167>Следует реализовать каждое задание в соответствии с 
            приведенными этапами:</P>
            <DIV id=mark_167 class=lecture_mark></DIV>
            <UL id=id_168>
              <LI>изучить словесную постановку задачи, выделив при этом все виды 
              данных;
              <LI>сформулировать математическую постановку задачи;
              <LI>выбрать метод решения задачи, если это необходимо;
              <LI>разработать графическую схему алгоритма;
              <LI>записать разработанный алгоритм на языке С++;
              <LI>разработать контрольный тест к программе;
              <LI>отладить программу;
              <LI>представить отчет по работе.</LI></UL>
            <DIV id=mark_168 class=lecture_mark></DIV>
            <P id=id_177><B>Требования к отчету.</B></P>
            <DIV id=mark_177 class=lecture_mark></DIV>
            <P id=id_178>Отчет по лабораторной работе должен соответствовать 
            следующей структуре.</P>
            <DIV id=mark_178 class=lecture_mark></DIV>
            <UL id=id_179>
              <LI>Титульный лист.
              <LI>Словесная постановка задачи. В этом подразделе проводится 
              полное описание задачи. Описывается суть задачи, анализ входящих в 
              нее физических величин, область их допустимых значений, единицы их 
              измерения, возможные ограничения, анализ условий при которых 
              задача имеет решение (не имеет решения), анализ ожидаемых 
              результатов.
              <LI>Математическая модель. В этом подразделе вводятся 
              математические описания физических величин и математическое 
              описание их взаимодействий. Цель подраздела – представить решаемую 
              задачу в математической формулировке.
              <LI>Алгоритм решения задачи. В подразделе описывается разработка 
              структуры алгоритма, обосновывается абстракция данных, задача 
              разбивается на подзадачи. Схема алгоритма выполняется по ЕСПД 
              (ГОСТ 19.003-80 и ГОСТ 19.002-80).
              <LI>Листинг программы. Подраздел должен содержать текст программы 
              на языке программирования С++, реализованный в среде MS Visual 
              Studio 2010.
              <LI>Контрольный тест. Подраздел содержит наборы исходных данных и 
              полученные в ходе выполнения программы результаты.
              <LI>Выводы по лабораторной работе. 
              <LI>Ответы на контрольные вопросы.</LI></UL>
            <DIV id=mark_179 class=lecture_mark></DIV>
            <P id=id_188>Контрольные вопросы</P>
            <DIV id=mark_188 class=lecture_mark></DIV>
            <UL id=id_189>
              <LI>Приведите примеры рекурсивных объектов и явлений. Обоснуйте 
              проявление рекурсивности.
              <LI>Почему при правильной организации рекурсивные вызовы не 
              зацикливаются?
              <LI>Почему не отождествляются совпадающие идентификаторы при 
              многократных рекурсивных вызовах?
              <LI>Почему рекурсивные обращения завершаются в порядке, обратном 
              вызовам этих обращений?
              <LI>Чем ограничено при выполнении программы количество рекурсивных 
              вызовов?
              <LI>Какой из методов в программировании является более эффективным 
              – рекурсивный или итерационный?</LI></UL>
            <DIV id=mark_189 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript 
src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/urchin.js">
</SCRIPT>

<SCRIPT 
type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
