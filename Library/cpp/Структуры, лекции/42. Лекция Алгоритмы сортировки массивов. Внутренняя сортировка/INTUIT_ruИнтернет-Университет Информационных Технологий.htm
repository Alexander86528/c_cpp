<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0071)http://www.intuit.ru/department/algorithms/staldata/42/staldata_42.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/printable.css">
<META name=GENERATOR content="MSHTML 9.00.8080.16413"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="COLOR: #000000; FONT-WEIGHT: bold">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD>
    <TD><!-- content -->
      <TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD class=head>Структуры и алгоритмы компьютерной обработки 
        данных</TD></TR>
        <TR>
          <TD height=4><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>42. Лекция: Алгоритмы сортировки массивов. 
            Внутренняя сортировка: версия для печати и PDA</SPAN> <BR><SPAN 
            class=rtxt>В лекции рассматриваются определение и классификация 
            алгоритмов сортировок массивов, в частности, быстрых сортировок, 
            изучаются параметры, характеризующие трудоемкость алгоритмов 
            сортировок, рассматриваются описания и примеры программных кодов 
            следующих алгоритмов быстрых сортировок: бинарная пирамидальная 
            сортировка, сортировка слиянием, сортировка Шелла и сортировка 
            Хоара. </SPAN></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3></H3>
            <P id=id_1><B>Цель лекции:</B> изучить основные алгоритмы внутренних 
            сортировок и научиться решать задачи сортировок массивов различными 
            методами (бинарная пирамидальная сортировка, метод Шелла, быстрая 
            сортировка Хоара, сортировка слиянием).</P>
            <DIV id=mark_1 class=lecture_mark></DIV>
            <P id=id_2>Сортировка является одной из фундаментальных 
            алгоритмических задач программирования. Решению проблем, связанных с 
            сортировкой, посвящено множество научных исследований, разработано 
            множество алгоритмов.</P>
            <DIV id=mark_2 class=lecture_mark></DIV>
            <P id=id_3>В общем случае сортировку следует понимать как процесс 
            перегруппировки, заданного множества объектов в определенном 
            порядке. Сортировка применяется во всех без исключения областях 
            программирования, будь то базы данных или математические 
            программы.</P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <P id=id_4><B>Алгоритмом сортировки</B> называется алгоритм для 
            упорядочения некоторого множества элементов. Обычно под алгоритмом 
            сортировки подразумевают алгоритм упорядочивания множества элементов 
            по возрастанию или убыванию. </P>
            <DIV id=mark_4 class=lecture_mark></DIV>
            <P id=id_5>В случае наличия элементов с одинаковыми значениями, в 
            упорядоченной последовательности они располагаются рядом друг за 
            другом в любом порядке. Однако иногда бывает полезно сохранять 
            первоначальный порядок элементов с одинаковыми значениями.</P>
            <DIV id=mark_5 class=lecture_mark></DIV>
            <P id=id_6>В алгоритмах сортировки лишь часть данных используется в 
            качестве ключа сортировки. <SPAN class=xml_em_italic>Ключом 
            сортировки</SPAN> называется атрибут (или несколько атрибутов), по 
            значению которого определяется порядок элементов. Таким образом, при 
            написании алгоритмов сортировок массивов следует учесть, что ключ 
            полностью или частично совпадает с данными.</P>
            <DIV id=mark_6 class=lecture_mark></DIV>
            <P id=id_7>Практически каждый алгоритм сортировки можно разбить на 3 
            части:</P>
            <DIV id=mark_7 class=lecture_mark></DIV>
            <UL id=id_8>
              <LI>сравнение, определяющее упорядоченность пары элементов;
              <LI>перестановку, меняющую местами пару элементов;
              <LI>собственно сортирующий алгоритм, который осуществляет 
              сравнение и перестановку элементов до тех пор, пока все элементы 
              множества не будут упорядочены.</LI></UL>
            <DIV id=mark_8 class=lecture_mark></DIV>
            <P id=id_12>Алгоритмы сортировки имеют большое практическое 
            применение. Их можно встретить там, где речь идет об обработке и 
            хранении больших объемов информации. Некоторые задачи обработки 
            данных решаются проще, если данные заранее упорядочить.</P>
            <DIV id=mark_12 class=lecture_mark></DIV><A name=sect2></A>
            <H3>Оценка алгоритмов сортировки</H3>
            <P id=id_13>Ни одна другая проблема не породила такого количества 
            разнообразнейших решений, как задача сортировки. Универсального, 
            наилучшего алгоритма сортировки на данный момент не существует. 
            Однако, имея приблизительные характеристики входных данных, можно 
            подобрать метод, работающий оптимальным образом. Для этого 
            необходимо знать параметры, по которым будет производиться оценка 
            алгоритмов.</P>
            <DIV id=mark_13 class=lecture_mark></DIV>
            <UL id=id_14>
              <LI><SPAN class=xml_em_italic>Время сортировки</SPAN> – основной 
              параметр, характеризующий быстродействие алгоритма.
              <LI><SPAN class=xml_em_italic>Память</SPAN> – один из параметров, 
              который характеризуется тем, что ряд алгоритмов сортировки требуют 
              выделения дополнительной памяти под временное хранение данных. При 
              оценке используемой памяти не будет учитываться место, которое 
              занимает исходный массив данных и независящие от входной 
              последовательности затраты, например, на хранение кода программы.
              <LI><SPAN class=xml_em_italic>Устойчивость</SPAN> – это параметр, 
              который отвечает за то, что сортировка не меняет взаимного 
              расположения равных элементов. 
              <LI><SPAN class=xml_em_italic>Естественность поведения</SPAN> – 
              параметр, которой указывает на эффективность метода при обработке 
              уже отсортированных, или частично отсортированных данных. Алгоритм 
              ведет себя естественно, если учитывает эту характеристику входной 
              последовательности и работает лучше. </LI></UL>
            <DIV id=mark_14 class=lecture_mark></DIV><A name=sect3></A>
            <H3></H3>
            <P id=id_19>Классификация алгоритмов сортировок</P>
            <DIV id=mark_19 class=lecture_mark></DIV>
            <P id=id_20>Все разнообразие и многообразие алгоритмов сортировок 
            можно классифицировать по различным признакам, например, по 
            устойчивости, по поведению, по использованию операций сравнения, по 
            потребности в дополнительной памяти, по потребности в знаниях о 
            структуре данных, выходящих за рамки операции сравнения, и 
            другие.</P>
            <DIV id=mark_20 class=lecture_mark></DIV>
            <P id=id_21>Наиболее подробно рассмотрим классификацию алгоритмов 
            сортировки по сфере применения. В данном случае основные типы 
            упорядочивания делятся следующим образом.</P>
            <DIV id=mark_21 class=lecture_mark></DIV>
            <UL id=id_22>
              <LI><SPAN class=xml_em_italic>Внутренняя сортировка</SPAN> – это 
              алгоритм сортировки, который в процессе упорядочивания данных 
              использует только оперативную память (ОЗУ) компьютера. То есть 
              оперативной памяти достаточно для помещения в нее сортируемого 
              массива данных с произвольным доступом к любой ячейке и собственно 
              для выполнения алгоритма. Внутренняя сортировка применяется во 
              всех случаях, за исключением однопроходного считывания данных и 
              однопроходной записи отсортированных данных. В зависимости от 
              конкретного алгоритма и его реализации данные могут сортироваться 
              в той же области памяти, либо использовать дополнительную 
              оперативную память.
              <LI><SPAN class=xml_em_italic>Внешняя сортировка</SPAN> – это 
              алгоритм сортировки, который при проведении упорядочивания данных 
              использует внешнюю память, как правило, жесткие диски. Внешняя 
              сортировка разработана для обработки больших списков данных, 
              которые не помещаются в оперативную память. Обращение к различным 
              носителям накладывает некоторые дополнительные ограничения на 
              данный алгоритм: доступ к носителю осуществляется последовательным 
              образом, то есть в каждый момент времени можно считать или 
              записать только элемент, следующий за текущим; объем данных не 
              позволяет им разместиться в ОЗУ.</LI></UL>
            <DIV id=mark_22 class=lecture_mark></DIV>
            <P id=id_25>Внутренняя сортировка является базовой для любого 
            алгоритма внешней сортировки – отдельные части массива данных 
            сортируются в оперативной памяти и с помощью специального алгоритма 
            сцепляются в один массив, упорядоченный по ключу.</P>
            <DIV id=mark_25 class=lecture_mark></DIV>
            <P id=id_26>Следует отметить, что внутренняя сортировка значительно 
            эффективней внешней, так как на обращение к оперативной памяти 
            затрачивается намного меньше времени, чем к носителям.</P>
            <DIV id=mark_26 class=lecture_mark></DIV>
            <P id=id_27>Рассмотрим основные алгоритмы внутренних сортировок, 
            которые называются усовершенствованными (логарифмическими).</P>
            <DIV id=mark_27 class=lecture_mark></DIV><A name=sect4></A>
            <H3>Бинарная пирамидальная сортировка</H3>
            <P id=id_28>Данный метод сортировки был предложен Дж. У. Дж. 
            Уильямсом и Р.У. Флойдом в 1964 году. Пирамидальная сортировка в 
            некотором роде является модификацией такого подхода, как сортировка 
            выбором, с тем лишь отличием, что минимальный (или максимальный) 
            элемент из неотсортированной последовательности выбирается за 
            меньшее количество операций. Для такого быстрого выбора из этой 
            неотсортированной последовательности строится некоторая структура. 
            Именно суть данного метода и состоит в построении такой структуры, 
            которая называется пирамидой.</P>
            <DIV id=mark_28 class=lecture_mark></DIV>
            <P id=id_29><B>Пирамида (сортирующее дерево, двоичная куча)</B> – 
            двоичное дерево с упорядоченными листьями (корень дерева – 
            наименьший или наибольший элемент). Пирамиду можно представить в 
            виде массива. Первый элемент пирамиды является наименьшим или 
            наибольшим, что зависит от ключа сортировки.</P>
            <DIV id=mark_29 class=lecture_mark></DIV>
            <P id=id_30><B>Просеивание</B> – это построение новой пирамиды по 
            следующему алгоритму: новый элемент помещается в вершину дерева, 
            далее он перемещается ("просеивается") по пути вниз на основе 
            сравнения с дочерними элементами. Спуск завершается, если результат 
            сравнения с дочерними элементами соответствует ключу сортировки.</P>
            <DIV id=mark_30 class=lecture_mark></DIV>
            <P id=id_31>Последовательность чисел <SPAN 
            class=texample>x<SUB>i</SUB>,x<SUB>i+1</SUB>,...,x<SUB>i</SUB></SPAN> 
            формирует пирамиду, если для всех <SPAN class=texample>k=i, 
            i+1,...,n/2</SPAN> выполняются неравенства <SPAN 
            class=texample>x<SUB>k</SUB> &gt; x<SUB>2k</SUB>, x<SUB>k</SUB> &gt; 
            x<SUB>i</SUB></SPAN> (или <SPAN class=texample>x<SUB>k</SUB> &lt; 
            x<SUB>2k</SUB>, x<SUB>k</SUB> &lt; x<SUB>2k+1</SUB></SPAN>). 
            Элементы <SPAN class=texample>x<SUB>2i</SUB></SPAN> и <SPAN 
            class=texample>x<SUB>2i+1</SUB></SPAN> называются потомками элемента 
            <SPAN class=texample>x<SUB>i</SUB></SPAN>.</P>
            <DIV id=mark_31 class=lecture_mark></DIV>
            <P id=id_39>Массив чисел 12 10 7 5 8 7 3 является пирамидой. Такой 
            массив удобно изображать в виде дерева. Первый элемент массива, 
            элементы которого образуют собой пирамиду, является наибольшим (или 
            наименьшим). Если массив представлен в виде пирамиды, то массив 
            легко отсортировать.</P>
            <DIV id=mark_39 class=lecture_mark></DIV>
            <P id=id_40><SPAN class=xml_em_italic>Алгоритм пирамидальной 
            сортировки.</SPAN></P>
            <DIV id=mark_40 class=lecture_mark></DIV>
            <P id=id_41>Шаг 1. Преобразовать массив в пирамиду (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/42/staldata_42.html#image.42.1">рис. 
            1. А</A>).</P>
            <DIV id=mark_41 class=lecture_mark></DIV>
            <P id=id_42>Шаг 2. Использовать алгоритм сортировки пирамиды (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/42/staldata_42.html#image.42.1">рис. 
            1. В – H</A>).</P>
            <DIV id=mark_42 class=lecture_mark></DIV>
            <P id=id_43><SPAN class=xml_em_italic>Алгоритм преобразования 
            массива в пирамиду (построение пирамиды)</SPAN>. Пусть дан массив 
            <SPAN class=texample>x[1],x[2],...,x[n]</SPAN>.</P>
            <DIV id=mark_43 class=lecture_mark></DIV>
            <P id=id_45>Шаг 1. Устанавливаем <SPAN 
            class=texample>k=n/2</SPAN>.</P>
            <DIV id=mark_45 class=lecture_mark></DIV>
            <P id=id_47>Шаг 2. Перебираем элементы массива в цикле справа налево 
            для <SPAN class=texample>i=k,k-1,...,1</SPAN>. Если неравенства 
            <SPAN class=texample>x<SUB>i</SUB> &gt; x<SUB>2i</SUB>, 
            x<SUB>i</SUB> &gt; x<SUB>2i+1</SUB></SPAN> не выполняются, то 
            повторяем перестановки <SPAN class=texample>x<SUB>i</SUB></SPAN> с 
            наибольшим из потомков. Перестановки завершаются при выполнении 
            неравенств <SPAN class=texample>x<SUB>i</SUB> &gt; x<SUB>2i</SUB>, 
            x<SUB>i</SUB> &gt; x<SUB>2i+1</SUB></SPAN>.</P>
            <DIV id=mark_47 class=lecture_mark></DIV>
            <P id=id_52><SPAN class=xml_em_italic>Алгоритм сортировки 
            пирамиды</SPAN>.</P>
            <DIV id=mark_52 class=lecture_mark></DIV>
            <P id=id_53>Рассмотрим массив размерности <SPAN 
            class=texample>n</SPAN>, который представляет пирамиду <SPAN 
            class=texample>x[1],x[2],...,x[n]</SPAN>.</P>
            <DIV id=mark_53 class=lecture_mark></DIV>
            <P id=id_56>Шаг 1. Переставляем элементы <SPAN 
            class=texample>x[1]</SPAN> и <SPAN class=texample>x[n]</SPAN>.</P>
            <DIV id=mark_56 class=lecture_mark></DIV>
            <P id=id_59>Шаг 2. Определяем <SPAN class=texample>n=n-1</SPAN>. Это 
            эквивалентно тому, что в массиве из дальнейшего рассмотрения 
            исключается элемент <SPAN class=texample>x[n]</SPAN>.</P>
            <DIV id=mark_59 class=lecture_mark></DIV>
            <P id=id_62>Шаг 3. Рассматриваем массив <SPAN 
            class=texample>x[1],x[2],...,x[n-1]</SPAN>, который получается из 
            исходного за счет исключения последнего элемента. Данный массив 
            из-за перестановки элементов уже не является пирамидой. Но такой 
            массив легко преобразовать в пирамиду. Это достигается повторением 
            перестановки значения элемента из <SPAN class=texample>x[1]</SPAN> с 
            наибольшим из потомков. Такая перестановка продолжается до тех пор, 
            пока элемент из <SPAN class=texample>x[1]</SPAN> не окажется на 
            месте элемента <SPAN class=texample>x[i]</SPAN> и при этом будут 
            выполняться неравенства <SPAN class=texample>x[i] &gt; x[2i], x[i] 
            &gt; x[2i+1]</SPAN>. Тем самым определяется новое место для значения 
            первого элемента из <SPAN class=texample>x[1]</SPAN> (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/42/staldata_42.html#image.42.1">рис. 
            1. С</A>).</P>
            <DIV id=mark_62 class=lecture_mark></DIV>
            <P id=id_69>Шаг 4. Повторяем шаги 2, 3, 4 до тех пор, пока не 
            получим <SPAN class=texample>n=1</SPAN>. Произвольный массив можно 
            преобразовать в пирамиду (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/42/staldata_42.html#image.42.1">рис. 
            1. D – H</A>).</P>
            <DIV id=mark_69 class=lecture_mark></DIV>
            <P id=id_71 align=left><A name=image.42.1></A>
            <DIV><IMG 
            alt="Демонстрация бинарной пирамидальной сортировки по неубыванию" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/42_01sm.png" 
            width=435 height=620></DIV><BR><A class=objectName 
            onclick="window.open('42_01.png','','menubar=no,scrollbars=yes,resizable=yes,width=657,height=915');return false;" 
            href="http://www.intuit.ru/department/algorithms/staldata/42/42_01.png" 
            target=_blank>увеличить изображение</A><BR><B>Рис. 42.1.</B>&nbsp; 
            Демонстрация бинарной пирамидальной сортировки по неубыванию
            <P></P>
            <DIV id=mark_71 class=lecture_mark></DIV>
            <P id=id_72>Построение пирамиды, ее сортировка и "просеивание" 
            элементов реализуются с помощью рекурсии. Базой рекурсии при этом 
            выступает пирамида из одного элемента, а сортировка и просеивание 
            элементов сводятся посредством декомпозиции к аналогичным действиям 
            с пирамидой из <SPAN class=texample>n-1</SPAN> элемента.</P>
            <DIV id=mark_72 class=lecture_mark></DIV>
            <DIV class=example><PRE>//Описание функции бинарной пирамидальной сортировки
void Binary_Pyramidal_Sort (int k,int *x){
  Build_Pyramid(k/2+1,k-1,x);
  Sort_Piramid(k-1,x);
}

//Построение пирамиды
void Build_Pyramid (int k, int r, int *x){
  Sifting(k,r,x);
  if (k &gt; 0)
    Build_Pyramid(k-1,r,x);
}

//Сортировка пирамиды
void Sort_Piramid (int k, int *x){
  Exchange (0,k,x);
  Sifting(0,k-1,x);
  if (k &gt; 1)
    Sort_Piramid(k-1,x);
}

//"Просеивание" элементов
void Sifting (int left, int right, int *x){
  int q, p, h;
  q=2*left+1;
  p=q+1;
  if (q &lt;= right){
    if (p &lt;= right &amp;&amp; x[p] &gt; x[q]) 
      q = p;
    if (x[left] &lt; x[q]){
      Exchange (left, q, x);
      Sifting(q, right, x);
    }
  }
}
//процедура обмена двух элементов
void Exchange (int i, int j, int *x){
  int tmp;
  tmp = x[i];
  x[i] = x[j];
  x[j] = tmp;
}
</PRE></DIV>
            <P id=id_75>Теоретическое время работы этого алгоритма можно 
            оценить, учитывая, что пирамидальная сортировка аналогична 
            построению пирамиды методом просеивания (при этом не учитывается 
            начальное построение пирамиды). Поэтому время работы алгоритма 
            пирамидальной сортировки без учета времени построения пирамиды будет 
            определяться по формуле <SPAN 
            class=texample>T<SUB>1</SUB>(n)=O(n·log n)</SPAN>.</P>
            <DIV id=mark_75 class=lecture_mark></DIV>
            <P id=id_77>Построение пирамиды занимает <SPAN 
            class=texample>T<SUB>2</SUB>(n)=O(n)</SPAN> операций за счет того, 
            что реальное время выполнения функции построения зависит от высоты 
            уже созданной части пирамиды.</P>
            <DIV id=mark_77 class=lecture_mark></DIV>
            <P id=id_79>Тогда общее время сортировки (с учетом построения 
            пирамиды) будет равно: <SPAN 
            class=texample>T(n)=T<SUB>1</SUB>(n)+T<SUB>2</SUB>(n)=O(n)+O(n·log 
            n)=O(n·log n)</SPAN>.</P>
            <DIV id=mark_79 class=lecture_mark></DIV>
            <P id=id_81>Пирамидальная сортировка не использует дополнительной 
            памяти. Метод не является устойчивым: по ходу работы массив так 
            "перетряхивается", что исходный порядок элементов может измениться 
            случайным образом. Поведение неестественно: частичная 
            упорядоченность массива никак не учитывается. Данная сортировка на 
            почти отсортированных массивах работает также долго, выигрыш ее 
            получается только на больших <SPAN class=texample>n</SPAN>.</P>
            <DIV id=mark_81 class=lecture_mark></DIV><A name=sect5></A>
            <H3>Сортировка методом Шелла</H3>
            <P id=id_83>Сортировка Шелла была названа в честь ее изобретателя – 
            Дональда Шелла, который опубликовал этот алгоритм в 1959 году. Общая 
            идея сортировки Шелла состоит в сравнении на начальных стадиях 
            сортировки пар значений, расположенных достаточно далеко друг от 
            друга в упорядочиваемом наборе данных. Такая модификация метода 
            сортировки позволяет быстро переставлять далекие неупорядоченные 
            пары значений (сортировка таких пар обычно требует большого 
            количества перестановок, если используется сравнение только соседних 
            элементов).</P>
            <DIV id=mark_83 class=lecture_mark></DIV>
            <P id=id_84><SPAN class=xml_em_italic>Общая схема метода</SPAN> 
            состоит в следующем. </P>
            <DIV id=mark_84 class=lecture_mark></DIV>
            <P id=id_85>Шаг 1. Происходит упорядочивание элементов <SPAN 
            class=texample>n/2</SPAN> пар <SPAN 
            class=texample>(x<SUB>i</SUB>,x<SUB>n/2+i</SUB>)</SPAN> для <SPAN 
            class=texample>1&lt;i&lt;n/2</SPAN>.</P>
            <DIV id=mark_85 class=lecture_mark></DIV>
            <P id=id_89>Шаг 2. Упорядочиваются элементы в <SPAN 
            class=texample>n/4</SPAN> группах из четырех элементов <SPAN 
            class=texample>(x<SUB>i</SUB>,x<SUB>n/4+i</SUB>,x<SUB>n/2+i</SUB>,x<SUB>3n/4+i</SUB>)</SPAN> 
            для <SPAN class=texample>1&lt;i&lt;n/4</SPAN>.</P>
            <DIV id=mark_89 class=lecture_mark></DIV>
            <P id=id_93>Шаг 3. Упорядочиваются элементы уже в <SPAN 
            class=texample>n/4</SPAN> группах из восьми элементов и т.д.</P>
            <DIV id=mark_93 class=lecture_mark></DIV>
            <P id=id_95>На последнем шаге упорядочиваются элементы сразу во всем 
            массиве <SPAN 
            class=texample>x<SUB>1</SUB>,x<SUB>2</SUB>,...,x<SUB>n</SUB></SPAN>. 
            На каждом шаге для упорядочивания элементов в группах используется 
            метод сортировки вставками (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/42/staldata_42.html#image.42.2">рис. 
            42.2</A>).</P>
            <DIV id=mark_95 class=lecture_mark></DIV>
            <P id=id_97>В настоящее время неизвестна последовательность <SPAN 
            class=texample>h<SUB>i</SUB>,h<SUB>i-1</SUB>,h<SUB>i-2</SUB>,...,h<SUB>1</SUB>,</SPAN>, 
            оптимальность которой доказана. Для достаточно больших массивов 
            рекомендуемой считается такая последовательность, что <SPAN 
            class=texample>h<SUB>i+1</SUB>=3h<SUB>i</SUB>+1</SPAN>, а <SPAN 
            class=texample>h<SUB>1</SUB>=1</SPAN>. Начинается процесс с <SPAN 
            class=texample>h<SUB>m</SUB></SPAN>, что <SPAN 
            class=texample>h<SUB>m</SUB>&gt;[n/9]</SPAN>. Иногда значение <SPAN 
            class=texample>h</SPAN> вычисляют проще: <SPAN 
            class=texample>h<SUB>i+1</SUB>=h<SUB>i</SUB>/2,h<SUB>1</SUB>=1,h<SUB>m</SUB>=n/2</SPAN>. 
            Это упрощенное вычисление <SPAN class=texample>h</SPAN> и будем 
            использовать далее.</P>
            <DIV id=mark_97 class=lecture_mark></DIV>
            <P id=id_106 align=left><A name=image.42.2></A>
            <DIV><IMG alt="Демонстрация сортировки по неубыванию методом Шелла" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/42_02.png" 
            width=545 height=620></DIV><BR><B>Рис. 42.2.</B>&nbsp; Демонстрация 
            сортировки по неубыванию методом Шелла
            <P></P>
            <DIV id=mark_106 class=lecture_mark></DIV>
            <DIV class=example><PRE>//Описание функции сортировки Шелла
void Shell_Sort (int n, int *x){
  int h, i, j;
  for (h = n/2 ; h &gt; 0 ; h = h/2)
    for (i = 0 ; i &lt; n-h ; i++)
      for (j = i ; j &gt;= 0 ; j = j - h)
        if (x[j] &gt; x[j+h]) 
          Exchange (j, j+h, x);
        else j = 0;
}
//процедура обмена двух элементов
void Exchange (int i, int j, int *x){
  int tmp;
  tmp = x[i];
  x[i] = x[j];
  x[j] = tmp;
}

</PRE></DIV>
            <P id=id_108>Метод, предложенный Дональдом Л. Шеллом, является 
            неустойчивой сортировкой по месту. </P>
            <DIV id=mark_108 class=lecture_mark></DIV>
            <P id=id_109>Эффективность метода Шелла объясняется тем, что 
            сдвигаемые элементы быстро попадают на нужные места. Среднее время 
            для сортировки Шелла равняется , для худшего случая оценкой является 
            <SPAN class=texample>O(n<SUP>1.5</SUP>)</SPAN>.</P>
            <DIV id=mark_109 class=lecture_mark></DIV><A name=sect6></A>
            <H3>Быстрая сортировка Хоара</H3>
            <P id=id_111>Метод быстрой сортировки был впервые описан Ч.А.Р. 
            Хоаром в 1962 году. <SPAN class=xml_em_italic>Быстрая 
            сортировка</SPAN> – это общее название ряда алгоритмов, которые 
            отражают различные подходы к получению критичного параметра, 
            влияющего на производительность метода.</P>
            <DIV id=mark_111 class=lecture_mark></DIV>
            <P id=id_112>При общем рассмотрении алгоритма быстрой сортировки, 
            отметим, что этот метод основывается на последовательном разделении 
            сортируемого набора данных на блоки меньшего размера таким образом, 
            что между значениями разных блоков обеспечивается отношение 
            упорядоченности (для любой пары блоков все значения одного из этих 
            блоков не превышают значений другого блока).</P>
            <DIV id=mark_112 class=lecture_mark></DIV>
            <P id=id_113><SPAN class=xml_em_italic>Опорным (ведущим) 
            элементом</SPAN> называется некоторый элемент массива, который 
            выбирается определенный образом. С точки зрения корректности 
            алгоритма выбор опорного элемента безразличен. С точки зрения 
            повышения эффективности алгоритма выбираться должна медиана, но без 
            дополнительных сведений о сортируемых данных ее обычно невозможно 
            получить. Необходимо выбирать постоянно один и тот же элемент 
            (например, средний или последний по положению) или выбирать элемент 
            со случайно выбранным индексом.</P>
            <DIV id=mark_113 class=lecture_mark></DIV>
            <P id=id_114>Алгоритм быстрой сортировки Хоара</P>
            <DIV id=mark_114 class=lecture_mark></DIV>
            <P id=id_115>Пусть дан массив <SPAN class=texample>x[n]</SPAN> 
            размерности <SPAN class=texample>n</SPAN>.</P>
            <DIV id=mark_115 class=lecture_mark></DIV>
            <P id=id_118>Шаг 1. Выбирается опорный элемент массива.</P>
            <DIV id=mark_118 class=lecture_mark></DIV>
            <P id=id_119>Шаг 2. Массив разбивается на два – левый и правый – 
            относительно опорного элемента. Реорганизуем массив таким образом, 
            чтобы все элементы, меньшие опорного элемента, оказались слева от 
            него, а все элементы, большие опорного – справа от него.</P>
            <DIV id=mark_119 class=lecture_mark></DIV>
            <P id=id_120>Шаг 3. Далее повторяется шаг 2 для каждого из двух 
            вновь образованных массивов. Каждый раз при повторении 
            преобразования очередная часть массива разбивается на два меньших и 
            т. д., пока не получится массив из двух элементов (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/42/staldata_42.html#image.42.3">рис. 
            42.3</A>).</P>
            <DIV id=mark_120 class=lecture_mark></DIV>
            <P id=id_121>Быстрая сортировка стала популярной прежде всего 
            потому, что ее нетрудно реализовать, она хорошо работает на 
            различных видах входных данных и во многих случаях требует меньше 
            затрат ресурсов по сравнению с другими методами сортировки.</P>
            <DIV id=mark_121 class=lecture_mark></DIV>
            <P id=id_122>Выберем в качестве опорного элемент, расположенный на 
            средней позиции.</P>
            <DIV id=mark_122 class=lecture_mark></DIV>
            <P id=id_123 align=left><A name=image.42.3></A>
            <DIV><IMG alt="Демонстрация быстрой сортировки Хоара по неубыванию" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/42_03.png" 
            width=543 height=468></DIV><BR><B>Рис. 42.3.</B>&nbsp; Демонстрация 
            быстрой сортировки Хоара по неубыванию
            <P></P>
            <DIV id=mark_123 class=lecture_mark></DIV>
            <DIV class=example><PRE>//Описание функции сортировки Хоара
void Hoar_Sort (int k, int *x){
  Quick_Sort (0, k-1, x);
}

void Quick_Sort(int left, int right, int *x){
  int i, j, m, h;
  i = left;
  j = right;
  m = x[(i+j+1)/2];
  do {
    while (x[i] &lt; m) i++;
    while (x[j] &gt; m) j--;
    if (i &lt;= j) {
      Exchange(i,j,x);
      i++;
      j--;
    }
  } while(i &lt;= j);
  if (left &lt; j) 
    Quick_Sort (left, j, x);
  if (i &lt; right) 
    Quick_Sort (i, right, x);
}

//процедура обмена двух элементов
void Exchange (int i, int j, int *x){
  int tmp;
  tmp = x[i];
  x[i] = x[j];
  x[j] = tmp;
}
</PRE></DIV>
            <P id=id_125>Эффективность быстрой сортировки в значительной степени 
            определяется правильностью выбора опорных (ведущих) элементов при 
            формировании блоков. В худшем случае трудоемкость метода имеет ту же 
            сложность, что и пузырьковая сортировка, то есть порядка <SPAN 
            class=texample>O(n<SUP>2</SUP>)</SPAN>. При оптимальном выборе 
            ведущих элементов, когда разделение каждого блока происходит на 
            равные по размеру части, трудоемкость алгоритма совпадает с 
            быстродействием наиболее эффективных способов сортировки, то есть 
            порядка <SPAN class=texample>O(n log n)</SPAN>. В среднем случае 
            количество операций, выполняемых алгоритмом быстрой сортировки, 
            определяется выражением <SPAN class=texample>T(n) = O(1.4n log 
            n)</SPAN></P>
            <DIV id=mark_125 class=lecture_mark></DIV>
            <P id=id_129>Быстрая сортировка является наиболее эффективным 
            алгоритмом из всех известных методов сортировки, но все 
            усовершенствованные методы имеют один общий недостаток – невысокую 
            скорость работы при малых значениях <SPAN 
            class=texample>n</SPAN>.</P>
            <DIV id=mark_129 class=lecture_mark></DIV>
            <P id=id_131>Рекурсивная реализация быстрой сортировки позволяет 
            устранить этот недостаток путем включения прямого метода сортировки 
            для частей массива с небольшим количеством элементов. Анализ 
            вычислительной сложности таких алгоритмов показывает, что если 
            подмассив имеет девять или менее элементов, то целесообразно 
            использовать прямой метод (сортировку простыми вставками).</P>
            <DIV id=mark_131 class=lecture_mark></DIV><A name=sect7></A>
            <H3>Сортировка слиянием</H3>
            <P id=id_132>Алгоритм сортировки слиянием был изобретен Джоном фон 
            Нейманом в 1945 году. Он является одним из самых быстрых способов 
            сортировки.</P>
            <DIV id=mark_132 class=lecture_mark></DIV>
            <P id=id_133><SPAN class=xml_em_italic>Слияние</SPAN> – это 
            объединение двух или более упорядоченных массивов в один 
            упорядоченный.</P>
            <DIV id=mark_133 class=lecture_mark></DIV>
            <P id=id_134>Сортировка слиянием является одним из самых простых 
            алгоритмов сортировки (среди быстрых алгоритмов). Особенностью этого 
            алгоритма является то, что он работает с элементами массива 
            преимущественно последовательно, благодаря чему именно этот алгоритм 
            используется при сортировке в системах с различными аппаратными 
            ограничениями (например, при сортировке данных на жестком диске). 
            Кроме того, сортировка слиянием является алгоритмом, который может 
            быть эффективно использован для сортировки таких структур данных, 
            как связанные списки.</P>
            <DIV id=mark_134 class=lecture_mark></DIV>
            <P id=id_135>Данный алгоритм применяется тогда, когда есть 
            возможность использовать для хранения промежуточных результатов 
            память, сравнимую с размером исходного массива. Он построен на 
            принципе "разделяй и властвуй". Сначала задача разбивается на 
            несколько подзадач меньшего размера. Затем эти задачи решаются с 
            помощью рекурсивного вызова или непосредственно, если их размер 
            достаточно мал. Далее их решения комбинируются, и получается решение 
            исходной задачи (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/42/staldata_42.html#image.42.4">рис. 
            42.4</A>).</P>
            <DIV id=mark_135 class=lecture_mark></DIV>
            <P id=id_136>Процедура слияния требует два отсортированных массива. 
            Заметим, что массив из одного элемента по определению является 
            отсортированным.</P>
            <DIV id=mark_136 class=lecture_mark></DIV>
            <P id=id_137><SPAN class=xml_em_italic>Алгоритм сортировки 
            слиянием</SPAN></P>
            <DIV id=mark_137 class=lecture_mark></DIV>
            <P id=id_138>Шаг 1. Разбить имеющиеся элементы массива на пары и 
            осуществить слияние элементов каждой пары, получив отсортированные 
            цепочки длины 2 (кроме, быть может, одного элемента, для которого не 
            нашлось пары).</P>
            <DIV id=mark_138 class=lecture_mark></DIV>
            <P id=id_139>Шаг 2. Разбить имеющиеся отсортированные цепочки на 
            пары, и осуществить слияние цепочек каждой пары.</P>
            <DIV id=mark_139 class=lecture_mark></DIV>
            <P id=id_140>Шаг 3. Если число отсортированных цепочек больше 
            единицы, перейти к шагу 2.</P>
            <DIV id=mark_140 class=lecture_mark></DIV>
            <P id=id_141 align=left><A name=image.42.4></A>
            <DIV><IMG alt="Демонстрация сортировки слиянием по неубыванию" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/42_04.png" 
            width=544 height=436></DIV><BR><B>Рис. 42.4.</B>&nbsp; Демонстрация 
            сортировки слиянием по неубыванию
            <P></P>
            <DIV id=mark_141 class=lecture_mark></DIV>
            <DIV class=example><PRE>//Описание функции сортировки слиянием
void Merging_Sort (int n, int *x){
  int i, j, k, t, s, Fin1, Fin2;
  int* tmp = new int[n];
  k = 1;
  while (k &lt; n){
    t = 0;
    s = 0;
    while (t+k &lt; n){
      Fin1 = t+k;
      Fin2 = (t+2*k &lt; n ? t+2*k : n);
      i = t; 
      j = Fin1;
      for ( ; i &lt; Fin1 &amp;&amp; j &lt; Fin2 ; s++){
        if (x[i] &lt; x[j]) {
          tmp[s] = x[i];
          i++;
        }
        else {
          tmp[s] = x[j];
          j++;
        }
      }
      for ( ; i &lt; Fin1; i++, s++)
        tmp[s] = x[i];
      for ( ; j &lt; Fin2; j++, s++)
        tmp[s] = x[j];
      t = Fin2;
    }
    k *= 2;
    for (s = 0; s &lt; t; s++)
      x[s] = tmp[s];
  }
  delete(tmp);
}
</PRE></DIV>
            <P id=id_143>Недостаток алгоритма заключается в том, что он требует 
            дополнительную память размером порядка n (для хранения 
            вспомогательного массива). Кроме того, он не гарантирует сохранение 
            порядка элементов с одинаковыми значениями. Но его временная 
            сложность всегда пропорциональна <SPAN class=texample>O(n log 
            n)</SPAN>.</P>
            <DIV id=mark_143 class=lecture_mark></DIV><A name=sect8></A>
            <H3>Ключевые термины</H3>
            <P id=id_145><B>Алгоритм сортировки</B> – это алгоритм для 
            упорядочения некоторого множества элементов.</P>
            <DIV id=mark_145 class=lecture_mark></DIV>
            <P id=id_146><B>Бинарная пирамидальная сортировка</B> – это алгоритм 
            внутренней сортировки, основанный на построении пирамиды и 
            просеивании элементов из ее вершины методом спуска вниз в 
            соответствии с ключом сортировки.</P>
            <DIV id=mark_146 class=lecture_mark></DIV>
            <P id=id_147><B>Быстрая сортировка</B> – это общее название ряда 
            алгоритмов, которые отражают различные подходы к получению 
            критичного параметра, влияющего на производительность метода.</P>
            <DIV id=mark_147 class=lecture_mark></DIV>
            <P id=id_148><B>Внешняя сортировка</B> – это алгоритм сортировки, 
            который при проведении упорядочивания данных использует внешнюю 
            память, как правило, жесткие диски.</P>
            <DIV id=mark_148 class=lecture_mark></DIV>
            <P id=id_149><B>Внутренняя сортировка</B> – это алгоритм сортировки, 
            который в процессе упорядочивания данных использует только 
            оперативную память (ОЗУ) компьютера. </P>
            <DIV id=mark_149 class=lecture_mark></DIV>
            <P id=id_150><B>Время сортировки</B> – основной параметр 
            трудоемкости алгоритма, характеризующий быстродействие алгоритма 
            сортировки.</P>
            <DIV id=mark_150 class=lecture_mark></DIV>
            <P id=id_151><B>Естественность поведения</B> – это один из 
            параметров трудоемкости алгоритма, которой указывает на 
            эффективность метода при обработке уже отсортированных, или частично 
            отсортированных данных. </P>
            <DIV id=mark_151 class=lecture_mark></DIV>
            <P id=id_152><B>Ключ сортировки</B> – это атрибут (или несколько 
            атрибутов), по значению которого определяется порядок элементов во 
            множестве.</P>
            <DIV id=mark_152 class=lecture_mark></DIV>
            <P id=id_153><B>Опорный (ведущий) элемент</B> – это некоторый 
            элемент массива, который выбирается определенный образом, и 
            относительно которого происходит сравнение и перемещение элементов 
            между подмножествами массива. </P>
            <DIV id=mark_153 class=lecture_mark></DIV>
            <P id=id_154><B>Память</B> – один из параметров трудоемкости 
            алгоритма, который характеризует размер выделяемой дополнительной 
            памяти под временное хранение данных. </P>
            <DIV id=mark_154 class=lecture_mark></DIV>
            <P id=id_155><B>Пирамида (сортирующее дерево, двоичная куча)</B> – 
            это двоичное дерево с упорядоченными листьями, в корне которого 
            расположен максимальный или минимальный элемент.</P>
            <DIV id=mark_155 class=lecture_mark></DIV>
            <P id=id_156><B>Просеивание</B> – это построение новой пирамиды 
            посредством спуска вниз элемента из вершины дерева в соответствии с 
            ключом сортировки</P>
            <DIV id=mark_156 class=lecture_mark></DIV>
            <P id=id_157><B>Слияние</B> – это объединение двух или более 
            упорядоченных массивов в один упорядоченный.</P>
            <DIV id=mark_157 class=lecture_mark></DIV>
            <P id=id_158><B>Сортировка слиянием</B> – это одна из разновидностей 
            алгоритмов быстрых сортировок, основанная на слиянии подмножеств 
            массива.</P>
            <DIV id=mark_158 class=lecture_mark></DIV>
            <P id=id_159><B>Сортировка Хоара</B> – это одна из разновидностей 
            быстрых сортировок, основанная на упорядочивании подмножеств массива 
            относительно опорных элементов.</P>
            <DIV id=mark_159 class=lecture_mark></DIV>
            <P id=id_160><B>Сортировка Шелла</B> – это алгоритм внутренней 
            сортировки, основанный на сравнении и перемещении пар значений, 
            расположенных сначала достаточно далеко друг от друга в 
            упорядочиваемом наборе данных, с дальнейшим сокращением расстояний 
            между ними.</P>
            <DIV id=mark_160 class=lecture_mark></DIV>
            <P id=id_161><B>Устойчивость</B> – это один из параметров 
            трудоемкости алгоритма, который характеризует то, что сортировка не 
            меняет взаимного расположения равных элементов.</P>
            <DIV id=mark_161 class=lecture_mark></DIV><A name=sect9></A>
            <H3>Краткие итоги</H3>
            <OL id=id_162>
              <LI>Сортировка является одной из фундаментальных алгоритмических 
              задач программирования.
              <LI>Практически каждый алгоритм сортировки можно разбить на 3 
              части: сравнение, определяющее упорядоченность пары элементов; 
              перестановку, меняющую местами пару элементов; собственно 
              сортирующий алгоритм, который осуществляет сравнение и 
              перестановку элементов до тех пор, пока все элементы множества не 
              будут упорядочены.
              <LI>Для оценки трудоемкости алгоритмов сортировки используются 
              параметры: время сортировки, дополнительная память, устойчивость и 
              естественность поведения 
              <LI>По сфере применения алгоритмы сортировок классифицируются на 
              алгоритмы внутренних и внешних сортировок.
              <LI>Бинарная пирамидальная сортировка является алгоритмом 
              внутренней сортировки, основанный на построении пирамиды и 
              просеивании элементов из ее вершины методом спуска вниз в 
              соответствии с ключом сортировки
              <LI>Пирамидальная сортировка не использует дополнительной памяти. 
              Метод не является устойчивым. Поведение неестественно. Данная 
              сортировка на почти отсортированных массивах работает также долго, 
              выигрыш ее получается только на больших <SPAN 
              class=texample>n</SPAN>.
              <LI>Сортировка Шелла является алгоритмом внутренней сортировки, 
              основанный на сравнении и перемещении пар значений, расположенных 
              сначала достаточно далеко друг от друга в упорядочиваемом наборе 
              данных, с дальнейшим сокращением расстояний между ними.
              <LI>Сортировка Шелла является неустойчивой сортировкой по месту. 
              Эффективность метода Шелла объясняется тем, что сдвигаемые 
              элементы быстро попадают на нужные места.
              <LI>Сортировка Хоара является одной из разновидностей быстрых 
              сортировок, основанная на упорядочивании подмножеств массива 
              относительно опорных элементов.
              <LI>Эффективность быстрой сортировки в значительной степени 
              определяется правильностью выбора опорных элементов при 
              формировании блоков.
              <LI>Сортировка слиянием является одним из самых простых алгоритмов 
              сортировки среди быстрых алгоритмов, который может быть эффективно 
              использован для сортировки связанных списков.
              <LI>Недостаток алгоритма сортировки слиянием заключается в том, 
              что он требует дополнительную память размером порядка <SPAN 
              class=texample>n</SPAN>, не гарантирует сохранение порядка 
              элементов с одинаковыми значениями. Его временная сложность всегда 
              пропорциональна <SPAN class=texample>O(n log n)</SPAN>.
              <LI>Быстрая сортировка является наиболее эффективным алгоритмом из 
              всех известных методов сортировки, но все усовершенствованные 
              методы имеют один общий недостаток – невысокую скорость работы при 
              малых значениях <SPAN class=texample>n</SPAN>.</LI></OL>
            <DIV id=mark_162 class=lecture_mark></DIV><A name=sect10></A>
            <H3>Лабораторная работа 42. Алгоритмы сортировки массивов. 
            Внутренняя сортировка</H3>
            <P id=id_180><B>Цель работы:</B> изучить основные алгоритмы 
            внутренних сортировок и научиться решать задачи сортировок массивов 
            различными методами (бинарная пирамидальная сортировка, метод Шелла, 
            быстрая сортировка Хоара, сортировка слиянием).</P>
            <DIV id=mark_180 class=lecture_mark></DIV>
            <P id=id_181>При выполнении лабораторной работы для каждого задания 
            требуется написать программу на языке С++, которая получает на входе 
            числовые данные, выполняет генерацию и вывод массива указанного типа 
            в зависимости от постановки задачи. В каждой задаче необходимо 
            выполнить сортировку данных и реализовать один из алгоритмов: 
            бинарной пирамидальной сортировки, сортировки по методу Шелла, 
            быстрой сортировки Хоара и сортировки слиянием в виде отдельных 
            функций. Ввод данных осуществляется с клавиатуры или из файла с 
            учетом требований к входным данным, содержащихся в постановке 
            задачи. Ограничениями на входные данные является диапазон 
            используемого числового типа данных в языке С++ и максимально 
            допустимый размер объявляемого одномерного массива.</P>
            <DIV id=mark_181 class=lecture_mark></DIV>
            <P id=id_182><B>Теоретические сведения.</B></P>
            <DIV id=mark_182 class=lecture_mark></DIV>
            <P id=id_183>Ознакомьтесь с материалом лекции 42.</P>
            <DIV id=mark_183 class=lecture_mark></DIV>
            <P id=id_184><B>Задания к лабораторной работе.</B></P>
            <DIV id=mark_184 class=lecture_mark></DIV>
            <P id=id_185>Выполните приведенные ниже задания.</P>
            <DIV id=mark_185 class=lecture_mark></DIV>
            <OL id=id_186>
              <LI>На основании приведенных в лекции 42 функций реализуйте 
              алгоритмы внутренних сортировок.
              <LI>Даны два целочисленных файла, упорядоченных по возрастанию. 
              Сформировать третий файл на основе данных, который также 
              упорядочен и представляет операцию с элементами исходных файлов: 
              <UL id=id_189>
                <LI>объединение (содержит числа, принадлежащие хотя бы одному из 
                множеств);
                <LI>перечисление (числа, принадлежащие обоим множествам);
                <LI>разность (числа, принадлежащие первому множеству, но не 
                второму);
                <LI>симметричную разность (объединение разностей 
              множеств).</LI></UL>
              <DIV id=mark_189 class=lecture_mark></DIV>
              <LI>Заданы <SPAN class=texample>N (N<IMG 
              style="POSITION: relative; TOP: 2px" border=0 alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/le.gif" 
              width=8 height=18>5000)</SPAN> попарно различных длин отрезков. 
              Вычислить количество способов, которыми из отрезков можно сложить 
              треугольник.
              <LI>Дана целочисленная квадратная матрица размером <SPAN 
              class=texample></SPAN>n. Упорядочить значения так, чтобы <SPAN 
              class=texample>a<SUB>11</SUB><IMG 
              style="POSITION: relative; TOP: 2px" border=0 alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/le.gif" 
              width=8 height=18>a<SUB>12</SUB><IMG 
              style="POSITION: relative; TOP: 2px" border=0 alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/le.gif" 
              width=8 height=18><IMG style="POSITION: relative; TOP: 2px" 
              border=0 alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/le.gif" 
              width=8 height=18>a<SUB>1n</SUB><IMG 
              style="POSITION: relative; TOP: 2px" border=0 alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/le.gif" 
              width=8 height=18>a<SUB>21</SUB><IMG 
              style="POSITION: relative; TOP: 2px" border=0 alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/le.gif" 
              width=8 height=18>a<SUB>22</SUB><IMG 
              style="POSITION: relative; TOP: 2px" border=0 alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/le.gif" 
              width=8 height=18><IMG style="POSITION: relative; TOP: 2px" 
              border=0 alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/le.gif" 
              width=8 height=18>a<SUB>2n</SUB><IMG 
              style="POSITION: relative; TOP: 2px" border=0 alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/le.gif" 
              width=8 height=18><IMG style="POSITION: relative; TOP: 2px" 
              border=0 alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/le.gif" 
              width=8 height=18>a<SUB>n1</SUB><IMG 
              style="POSITION: relative; TOP: 2px" border=0 alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/le.gif" 
              width=8 height=18>a<SUB>n2</SUB><IMG 
              style="POSITION: relative; TOP: 2px" border=0 alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/le.gif" 
              width=8 height=18><IMG style="POSITION: relative; TOP: 2px" 
              border=0 alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/le.gif" 
              width=8 height=18>a<SUB>nn</SUB></SPAN>.
              <LI>Дан целочисленный массив. Выполните проверку уникальности. 
              Удалите из массива повторные вхождения чисел.</LI></OL>
            <DIV id=mark_186 class=lecture_mark></DIV>
            <P id=id_200><B>Указания к выполнению работы.</B></P>
            <DIV id=mark_200 class=lecture_mark></DIV>
            <P id=id_201>Каждое задание необходимо решить в соответствии с 
            изученными алгоритмами внутренних сортировок: бинарной пирамидальной 
            сортировки, сортировки по методу Шелла, быстрой сортировки Хоара и 
            сортировки слиянием. Программные коды следует реализовать на языке 
            С++. Рекомендуется воспользоваться материалами лекции 42, где 
            подробно рассматриваются описание используемых в работе алгоритмов, 
            примеры их реализации на языке С++. Программу для решения каждого 
            задания необходимо разработать методом процедурной абстракции, 
            используя функции. Этапы решения сопроводить комментариями в коде. В 
            отчете следует отразить разработку и обоснование математической 
            модели решения задачи и примеры входных и выходных файлов.</P>
            <DIV id=mark_201 class=lecture_mark></DIV>
            <P id=id_202>Следует реализовать каждое задание в соответствии с 
            приведенными этапами:</P>
            <DIV id=mark_202 class=lecture_mark></DIV>
            <UL id=id_203>
              <LI>изучить словесную постановку задачи, выделив при этом все виды 
              данных;
              <LI>сформулировать математическую постановку задачи;
              <LI>выбрать метод решения задачи, если это необходимо;
              <LI>разработать графическую схему алгоритма;
              <LI>записать разработанный алгоритм на языке С++;
              <LI>разработать контрольный тест к программе;
              <LI>отладить программу;
              <LI>представить отчет по работе.</LI></UL>
            <DIV id=mark_203 class=lecture_mark></DIV>
            <P id=id_212><B>Требования к отчету.</B></P>
            <DIV id=mark_212 class=lecture_mark></DIV>
            <P id=id_213>Отчет по лабораторной работе должен соответствовать 
            следующей структуре.</P>
            <DIV id=mark_213 class=lecture_mark></DIV>
            <UL id=id_214>
              <LI>Титульный лист.
              <LI>Словесная постановка задачи. В этом подразделе проводится 
              полное описание задачи. Описывается суть задачи, анализ входящих в 
              нее физических величин, область их допустимых значений, единицы их 
              измерения, возможные ограничения, анализ условий при которых 
              задача имеет решение (не имеет решения), анализ ожидаемых 
              результатов.
              <LI>Математическая модель. В этом подразделе вводятся 
              математические описания физических величин и математическое 
              описание их взаимодействий. Цель подраздела – представить решаемую 
              задачу в математической формулировке.
              <LI>Алгоритм решения задачи. В подразделе описывается разработка 
              структуры алгоритма, обосновывается абстракция данных, задача 
              разбивается на подзадачи. Схема алгоритма выполняется по ЕСПД 
              (ГОСТ 19.003-80 и ГОСТ 19.002-80).
              <LI>Листинг программы. Подраздел должен содержать текст программы 
              на языке программирования С++, реализованный в среде MS Visual 
              Studio 2010.
              <LI>Контрольный тест. Подраздел содержит наборы исходных данных и 
              полученные в ходе выполнения программы результаты.
              <LI>Выводы по лабораторной работе. 
              <LI>Ответы на контрольные вопросы.</LI></UL>
            <DIV id=mark_214 class=lecture_mark></DIV>
            <P id=id_223><B>Контрольные вопросы</B></P>
            <DIV id=mark_223 class=lecture_mark></DIV>
            <OL id=id_224>
              <LI>Чем можно объяснить многообразие алгоритмов сортировок?
              <LI>Почему на данный момент не существует универсального алгоритма 
              сортировки?
              <LI>Как соблюдение свойств устойчивости и естественности влияет на 
              трудоемкость алгоритма сортировки?
              <LI>За счет чего в алгоритмах быстрых сортировок происходит 
              выигрыш при выполнении операций сравнения и перестановок?
              <LI>Какие из перечисленных алгоритмов наиболее эффективны на почти 
              отсортированных массивах: бинарная пирамидальная сортировка, 
              сортировка слиянием, сортировка Шелла и сортировка Хоара? За счет 
              чего происходит выигрыш?
              <LI>Почему алгоритмы быстрых сортировок не дают большого выигрыша 
              при малых размерах массивов?
              <LI>В чем преимущества и недостатки по отношению друг к другу 
              следующих алгоритмов сортировок: бинарная пирамидальная 
              сортировка, сортировка слиянием, сортировка Шелла и сортировка 
              Хоара?
              <LI>Как определить, какому алгоритму сортировки отдать 
              предпочтение при решении задачи?</LI></OL>
            <DIV id=mark_224 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript 
src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/urchin.js">
</SCRIPT>

<SCRIPT 
type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
