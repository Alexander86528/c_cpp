<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0071)http://www.intuit.ru/department/algorithms/staldata/38/staldata_38.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/printable.css">
<META name=GENERATOR content="MSHTML 9.00.8080.16413"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="COLOR: #000000; FONT-WEIGHT: bold">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD>
    <TD><!-- content -->
      <TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD class=head>Структуры и алгоритмы компьютерной обработки 
        данных</TD></TR>
        <TR>
          <TD height=4><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>38. Лекция: Алгоритмы хеширования данных: 
            версия для печати и PDA</SPAN> <BR><SPAN class=rtxt>В лекции 
            рассматриваются определение и виды хеширования, методы разрешения 
            коллизий в хеш-таблицах, основные алгоритмы хеширования, приводятся 
            примеры программной реализации открытого и закрытого хеширования. 
            </SPAN></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3></H3>
            <P id=id_1><B>Цель лекции:</B> изучить построение функции 
            хеширования и алгоритмов хеширования данных и научиться 
            разрабатывать алгоритмы открытого и закрытого хеширования при 
            решении задач на языке C++.</P>
            <DIV id=mark_1 class=lecture_mark></DIV>
            <P id=id_2>Процесс поиска данных в больших объемах информации 
            сопряжен с временными затратами, которые обусловлены необходимостью 
            просмотра и сравнения с ключом поиска значительного числа элементов. 
            Сокращение поиска возможно осуществить путем локализации области 
            просмотра. Например, отсортировать данные по ключу поиска, разбить 
            на непересекающиеся блоки по некоторому групповому признаку или 
            поставить в соответствие реальным данным некий код, который упростит 
            процедуру поиска.</P>
            <DIV id=mark_2 class=lecture_mark></DIV>
            <P id=id_3>В настоящее время используется широко распространенный 
            метод обеспечения быстрого доступа к информации, хранящейся во 
            внешней памяти – хеширование. </P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <P id=id_4><B>Хеширование</B> (или <SPAN 
            class=xml_em_italic>хэширование</SPAN>, англ. <SPAN 
            class=xml_em_italic>hashing</SPAN>) – это преобразование входного 
            массива данных определенного типа и произвольной длины в выходную 
            битовую строку фиксированной длины. Такие преобразования также 
            называются <SPAN class=xml_em_italic>хеш-функциями</SPAN> или 
            функциями свертки, а их результаты называют <SPAN 
            class=xml_em_italic>хешем, хеш-кодом, хеш-таблицей</SPAN> или <SPAN 
            class=xml_em_italic>дайджестом</SPAN> сообщения (англ. <SPAN 
            class=xml_em_italic>message digest</SPAN>).</P>
            <DIV id=mark_4 class=lecture_mark></DIV>
            <P id=id_5><B>Хеш-таблица</B> – это структура данных, реализующая 
            интерфейс ассоциативного массива, то есть она позволяет хранить пары 
            вида "ключ- значение" и выполнять три операции: операцию добавления 
            новой пары, операцию поиска и операцию удаления пары по ключу. 
            Хеш-таблица является массивов, формируемым в определенном порядке 
            хеш-функцией. </P>
            <DIV id=mark_5 class=lecture_mark></DIV>
            <P id=id_6>Принято считать, что хорошей, с точки зрения 
            практического применения, является такая хеш-функция, которая 
            удовлетворяет следующим условиям:</P>
            <DIV id=mark_6 class=lecture_mark></DIV>
            <UL id=id_7>
              <LI>функция должна быть простой с вычислительной точки зрения;
              <LI>функция должна распределять ключи в хеш-таблице наиболее 
              равномерно;
              <LI>функция не должна отображать какую-либо связь между значениями 
              ключей в связь между значениями адресов;
              <LI>функция должна минимизировать число коллизий – то есть 
              ситуаций, когда разным ключам соответствует одно значение 
              хеш-функции (ключи в этом случае называются <SPAN 
              class=xml_em_italic>синонимами</SPAN>).</LI></UL>
            <DIV id=mark_7 class=lecture_mark></DIV>
            <P id=id_12>При этом первое свойство хорошей хеш-функции зависит от 
            характеристик компьютера, а второе – от значений данных. </P>
            <DIV id=mark_12 class=lecture_mark></DIV>
            <P id=id_13>Если бы все данные были случайными, то хеш-функции были 
            бы очень простые (например, несколько битов ключа). Однако на 
            практике случайные данные встречаются достаточно редко, и приходится 
            создавать функцию, которая зависела бы от всего ключа. Если 
            хеш-функция распределяет совокупность возможных ключей равномерно по 
            множеству индексов, то хеширование эффективно разбивает множество 
            ключей. Наихудший случай – когда все ключи хешируются в один 
            индекс.</P>
            <DIV id=mark_13 class=lecture_mark></DIV>
            <P id=id_14>При возникновении коллизий необходимо найти новое место 
            для хранения ключей, претендующих на одну и ту же ячейку 
            хеш-таблицы. Причем, если коллизии допускаются, то их количество 
            необходимо минимизировать. В некоторых специальных случаях удается 
            избежать коллизий вообще. Например, если все ключи элементов 
            известны заранее (или очень редко меняются), то для них можно найти 
            некоторую инъективную хеш-функцию, которая распределит их по ячейкам 
            хеш-таблицы без коллизий. Хеш-таблицы, использующие подобные 
            хеш-функции, не нуждаются в механизме разрешения коллизий, и 
            называются хеш-таблицами с <SPAN class=xml_em_italic>прямой 
            адресацией</SPAN>.</P>
            <DIV id=mark_14 class=lecture_mark></DIV>
            <P id=id_15>Хеш-таблицы должны соответствовать следующим <SPAN 
            class=xml_em_italic>свойствам</SPAN>.</P>
            <DIV id=mark_15 class=lecture_mark></DIV>
            <UL id=id_16>
              <LI>Выполнение операции в хеш-таблице начинается с вычисления 
              хеш-функции от ключа. Получающееся хеш-значение является индексом 
              в исходном массиве.
              <LI>Количество хранимых элементов массива, деленное на число 
              возможных значений хеш-функции, называется <SPAN 
              class=xml_em_italic>коэффициентом заполнения хеш-таблицы</SPAN> 
              (<SPAN class=xml_em_italic>load factor</SPAN>) и является важным 
              параметром, от которого зависит среднее время выполнения операций.
              <LI>Операции поиска, вставки и удаления должны выполняться в 
              среднем за время <SPAN class=texample>O(1)</SPAN>. Однако при 
              такой оценке не учитываются возможные аппаратные затраты на 
              перестройку индекса хеш-таблицы, связанную с увеличением значения 
              размера массива и добавлением в хеш-таблицу новой пары.
              <LI>Механизм разрешения коллизий является важной составляющей 
              любой хеш-таблицы.</LI></UL>
            <DIV id=mark_16 class=lecture_mark></DIV>
            <P id=id_22>Хеширование полезно, когда широкий диапазон возможных 
            значений должен быть сохранен в малом объеме памяти, и нужен способ 
            быстрого, практически произвольного доступа. Хэш-таблицы часто 
            применяются в базах данных, и, особенно, в языковых процессорах типа 
            компиляторов и ассемблеров, где они повышают скорость обработки 
            таблицы идентификаторов. В качестве использования хеширования в 
            повседневной жизни можно привести примеры распределение книг в 
            библиотеке по тематическим каталогам, упорядочивание в словарях по 
            первым буквам слов, шифрование специальностей в вузах и т.д.</P>
            <DIV id=mark_22 class=lecture_mark></DIV><A name=sect2></A>
            <H3>Методы разрешения коллизий</H3>
            <P id=id_23>Коллизии осложняют использование хеш-таблиц, так как 
            нарушают однозначность соответствия между хеш-кодами и данными. Тем 
            не менее, существуют способы преодоления возникающих сложностей:</P>
            <DIV id=mark_23 class=lecture_mark></DIV>
            <UL id=id_24>
              <LI>метод цепочек (внешнее или открытое хеширование);
              <LI>метод открытой адресации (закрытое хеширование).</LI></UL>
            <DIV id=mark_24 class=lecture_mark></DIV>
            <P id=id_27><SPAN class=xml_em_italic>Метод цепочек</SPAN>. 
            Технология сцепления элементов состоит в том, что элементы 
            множества, которым соответствует одно и то же хеш-значение, 
            связываются в цепочку-список. В позиции номер <SPAN 
            class=texample>i</SPAN> хранится указатель на голову списка тех 
            элементов, у которых хеш-значение ключа равно <SPAN 
            class=texample>i</SPAN>; если таких элементов в множестве нет, в 
            позиции <SPAN class=texample>i</SPAN> записан <SPAN 
            class=texample>NULL</SPAN>. На <A 
            href="http://www.intuit.ru/department/algorithms/staldata/38/staldata_38.html#image.38.1">рис. 
            38.1</A> демонстрируется реализация метода цепочек при разрешении 
            коллизий. На ключ 002 претендуют два значения, которые организуются 
            в линейный список.</P>
            <DIV id=mark_27 class=lecture_mark></DIV>
            <P id=id_32 align=left><A name=image.38.1></A>
            <DIV><IMG alt="Разрешение коллизий при помощи цепочек" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/38_01.png" 
            width=584 height=238></DIV><BR><B>Рис. 38.1.</B>&nbsp; Разрешение 
            коллизий при помощи цепочек
            <P></P>
            <DIV id=mark_32 class=lecture_mark></DIV>
            <P id=id_33>Каждая ячейка массива является указателем на связный 
            список (цепочку) пар ключ-значение, соответствующих одному и тому же 
            хеш-значению ключа. Коллизии просто приводят к тому, что появляются 
            цепочки длиной более одного элемента.</P>
            <DIV id=mark_33 class=lecture_mark></DIV>
            <P id=id_34>Операции поиска или удаления данных требуют просмотра 
            всех элементов соответствующей ему цепочки, чтобы найти в ней 
            элемент с заданным ключом. Для добавления данных нужно добавить 
            элемент в конец или начало соответствующего списка, и, в случае если 
            коэффициент заполнения станет слишком велик, увеличить размер 
            массива и перестроить таблицу.</P>
            <DIV id=mark_34 class=lecture_mark></DIV>
            <P id=id_35>При предположении, что каждый элемент может попасть в 
            любую позицию таблицы с равной вероятностью и независимо от того, 
            куда попал любой другой элемент, среднее время работы операции 
            поиска элемента составляет <SPAN class=texample>O(1+k)</SPAN>, где 
            <SPAN class=texample>k</SPAN> – коэффициент заполнения таблицы.</P>
            <DIV id=mark_35 class=lecture_mark></DIV>
            <P id=id_38><SPAN class=xml_em_italic>Метод открытой 
            адресации</SPAN>. В отличие от хеширования с цепочками, при открытой 
            адресации никаких списков нет, а все записи хранятся в самой 
            хеш-таблице. Каждая ячейка таблицы содержит либо элемент 
            динамического множества, либо <SPAN class=texample>NULL</SPAN>.</P>
            <DIV id=mark_38 class=lecture_mark></DIV>
            <P id=id_40>В этом случае, если ячейка с вычисленным индексом 
            занята, то можно просто просматривать следующие записи таблицы по 
            порядку до тех пор, пока не будет найден ключ <SPAN 
            class=texample>K</SPAN> или пустая позиция в таблице. Для вычисления 
            шага можно также применить формулу, которая и определит способ 
            изменения шага. На <A 
            href="http://www.intuit.ru/department/algorithms/staldata/38/staldata_38.html#image.38.2">рис. 
            38.2</A> разрешение коллизий осуществляется методом открытой 
            адресации. Два значения претендуют на ключ 002, для одного из них 
            находится первое свободное (еще незанятое) место в таблице.</P>
            <DIV id=mark_40 class=lecture_mark></DIV>
            <P id=id_42 align=left><A name=image.38.2></A>
            <DIV><IMG alt="Разрешение коллизий при помощи открытой адресации" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/38_02.png" 
            width=462 height=263></DIV><BR><B>Рис. 38.2.</B>&nbsp; Разрешение 
            коллизий при помощи открытой адресации
            <P></P>
            <DIV id=mark_42 class=lecture_mark></DIV>
            <P id=id_43>При любом методе разрешения коллизий необходимо 
            ограничить длину поиска элемента. Если для поиска элемента 
            необходимо более 3 – 4 сравнений, то эффективность использования 
            такой хеш-таблицы пропадает и ее следует реструктуризировать (т.е. 
            найти другую хеш-функцию), чтобы минимизировать количество сравнений 
            для поиска элемента</P>
            <DIV id=mark_43 class=lecture_mark></DIV>
            <P id=id_44>Для успешной работы алгоритмов поиска, 
            последовательность проб должна быть такой, чтобы все ячейки 
            хеш-таблицы оказались просмотренными ровно по одному разу.</P>
            <DIV id=mark_44 class=lecture_mark></DIV>
            <P id=id_45>Удаление элементов в такой схеме несколько затруднено. 
            Обычно поступают так: заводят логический флаг для каждой ячейки, 
            помечающий, удален ли элемент в ней или нет. Тогда удаление элемента 
            состоит в установке этого флага для соответствующей ячейки 
            хеш-таблицы, но при этом необходимо модифицировать процедуру поиска 
            существующего элемента так, чтобы она считала удаленные ячейки 
            занятыми, а процедуру добавления – чтобы она их считала свободными и 
            сбрасывала значение флага при добавлении.</P>
            <DIV id=mark_45 class=lecture_mark></DIV><A name=sect3></A>
            <H3>Алгоритмы хеширования</H3>
            <P id=id_46>Существует несколько типов функций хеширования, каждая 
            из которых имеет свои преимущества и недостатки и основана на 
            представлении данных. Приведем обзор и анализ некоторых наиболее 
            простых из применяемых на практике хеш-функций.</P>
            <DIV id=mark_46 class=lecture_mark></DIV><A name=sect4></A>
            <H4>Таблица прямого доступа</H4>
            <P id=id_47>Простейшей организацией таблицы, обеспечивающей идеально 
            быстрый поиск, является таблица прямого доступа. В такой таблице 
            ключ является адресом записи в таблице или может быть преобразован в 
            адрес, причем таким образом, что никакие два разных ключа не 
            преобразуются в один и тот же адрес. При создании таблицы выделяется 
            память для хранения всей таблицы и заполняется пустыми записями. 
            Затем записи вносятся в таблицу – каждая на свое место, определяемое 
            ее ключом. При поиске ключ используется как адрес и по этому адресу 
            выбирается запись. Если выбранная запись пустая, то записи с таким 
            ключом вообще нет в таблице. Таблицы прямого доступа очень 
            эффективны в использовании, но, к сожалению, область их применения 
            весьма ограничена.</P>
            <DIV id=mark_47 class=lecture_mark></DIV>
            <P id=id_48>Назовем <SPAN class=xml_em_italic>пространством 
            ключей</SPAN> множество всех теоретически возможных значений ключей 
            записи. Назовем <SPAN class=xml_em_italic>пространством 
            записей</SPAN> множество тех ячеек памяти, которые выделяются для 
            хранения таблицы. Таблицы прямого доступа применимы только для таких 
            задач, в которых размер пространства записей может быть равен 
            размеру пространства ключей. В большинстве реальных задач размер 
            пространства записей много меньше, чем пространства ключей. Так, 
            если в качестве ключа используется фамилия, то, даже ограничив длину 
            ключа десятью символами кириллицы, получаем 3310 возможных значений 
            ключей. Даже если ресурсы вычислительной системы и позволят выделить 
            пространство записей такого размера, то значительная часть этого 
            пространства будет заполнена пустыми записями, так как в каждом 
            конкретном заполнении таблицы фактическое множество ключей не будет 
            полностью покрывать пространство ключей.</P>
            <DIV id=mark_48 class=lecture_mark></DIV>
            <P id=id_49>В целях экономии памяти можно назначать размер 
            пространства записей равным размеру фактического множества записей 
            или превосходящим его незначительно. В этом случае необходимо иметь 
            некоторую функцию, обеспечивающую отображение точки из пространства 
            ключей в точку в пространстве записей, то есть, преобразование ключа 
            в адрес записи: <SPAN class=texample>a=h(k)</SPAN>, где <SPAN 
            class=texample>a</SPAN> – адрес, <SPAN class=texample>k</SPAN> – 
            ключ.</P>
            <DIV id=mark_49 class=lecture_mark></DIV>
            <P id=id_53>Идеальной хеш-функцией является инъективная функция, 
            которая для любых двух неодинаковых ключей дает неодинаковые 
            адреса.</P>
            <DIV id=mark_53 class=lecture_mark></DIV><A name=sect5></A>
            <H4>Метод остатков от деления</H4>
            <P id=id_54>Простейшей хеш-функцией является деление по модулю 
            числового значения ключа Key на размер пространства записи <SPAN 
            class=texample>HashTableSize</SPAN>. Результат интерпретируется как 
            адрес записи. Следует иметь в виду, что такая функция хорошо 
            соответствует первому, но плохо – последним трем требованиям к 
            хеш-функции и сама по себе может быть применена лишь в очень 
            ограниченном диапазоне реальных задач. Однако операция деления по 
            модулю обычно применяется как последний шаг в более сложных функциях 
            хеширования, обеспечивая приведение результата к размеру 
            пространства записей.</P>
            <DIV id=mark_54 class=lecture_mark></DIV>
            <P id=id_56>Если ключей меньше, чем элементов массива, то в качестве 
            хеш-функции можно использовать деление по модулю, то есть остаток от 
            деления целочисленного ключа <SPAN class=texample>Key</SPAN> на 
            размерность массива <SPAN class=texample>HashTableSize</SPAN>, то 
            есть:</P>
            <DIV id=mark_56 class=lecture_mark></DIV>
            <DIV class=example><PRE>Key % HashTableSize
</PRE></DIV>
            <P id=id_60>Данная функция очень проста, хотя и не относится к 
            хорошим. Вообще, можно использовать любую размерность массива, но 
            она должна быть такой, чтобы минимизировать число коллизий. Для 
            этого в качестве размерности лучше использовать простое число. В 
            большинстве случаев подобный выбор вполне удовлетворителен. Для 
            символьной строки ключом может являться остаток от деления, 
            например, суммы кодов символов строки на <SPAN 
            class=texample>HashTableSize</SPAN>.</P>
            <DIV id=mark_60 class=lecture_mark></DIV>
            <P id=id_62>На практике, метод деления – самый распространенный.</P>
            <DIV id=mark_62 class=lecture_mark></DIV>
            <DIV class=example><PRE>//функция создания хеш-таблицы метод деления по модулю
int Hash(int Key, int HashTableSize) {
//HashTableSize
    return Key % HashTableSize;
}
</PRE></DIV><A name=sect6></A>
            <H4>Метод функции середины квадрата</H4>
            <P id=id_64>Следующей хеш-функцией является функция середины 
            квадрата. Значение ключа преобразуется в число, это число затем 
            возводится в квадрат, из него выбираются несколько средних цифр и 
            интерпретируются как адрес записи.</P>
            <DIV id=mark_64 class=lecture_mark></DIV><A name=sect7></A>
            <H4>Метод свертки</H4>
            <P id=id_65>Еще одной хеш-функцией можно назвать функцию свертки. 
            Цифровое представление ключа разбивается на части, каждая из которых 
            имеет длину, равную длине требуемого адреса. Над частями 
            производятся определенные арифметические или поразрядные логические 
            операции, результат которых интерпретируется как адрес. Например, 
            для сравнительно небольших таблиц с ключами – символьными строками 
            неплохие результаты дает функция хеширования, в которой адрес записи 
            получается в результате сложения кодов символов, составляющих 
            строку-ключ.</P>
            <DIV id=mark_65 class=lecture_mark></DIV>
            <P id=id_66>В качестве хеш-функции также применяют функцию 
            преобразования системы счисления. Ключ, записанный как число в 
            некоторой системе счисления <SPAN class=texample>P</SPAN>, 
            интерпретируется как число в системе счисления <SPAN 
            class=texample>Q&gt;P</SPAN>. Обычно выбирают <SPAN 
            class=texample>Q=P+1</SPAN>. Это число переводится из системы <SPAN 
            class=texample>Q</SPAN> обратно в систему <SPAN 
            class=texample>P</SPAN>, приводится к размеру пространства записей и 
            интерпретируется как адрес.</P>
            <DIV id=mark_66 class=lecture_mark></DIV><A name=sect8></A>
            <H4>Открытое хеширование</H4>
            <P id=id_72>Основная идея базовой структуры при открытом (внешнем) 
            хешировании заключается в том, что потенциальное множество 
            (возможно, бесконечное) разбивается на конечное число классов. Для 
            <SPAN class=texample>В</SPAN> классов, пронумерованных от 0 до <SPAN 
            class=texample>В-1</SPAN>, строится хеш-функция <SPAN 
            class=texample>h(x)</SPAN> такая, что для любого элемента <SPAN 
            class=texample>х</SPAN> исходного множества функция <SPAN 
            class=texample>h(x)</SPAN> принимает целочисленное значение из 
            интервала <SPAN class=texample>0,1,...,В-1</SPAN>, соответствующее, 
            классу, которому принадлежит элемент <SPAN class=texample>х</SPAN>. 
            Часто классы называют <SPAN class=xml_em_italic>сегментами</SPAN>, 
            поэтому будем говорить, что элемент <SPAN class=texample>х</SPAN> 
            принадлежит сегменту <SPAN class=texample>h(x)</SPAN>. Массив, 
            называемый таблицей сегментов и проиндексированный номерами 
            сегментов <SPAN class=texample>0,1,...,В-1</SPAN>, содержит 
            заголовки для <SPAN class=texample>B</SPAN> списков. Элемент <SPAN 
            class=texample>х</SPAN>, относящийся к <SPAN 
            class=texample>i</SPAN>-му списку – это элемент исходного множества, 
            для которого <SPAN class=texample>h(x)=i</SPAN>.</P>
            <DIV id=mark_72 class=lecture_mark></DIV>
            <P id=id_87>Если сегменты примерно одинаковы по размеру, то в этом 
            случае списки всех сегментов должны быть наиболее короткими при 
            данном числе сегментов. Если исходное множество состоит из <SPAN 
            class=texample>N</SPAN> элементов, тогда средняя длина списков будет 
            <SPAN class=texample>N/B</SPAN> элементов. Если можно оценить 
            величину <SPAN class=texample>N</SPAN> и выбрать <SPAN 
            class=texample>В</SPAN> как можно ближе к этой величине, то в каждом 
            списке будет один или два элемента. Тогда время выполнения 
            операторов словарей будет малой постоянной величиной, не зависящей 
            от <SPAN class=texample>N</SPAN>.</P>
            <DIV id=mark_87 class=lecture_mark></DIV>
            <P id=id_93><SPAN class=xml_em_italic>Пример 1</SPAN>. Программная 
            реализация открытого хеширования.</P>
            <DIV id=mark_93 class=lecture_mark></DIV><A></A>
            <DIV class=example><PRE>#include "stdafx.h"
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;

typedef int T;  // тип элементов
typedef int hashTableIndex; // индекс в хеш-таблице
#define compEQ(a,b) (a == b)
typedef struct Node_ {
       T data;// данные, хранящиеся в вершине
       struct Node_ *next; // следующая вершина
} Node;

Node **hashTable;
int hashTableSize;
hashTableIndex myhash(T data);
Node *insertNode(T data);
void deleteNode(T data);
Node *findNode (T data);

int _tmain(int argc, _TCHAR* argv[]){
  int i, *a, maxnum;
  cout &lt;&lt; "Введите количество элементов maxnum : ";
  cin &gt;&gt; maxnum;
  cout &lt;&lt; "Введите размер хеш-таблицы HashTableSize : ";
  cin &gt;&gt; hashTableSize;
  a = new int[maxnum];
  hashTable = new Node*[hashTableSize];
  for (i = 0; i &lt; hashTableSize; i++)
    hashTable[i] = NULL;
  // генерация массива
  for (i = 0; i &lt; maxnum; i++)
    a[i] = rand();
  // заполнение хеш-таблицы элементами массива
  for (i = 0; i &lt; maxnum; i++) {
    insertNode(a[i]);
  }
  // поиск элементов массива по хеш-таблице
  for (i = maxnum-1; i &gt;= 0; i--) {
    findNode(a[i]);
  }
  // вывод элементов массива в файл List.txt
  ofstream out("List.txt");
  for (i = 0; i &lt; maxnum; i++){
    out &lt;&lt; a[i];
    if ( i &lt; maxnum - 1 ) out &lt;&lt; "\t";
  }
  out.close();
  // сохранение хеш-таблицы в файл HashTable.txt
  out.open("HashTable.txt");
  for (i = 0; i &lt; hashTableSize; i++){
    out &lt;&lt; i &lt;&lt; "  :  "; 
    Node *Temp = hashTable[i];
    while ( Temp ){
      out &lt;&lt; Temp-&gt;data &lt;&lt; " -&gt; ";
      Temp = Temp-&gt;next;
    }
    out &lt;&lt; endl;
  }
  out.close();
  // очистка хеш-таблицы
    for (i = maxnum-1; i &gt;= 0; i--) {
        deleteNode(a[i]);
    }
  system("pause");
  return 0;
}

// хеш-функция размещения вершины
hashTableIndex myhash(T data) {
  return (data % hashTableSize);
}

// функция поиска местоположения и вставки вершины в таблицу
Node *insertNode(T data) {
  Node *p, *p0;
  hashTableIndex bucket;
  // вставка вершины в начало списка
  bucket = myhash(data);
  if ((p = new Node) == 0) {
    fprintf (stderr, "Нехватка памяти (insertNode)\n");
    exit(1);
  }
  p0 = hashTable[bucket];
  hashTable[bucket] = p;
  p-&gt;next = p0;
  p-&gt;data = data;
  return p;
}

//функция удаления вершины из таблицы
void deleteNode(T data) {
  Node *p0, *p;
  hashTableIndex bucket;
  p0 = 0;
  bucket = myhash(data);
  p = hashTable[bucket];
  while (p &amp;&amp; !compEQ(p-&gt;data, data)) {
    p0 = p;
    p = p-&gt;next;
  }
  if (!p) return;
  if (p0)
    p0-&gt;next = p-&gt;next;
  else
    hashTable[bucket] = p-&gt;next;
  free (p);
}

// функция поиска вершины со значением data
Node *findNode (T data) {
  Node *p;
  p = hashTable[myhash(data)];
  while (p &amp;&amp; !compEQ(p-&gt;data, data)) 
    p = p-&gt;next;
  return p;
}
</PRE><SPAN class=objectName>Листинг . </SPAN></DIV><A 
            name=sect9></A>
            <H4>Закрытое хеширование</H4>
            <P id=id_95>При закрытом (внутреннем) хешировании в хеш-таблице 
            хранятся непосредственно сами элементы, а не заголовки списков 
            элементов. Поэтому в каждой записи (сегменте) может храниться только 
            один элемент. При закрытом хешировании применяется методика <SPAN 
            class=xml_em_italic>повторного хеширования</SPAN>. Если 
            осуществляется попытка поместить элемент <SPAN 
            class=texample>х</SPAN> в сегмент с номером <SPAN 
            class=texample>h(х)</SPAN>, который уже занят другим элементом 
            (коллизия), то в соответствии с методикой повторного хеширования 
            выбирается последовательность других номеров сегментов <SPAN 
            class=texample>h1(х),h2(х),...</SPAN>, куда можно поместить элемент 
            <SPAN class=texample>х</SPAN>. Каждое из этих местоположений 
            последовательно проверяется, пока не будет найдено свободное. Если 
            свободных сегментов нет, то, следовательно, таблица заполнена, и 
            элемент <SPAN class=texample>х</SPAN> добавить нельзя.</P>
            <DIV id=mark_95 class=lecture_mark></DIV>
            <P id=id_101>При поиске элемента <SPAN class=texample>х</SPAN> 
            необходимо просмотреть все местоположения <SPAN 
            class=texample>h(x),h1(х),h2(х),...</SPAN>, пока не будет найден 
            <SPAN class=texample>х</SPAN> или пока не встретится пустой сегмент. 
            Чтобы объяснить, почему можно остановить поиск при достижении 
            пустого сегмента, предположим, что в хеш-таблице не допускается 
            удаление элементов. Пусть <SPAN class=texample>h3(х)</SPAN> – первый 
            пустой сегмент. В такой ситуации невозможно нахождение элемента 
            <SPAN class=texample>х</SPAN> в сегментах <SPAN 
            class=texample>h4(х),h5(х)</SPAN> и далее, так как при вставке 
            элемент <SPAN class=texample>х</SPAN> вставляется в первый пустой 
            сегмент, следовательно, он находится где-то до сегмента <SPAN 
            class=texample>h3(х)</SPAN>. Но если в хеш-таблице допускается 
            удаление элементов, то при достижении пустого сегмента, не найдя 
            элемента <SPAN class=texample>х</SPAN>, нельзя быть уверенным в том, 
            что его вообще нет в таблице, так как сегмент может стать пустым уже 
            после вставки элемента <SPAN class=texample>х</SPAN>. Поэтому, чтобы 
            увеличить эффективность данной реализации, необходимо в сегмент, 
            который освободился после операции удаления элемента, поместить 
            специальную константу, которую назовем, например, <SPAN 
            class=texample>DEL</SPAN>. В качестве альтернативы специальной 
            константе можно использовать дополнительное поле таблицы, которое 
            показывает состояние элемента. Важно различать константы <SPAN 
            class=texample>DEL</SPAN> и <SPAN class=texample>NULL</SPAN> – 
            последняя находится в сегментах, которые никогда не содержали 
            элементов. При таком подходе выполнение поиска элемента не требует 
            просмотра всей хеш-таблицы. Кроме того, при вставке элементов 
            сегменты, помеченные константой <SPAN class=texample>DEL</SPAN>, 
            можно трактовать как свободные, таким образом, пространство, 
            освобожденное после удаления элементов, можно рано или поздно 
            использовать повторно. Но если невозможно непосредственно сразу 
            после удаления элементов пометить освободившиеся сегменты, то 
            следует предпочесть закрытому хешированию схему открытого 
            хеширования.</P>
            <DIV id=mark_101 class=lecture_mark></DIV>
            <P id=id_116>Существует несколько методов повторного хеширования, то 
            есть определения местоположений <SPAN 
            class=texample>h(x),h1(х),h2(х),...</SPAN>:</P>
            <DIV id=mark_116 class=lecture_mark></DIV>
            <UL id=id_118>
              <LI>линейное опробование;
              <LI>квадратичное опробование;
              <LI>двойное хеширование.</LI></UL>
            <DIV id=mark_118 class=lecture_mark></DIV>
            <P id=id_122><SPAN class=xml_em_italic>Линейное опробование</SPAN> 
            сводится к последовательному перебору сегментов таблицы с некоторым 
            фиксированным шагом:</P>
            <DIV id=mark_122 class=lecture_mark></DIV>
            <DIV class=example><PRE>адрес=h(x)+ci,
</PRE></DIV>
            <P id=id_124>где <SPAN class=texample>i</SPAN> – номер попытки 
            разрешить коллизию;</P>
            <DIV id=mark_124 class=lecture_mark></DIV>
            <P id=id_126><SPAN class=texample>c</SPAN> – константа, определяющая 
            шаг перебора.</P>
            <DIV id=mark_126 class=lecture_mark></DIV>
            <P id=id_128>При шаге, равном единице, происходит последовательный 
            перебор всех сегментов после текущего. <SPAN 
            class=xml_em_italic>Квадратичное опробование</SPAN> отличается от 
            линейного тем, что шаг перебора сегментов нелинейно зависит от 
            номера попытки найти свободный сегмент:</P>
            <DIV id=mark_128 class=lecture_mark></DIV>
            <DIV class=example><PRE>адрес=h(x)+ci+di<SUP>2</SUP>,
</PRE></DIV>
            <P id=id_130>где <SPAN class=texample>i</SPAN> – номер попытки 
            разрешить коллизию,</P>
            <DIV id=mark_130 class=lecture_mark></DIV>
            <P id=id_132><SPAN class=texample>c</SPAN> и <SPAN 
            class=texample>d</SPAN> – константы.</P>
            <DIV id=mark_132 class=lecture_mark></DIV>
            <P id=id_135>Благодаря нелинейности такой адресации уменьшается 
            число проб при большом числе ключей-синонимов. Однако даже 
            относительно небольшое число проб может быстро привести к выходу за 
            адресное пространство небольшой таблицы вследствие квадратичной 
            зависимости адреса от номера попытки. </P>
            <DIV id=mark_135 class=lecture_mark></DIV>
            <P id=id_136>Еще одна разновидность метода открытой адресации, 
            которая называется <SPAN class=xml_em_italic>двойным 
            хешированием</SPAN>, основана на нелинейной адресации, достигаемой 
            за счет суммирования значений основной и дополнительной 
            хеш-функций:</P>
            <DIV id=mark_136 class=lecture_mark></DIV>
            <DIV class=example><PRE>адрес=h(x)+ih2(x).
</PRE></DIV>
            <P id=id_138>Очевидно, что по мере заполнения хеш-таблицы будут 
            происходить коллизии, и в результате их разрешения очередной адрес 
            может выйти за пределы адресного пространства таблицы. Чтобы это 
            явление происходило реже, можно пойти на увеличение длины таблицы по 
            сравнению с диапазоном адресов, выдаваемым хеш-функцией. С одной 
            стороны, это приведет к сокращению числа коллизий и ускорению работы 
            с хеш-таблицей, а с другой – к нерациональному расходованию памяти. 
            Даже при увеличении длины таблицы в два раза по сравнению с областью 
            значений хеш-функции нет гарантии того, что в результате коллизий 
            адрес не превысит длину таблицы. При этом в начальной части таблицы 
            может оставаться достаточно свободных сегментов. Поэтому на практике 
            используют циклический переход к началу таблицы.</P>
            <DIV id=mark_138 class=lecture_mark></DIV>
            <P id=id_139>Однако в случае многократного превышения адресного 
            пространства и, соответственно, многократного циклического перехода 
            к началу будет происходить просмотр одних и тех же ранее занятых 
            сегментов, тогда как между ними могут быть еще свободные сегменты. 
            Более корректным будет использование сдвига адреса на 1 в случае 
            каждого циклического перехода к началу таблицы. Это повышает 
            вероятность нахождения свободных сегментов.</P>
            <DIV id=mark_139 class=lecture_mark></DIV>
            <P id=id_140>В случае применения схемы закрытого хеширования 
            скорость выполнения вставки и других операций зависит не только от 
            равномерности распределения элементов по сегментам хеш-функцией, но 
            и от выбранной методики повторного хеширования (опробования) для 
            разрешения коллизий, связанных с попытками вставки элементов в уже 
            заполненные сегменты. Например, методика линейного опробования для 
            разрешения коллизий – не самый лучший выбор.</P>
            <DIV id=mark_140 class=lecture_mark></DIV>
            <P id=id_141>Как только несколько последовательных сегментов будут 
            заполнены, образуя группу, любой новый элемент при попытке вставки в 
            эти сегменты будет вставлен в конец этой группы, увеличивая тем 
            самым длину группы последовательно заполненных сегментов. Другими 
            словами, для поиска пустого сегмента в случае непрерывного 
            расположения заполненных сегментов необходимо просмотреть больше 
            сегментов, чем при случайном распределении заполненных сегментов. 
            Отсюда также следует очевидный вывод, что при непрерывном 
            расположении заполненных сегментов увеличивается время выполнения 
            вставки нового элемента и других операций.</P>
            <DIV id=mark_141 class=lecture_mark></DIV>
            <P id=id_142><SPAN class=xml_em_italic>Пример 2</SPAN>. Программная 
            реализация закрытого хеширования.</P>
            <DIV id=mark_142 class=lecture_mark></DIV><A></A>
            <DIV class=example><PRE>#include "stdafx.h"
#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;

typedef int T;  // тип элементов
typedef int hashTableIndex;// индекс в хеш-таблице
int hashTableSize;
T *hashTable;
bool *used;

hashTableIndex myhash(T data);
void insertData(T data);
void deleteData(T data);
bool findData (T data);
int dist (hashTableIndex a,hashTableIndex b);

int _tmain(int argc, _TCHAR* argv[]){
  int i, *a, maxnum;
  cout &lt;&lt; "Введите количество элементов maxnum : ";
  cin &gt;&gt; maxnum;
    cout &lt;&lt; "Введите размер хеш-таблицы hashTableSize : ";
  cin &gt;&gt; hashTableSize;
  a = new int[maxnum];
  hashTable = new T[hashTableSize];
  used = new bool[hashTableSize];
  for (i = 0; i &lt; hashTableSize; i++){
    hashTable[i] = 0;
    used[i] = false;
  }
  // генерация массива
  for (i = 0; i &lt; maxnum; i++)
    a[i] = rand();
  // заполнение хеш-таблицы элементами массива
  for (i = 0; i &lt; maxnum; i++)
    insertData(a[i]);
  // поиск элементов массива по хеш-таблице
  for (i = maxnum-1; i &gt;= 0; i--) 
    findData(a[i]);
  // вывод элементов массива в файл List.txt
  ofstream out("List.txt");
  for (i = 0; i &lt; maxnum; i++){
    out &lt;&lt; a[i];
    if ( i &lt; maxnum - 1 ) out &lt;&lt; "\t";
  }
  out.close();
  // сохранение хеш-таблицы в файл HashTable.txt
  out.open("HashTable.txt");
  for (i = 0; i &lt; hashTableSize; i++){
    out &lt;&lt; i &lt;&lt; "  :  " &lt;&lt; used[i] &lt;&lt; " : " &lt;&lt; hashTable[i] &lt;&lt; endl;
  }
  out.close();
  // очистка хеш-таблицы
  for (i = maxnum-1; i &gt;= 0; i--) {
    deleteData(a[i]);
  }
  system("pause");
  return 0;
}

// хеш-функция размещения величины
hashTableIndex myhash(T data) {
    return (data % hashTableSize);
}

// функция поиска местоположения и вставки величины в таблицу
void insertData(T data) {
  hashTableIndex bucket;
    bucket = myhash(data);
  while  ( used[bucket] &amp;&amp; hashTable[bucket] != data)
    bucket = (bucket + 1) % hashTableSize;
  if ( !used[bucket] ) {
    used[bucket] = true;
    hashTable[bucket] = data;
  }
}

// функция поиска величины, равной data
bool findData (T data) {
  hashTableIndex bucket;
  bucket = myhash(data);
  while ( used[bucket] &amp;&amp; hashTable[bucket] != data )
    bucket = (bucket + 1) % hashTableSize;
  return used[bucket] &amp;&amp; hashTable[bucket] == data;
}

//функция удаления величины из таблицы
void deleteData(T data){
  int bucket, gap;
  bucket = myhash(data);
  while ( used[bucket] &amp;&amp; hashTable[bucket] != data )
    bucket = (bucket + 1) % hashTableSize;
  if ( used[bucket] &amp;&amp; hashTable[bucket] == data ){
    used[bucket] = false;
    gap = bucket;
    bucket = (bucket + 1) % hashTableSize;
    while ( used[bucket] ){
      if ( bucket == myhash(hashTable[bucket]) )
        bucket = (bucket + 1) % hashTableSize;
      else if ( dist(myhash(hashTable[bucket]),bucket) &lt; dist(gap,bucket) )
        bucket = (bucket + 1) % hashTableSize;
      else {
        used[gap] = true;
        hashTable[gap] = hashTable[bucket];
        used[bucket] = false;
        gap = bucket;
        bucket++;
      }
    }
  }
}

// функция вычисления расстояние от a до b (по часовой стрелке, слева направо) 
int dist (hashTableIndex a,hashTableIndex b){
  return (b - a + hashTableSize) % hashTableSize;
}
</PRE><SPAN class=objectName>Листинг . </SPAN></DIV>
            <P id=id_144>До сих пор рассматривались способы поиска в таблице по 
            ключам, позволяющим однозначно идентифицировать запись. Такие ключи 
            называются <SPAN class=xml_em_italic>первичными</SPAN>. Возможен 
            вариант организации таблицы, при котором отдельный ключ не позволяет 
            однозначно идентифицировать запись. Такая ситуация часто встречается 
            в базах данных. Идентификация записи осуществляется по некоторой 
            совокупности ключей. Ключи, не позволяющие однозначно 
            идентифицировать запись в таблице, называются <SPAN 
            class=xml_em_italic>вторичными</SPAN> ключами. Даже при наличии 
            первичного ключа, для поиска записи могут быть использованы 
            вторичные. </P>
            <DIV id=mark_144 class=lecture_mark></DIV>
            <P id=id_145>Идея хеширования впервые была высказана Г.П. Ланом при 
            создании внутреннего меморандума IBM в январе 1953 г. с предложением 
            использовать для разрешения коллизий метод цепочек. Примерно в это 
            же время другой сотрудник IBM, Жини Амдал, высказала идею 
            использования открытой линейной адресации. В открытой печати 
            хеширование впервые было описано Арнольдом Думи (1956 год), 
            указавшим, что в качестве хеш-адреса удобно использовать остаток от 
            деления на простое число. А. Думи описывал метод цепочек для 
            разрешения коллизий, но не говорил об открытой адресации. Подход к 
            хешированию, отличный от метода цепочек, был предложен А.П. Ершовым 
            (1957 год), который разработал и описал метод линейной открытой 
            адресации.</P>
            <DIV id=mark_145 class=lecture_mark></DIV><A name=sect10></A>
            <H3>Ключевые термины</H3>
            <P id=id_146><B>Вторичные ключи</B> – это ключи, не позволяющие 
            однозначно идентифицировать запись в таблице.</P>
            <DIV id=mark_146 class=lecture_mark></DIV>
            <P id=id_147><B>Закрытое хеширование или Метод открытой 
            адресации</B> – это технология разрешения коллизий, которая 
            предполагает хранение записей в самой хеш-таблице.</P>
            <DIV id=mark_147 class=lecture_mark></DIV>
            <P id=id_148><B>Коллизия</B> – это ситуация, когда разным ключам 
            соответствует одно значение хеш-функции.</P>
            <DIV id=mark_148 class=lecture_mark></DIV>
            <P id=id_149><B>Коэффициент заполнения хеш-таблицы</B> – это 
            количество хранимых элементов массива, деленное на число возможных 
            значений хеш-функции.</P>
            <DIV id=mark_149 class=lecture_mark></DIV>
            <P id=id_150><B>Открытое хеширование или Метод цепочек</B> – это 
            технология разрешения коллизий, которая состоит в том, что элементы 
            множества с равными хеш-значениями связываются в цепочку-список.</P>
            <DIV id=mark_150 class=lecture_mark></DIV>
            <P id=id_151><B>Первичные ключи</B> – это ключи, позволяющие 
            однозначно идентифицировать запись. </P>
            <DIV id=mark_151 class=lecture_mark></DIV>
            <P id=id_152><B>Повторное хеширование</B> – это поиск местоположения 
            для очередного элемента таблицы с учетом шага перемещения.</P>
            <DIV id=mark_152 class=lecture_mark></DIV>
            <P id=id_153><B>Пространство записей</B> – это множество тех ячеек 
            памяти, которые выделяются для хранения таблицы.</P>
            <DIV id=mark_153 class=lecture_mark></DIV>
            <P id=id_154><B>Пространство ключей</B> – это множество всех 
            теоретически возможных значений ключей записи. </P>
            <DIV id=mark_154 class=lecture_mark></DIV>
            <P id=id_155><B>Синонимы</B> – это совпадающие ключи в 
            хеш-таблице.</P>
            <DIV id=mark_155 class=lecture_mark></DIV>
            <P id=id_156><B>Хеширование</B> – это преобразование входного 
            массива данных определенного типа и произвольной длины в выходную 
            битовую строку фиксированной длины.</P>
            <DIV id=mark_156 class=lecture_mark></DIV>
            <P id=id_157><B>Хеш-таблица</B> – это структура данных, реализующая 
            интерфейс ассоциативного массива, то есть она позволяет хранить пары 
            вида "ключ- значение" и выполнять три операции: операцию добавления 
            новой пары, операцию поиска и операцию удаления пары по ключу.</P>
            <DIV id=mark_157 class=lecture_mark></DIV>
            <P id=id_158><B>Хеш-таблицы с прямой адресацией</B> – это 
            хеш-таблицы, использующие инъективные хеш-функции и не нуждающиеся в 
            механизме разрешения коллизий.</P>
            <DIV id=mark_158 class=lecture_mark></DIV><A name=sect11></A>
            <H3>Краткие итоги</H3>
            <OL id=id_159>
              <LI>В настоящее время используется широко распространенный метод 
              обеспечения быстрого доступа к большим объемам информации – 
              хеширование.
              <LI>Для установления соответствия ключей и данных строится 
              хеш-таблица.
              <LI>Хеш-таблица строится при помощи хеш-функций. Практическое 
              применение получили функции прямого доступа, остатков от деления, 
              середины квадрата, свертки.
              <LI>При построении хеш-таблиц могут возникать коллизии, то есть 
              ситуации неоднозначного соответствия данных ключу.
              <LI>Разрешение коллизий проводится методом цепочек (открытое или 
              внешнее хеширование) или методом открытой адресации (закрытое 
              хеширование).
              <LI>Поиск свободных ключей в методе открытой адресации может 
              проводиться методом повторного хеширования с помощью линейного 
              опробования, квадратичного опробования или двойного хеширования.
              <LI>Идентификация данных в таблицах может осуществляться как по 
              первичному, так и по вторичному ключу.
              <LI>Хеширование имеет широкое практическое применение в теории баз 
              данных, кодировании, банковском деле, криптографии и других 
              областях.</LI></OL>
            <DIV id=mark_159 class=lecture_mark></DIV><A name=sect12></A>
            <H3>Лабораторная работа 38. Алгоритмы хеширования данных</H3>
            <P id=id_168><B>Цель работы:</B> изучить построение функции 
            хеширования и алгоритмов хеширования данных и научиться 
            разрабатывать алгоритмы открытого и закрытого хеширования при 
            решении задач на языке C++.</P>
            <DIV id=mark_168 class=lecture_mark></DIV>
            <P id=id_169>При выполнении лабораторной работы для каждого задания 
            требуется написать программу на языке С++, которая получает на 
            данные с клавиатуры или из входного файла, выполняет их обработку в 
            соответствии с требованиями задания и выводит результат в выходной 
            файл. Для обработки данных необходимо реализовать функции алгоритмов 
            хеширования данных. Ограничениями на входные данные являются 
            максимальный размер строковых данных, допустимый диапазон значений 
            используемых числовых типов в языке С++.</P>
            <DIV id=mark_169 class=lecture_mark></DIV>
            <P id=id_170><B>Теоретические сведения.</B></P>
            <DIV id=mark_170 class=lecture_mark></DIV>
            <P id=id_171>Ознакомьтесь с материалом лекции 38.</P>
            <DIV id=mark_171 class=lecture_mark></DIV>
            <P id=id_172><B>Задания к лабораторной работе.</B></P>
            <DIV id=mark_172 class=lecture_mark></DIV>
            <P id=id_173>Выполните приведенные ниже задания.</P>
            <DIV id=mark_173 class=lecture_mark></DIV>
            <OL id=id_174>
              <LI>Составьте хеш-таблицу, содержащую буквы и количество их 
              вхождений во введенной строке. Вывести таблицу на экран. 
              Осуществить поиск введенной буквы в хеш-таблице.
              <LI>Постройте хеш-таблицу из слов произвольного текстового файла, 
              задав ее размерность с экрана. Выведите построенную таблицу слов 
              на экран. Осуществите поиск введенного слова. Выполните программу 
              для различных размерностей таблицы и сравните количество 
              сравнений. Удалите все слова, начинающиеся на указанную букву, 
              выведите таблицу. 
              <LI>Постройте хеш-таблицу для зарезервированных слов, 
              используемого языка программирования (не менее 20 слов), 
              содержащую HELP для каждого слова. Выдайте на экран подсказку по 
              введенному слову. Добавьте подсказку по вновь введенному слову, 
              используя при необходимости реструктуризацию таблицы. Сравните 
              эффективность добавления ключа в таблицу или ее реструктуризацию 
              для различной степени заполненности таблицы. 
              <LI>В текстовом файле содержатся целые числа. Постройте 
              хеш-таблицу из чисел файла. Осуществите поиск введенного целого 
              числа в хеш-таблице. Сравните результаты количества сравнений при 
              различном наборе данных в файле.</LI></OL>
            <DIV id=mark_174 class=lecture_mark></DIV>
            <P id=id_179><B>Указания к выполнению работы.</B></P>
            <DIV id=mark_179 class=lecture_mark></DIV>
            <P id=id_180>Каждое задание необходимо решить в соответствии с 
            изученным алгоритмами хеширования данных, реализовав программный код 
            на языке С++. Рекомендуется воспользоваться материалами лекции 38, 
            где подробно рассматриваются описание используемых в работе 
            алгоритмов, примеры их реализации на языке С++. Программу для 
            решения каждого задания необходимо разработать методом процедурной 
            абстракции, используя функции, коды которых требуется сопроводить 
            комментариями. Результаты обработки данных следует выводить в 
            выходной файл и дублировать вывод на экране. В отчете следует 
            отразить разработку и обоснование математической модели решения 
            задачи и результаты тестирования программ.</P>
            <DIV id=mark_180 class=lecture_mark></DIV>
            <P id=id_181>Следует реализовать каждое задание в соответствии с 
            приведенными этапами:</P>
            <DIV id=mark_181 class=lecture_mark></DIV>
            <UL id=id_182>
              <LI>изучить словесную постановку задачи, выделив при этом все виды 
              данных;
              <LI>сформулировать математическую постановку задачи;
              <LI>выбрать метод решения задачи, если это необходимо;
              <LI>разработать графическую схему алгоритма;
              <LI>записать разработанный алгоритм на языке С++;
              <LI>разработать контрольный тест к программе;
              <LI>отладить программу;
              <LI>представить отчет по работе.</LI></UL>
            <DIV id=mark_182 class=lecture_mark></DIV>
            <P id=id_191><B>Требования к отчету.</B></P>
            <DIV id=mark_191 class=lecture_mark></DIV>
            <P id=id_192>Отчет по лабораторной работе должен соответствовать 
            следующей структуре.</P>
            <DIV id=mark_192 class=lecture_mark></DIV>
            <UL id=id_193>
              <LI>Титульный лист.
              <LI>Словесная постановка задачи. В этом подразделе проводится 
              полное описание задачи. Описывается суть задачи, анализ входящих в 
              нее физических величин, область их допустимых значений, единицы их 
              измерения, возможные ограничения, анализ условий при которых 
              задача имеет решение (не имеет решения), анализ ожидаемых 
              результатов.
              <LI>Математическая модель. В этом подразделе вводятся 
              математические описания физических величин и математическое 
              описание их взаимодействий. Цель подраздела – представить решаемую 
              задачу в математической формулировке.
              <LI>Алгоритм решения задачи. В подразделе описывается разработка 
              структуры алгоритма, обосновывается абстракция данных, задача 
              разбивается на подзадачи. Схема алгоритма выполняется по ЕСПД 
              (ГОСТ 19.003-80 и ГОСТ 19.002-80).
              <LI>Листинг программы. Подраздел должен содержать текст программы 
              на языке программирования С++, реализованный в среде MS Visual 
              Studio 2010.
              <LI>Контрольный тест. Подраздел содержит наборы исходных данных и 
              полученные в ходе выполнения программы результаты.
              <LI>Выводы по лабораторной работе. 
              <LI>Ответы на контрольные вопросы.</LI></UL>
            <DIV id=mark_193 class=lecture_mark></DIV>
            <P id=id_202><B>Контрольные вопросы</B></P>
            <DIV id=mark_202 class=lecture_mark></DIV>
            <OL id=id_203>
              <LI>Каков принцип построения хеш-таблиц? 
              <LI>Существуют ли универсальные методы построения хеш-таблиц? 
              Ответ обоснуйте.
              <LI>Почему возможно возникновение коллизий? 
              <LI>Каковы методы устранения коллизий? Охарактеризуйте их 
              эффективность в различных ситуациях.
              <LI>Назовите преимущества открытого и закрытого хеширования.
              <LI>В каком случае поиск в хеш-таблицах становится неэффективен? 
              <LI>Как выбирается метод изменения адреса при повторном 
              хешировании?</LI></OL>
            <DIV id=mark_203 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript 
src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/urchin.js">
</SCRIPT>

<SCRIPT 
type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
