<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0071)http://www.intuit.ru/department/algorithms/staldata/37/staldata_37.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/printable.css">
<META name=GENERATOR content="MSHTML 9.00.8080.16413"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="COLOR: #000000; FONT-WEIGHT: bold">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD>
    <TD><!-- content -->
      <TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD class=head>Структуры и алгоритмы компьютерной обработки 
        данных</TD></TR>
        <TR>
          <TD height=4><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>37. Лекция: Алгоритмы поиска в линейных 
            структурах: версия для печати и PDA</SPAN> <BR><SPAN class=rtxt>В 
            лекции рассматриваются определение и классификация алгоритмов поиска 
            в линейных структурах данных, описания и примеры реализаций 
            алгоритмов последовательного поиска, поиска с барьером, бинарного 
            поиска, приводится оценка трудоемкости алгоритмов поиска в линейных 
            структурах. </SPAN></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3></H3>
            <P id=id_1><B>Цель лекции:</B> изучить основные алгоритмы поиска в 
            линейных структурах и научиться решать задачи поиска в линейных 
            структурах на основе алгоритмов последовательного и бинарного 
            поиска.</P>
            <DIV id=mark_1 class=lecture_mark></DIV>
            <P id=id_2>Одним из важнейших действий со структурированной 
            информацией является поиск. <B>Поиск</B> – процесс нахождения 
            конкретной информации в ранее созданном множестве данных. Обычно 
            данные представляют собой записи, каждая из которых имеет хотя бы 
            один ключ. <SPAN class=xml_em_italic>Ключ поиска</SPAN> – это поле 
            записи, по значению которого происходит поиск. Ключи используются 
            для отличия одних записей от других. Целью поиска является 
            нахождение всех записей (если они есть) с данным значением ключа. 
            </P>
            <DIV id=mark_2 class=lecture_mark></DIV>
            <P id=id_3>Структуру данных, в которой проводится поиск, можно 
            рассматривать как <SPAN class=xml_em_italic>таблицу символов</SPAN> 
            (таблицу имен или таблицу идентификаторов) – структуру, содержащую 
            ключи и данные, и допускающую две операции – вставку нового элемента 
            и возврат элемента с заданным ключом. Иногда таблицы символов 
            называют <SPAN class=xml_em_italic>словарями</SPAN> по аналогии с 
            хорошо известной системой упорядочивания слов в алфавитном порядке: 
            слово – ключ, его толкование – данные.</P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <P id=id_4>Поиск является одним из наиболее часто встречаемых 
            действий в программировании. Существует множество различных 
            алгоритмов поиска, которые принципиально зависят от способа 
            организации данных. У каждого алгоритма поиска есть свои 
            преимущества и недостатки. Поэтому важно выбрать тот алгоритм, 
            который лучше всего подходит для решения конкретной задачи.</P>
            <DIV id=mark_4 class=lecture_mark></DIV>
            <P id=id_5>Поставим задачу поиска в линейных структурах. Пусть 
            задано множество данных, которое описывается как массив, состоящий 
            из некоторого количества элементов. Проверим, входит ли заданный 
            ключ в данный массив. Если входит, то найдем номер этого элемента 
            массива, то есть, определим первое вхождение заданного ключа 
            (элемента) в исходном массиве.</P>
            <DIV id=mark_5 class=lecture_mark></DIV>
            <P id=id_6>Таким образом, определим <SPAN class=xml_em_italic>общий 
            алгоритм поиска</SPAN> данных:</P>
            <DIV id=mark_6 class=lecture_mark></DIV>
            <P id=id_7>Шаг 1. Вычисление элемента, что часто предполагает 
            получение значения элемента, ключа элемента и т.д.</P>
            <DIV id=mark_7 class=lecture_mark></DIV>
            <P id=id_8>Шаг 2. Сравнение элемента с эталоном или сравнение двух 
            элементов (в зависимости от постановки задачи).</P>
            <DIV id=mark_8 class=lecture_mark></DIV>
            <P id=id_9>Шаг 3. Перебор элементов множества, то есть прохождение 
            по элементам массива.</P>
            <DIV id=mark_9 class=lecture_mark></DIV>
            <P id=id_10>Основные идеи различных алгоритмов поиска сосредоточены 
            в методах перебора и стратегии поиска.</P>
            <DIV id=mark_10 class=lecture_mark></DIV>
            <P id=id_11>Рассмотрим основные алгоритмы поиска в линейных 
            структурах более подробно.</P>
            <DIV id=mark_11 class=lecture_mark></DIV><A name=sect2></A>
            <H3>Последовательный (линейный) поиск</H3>
            <P id=id_12><B>Последовательный (линейный) поиск</B> – это 
            простейший вид поиска заданного элемента на некотором множестве, 
            осуществляемый путем последовательного сравнения очередного 
            рассматриваемого значения с искомым до тех пор, пока эти значения не 
            совпадут.</P>
            <DIV id=mark_12 class=lecture_mark></DIV>
            <P id=id_13>Идея этого метода заключается в следующем. Множество 
            элементов просматривается последовательно в некотором порядке, 
            гарантирующем, что будут просмотрены все элементы множества 
            (например, слева направо). Если в ходе просмотра множества будет 
            найден искомый элемент, просмотр прекращается с положительным 
            результатом; если же будет просмотрено все множество, а элемент не 
            будет найден, алгоритм должен выдать отрицательный результат.</P>
            <DIV id=mark_13 class=lecture_mark></DIV>
            <P id=id_14><SPAN class=xml_em_italic>Алгоритм последовательного 
            поиска</SPAN></P>
            <DIV id=mark_14 class=lecture_mark></DIV>
            <P id=id_15>Шаг 1. Полагаем, что значение переменной цикла <SPAN 
            class=texample>i=0</SPAN>.</P>
            <DIV id=mark_15 class=lecture_mark></DIV>
            <P id=id_17>Шаг 2. Если значение элемента массива <SPAN 
            class=texample>x[i]</SPAN> равно значению ключа <SPAN 
            class=texample>key</SPAN>, то возвращаем значение, равное номеру 
            искомого элемента, и алгоритм завершает работу. В противном случае 
            значение переменной цикла увеличивается на единицу <SPAN 
            class=texample>i=i+1</SPAN>.</P>
            <DIV id=mark_17 class=lecture_mark></DIV>
            <P id=id_21>Шаг 3. Если <SPAN class=texample>i&lt;k</SPAN>, где 
            <SPAN class=texample>k</SPAN> – число элементов массива <SPAN 
            class=texample>x</SPAN>, то выполняется Шаг 2, в противном случае – 
            работа алгоритма завершена и возвращается значение равное -1.</P>
            <DIV id=mark_21 class=lecture_mark></DIV>
            <P id=id_25>При наличии в массиве нескольких элементов со значением 
            <SPAN class=texample>key</SPAN> данный алгоритм находит только 
            первый из них (с наименьшим индексом).</P>
            <DIV id=mark_25 class=lecture_mark></DIV>
            <DIV class=example><PRE>int LinearSearch(int *x, int k, int key){
  int i = 0;
  for ( i = 0 ; i &lt; k ; i++ )
    if ( x[i] == key )
      break;
  return i &lt; k ? i : -1;
}
</PRE></DIV>
            <P id=id_28>Время выполнения данного алгоритма поиска для 
            вещественных чисел <SPAN class=texample>n/&#949;</SPAN>, где <SPAN 
            class=texample>n</SPAN> – количество элементов множества, а <SPAN 
            class=texample>&#949;</SPAN> – точность. Поиск на дискретном множестве из 
            <SPAN class=texample>n</SPAN> элементов осуществляется в худшем 
            случае за <SPAN class=texample>n</SPAN> итераций, а в среднем этот 
            алгоритм требует <SPAN class=texample>n/2</SPAN> итераций цикла. 
            Следовательно, временная сложность последовательного поиска 
            пропорциональна <SPAN class=texample>O(n)</SPAN>. Никаких 
            ограничений на порядок элементов в массиве данный алгоритм не 
            накладывает. </P>
            <DIV id=mark_28 class=lecture_mark></DIV>
            <P id=id_36>Недостатком рассматриваемого алгоритма поиска является 
            то, что в худшем случае осуществляется просмотр всего массива. 
            Поэтому данный алгоритм используется, если множество содержит 
            небольшое количество элементов.</P>
            <DIV id=mark_36 class=lecture_mark></DIV>
            <P id=id_37>Достоинства последовательного поиска заключаются в том, 
            что он прост в реализации, не требует сортировки значений множества, 
            дополнительной памяти и дополнительного анализа функций. 
            Следовательно, может работать в потоковом режиме при 
            непосредственном получении данных из любого источника.</P>
            <DIV id=mark_37 class=lecture_mark></DIV>
            <P id=id_38>Существует модификация алгоритма последовательного 
            поиска, которая ускоряет поиск. Эта модификация является небольшим 
            усовершенствованием рассмотренного алгоритма поиска.</P>
            <DIV id=mark_38 class=lecture_mark></DIV>
            <P id=id_39>Идея <SPAN class=xml_em_italic>поиска с барьером</SPAN> 
            состоит в том, чтобы не проверять каждый раз в цикле условие, 
            связанное с границами множества. Это можно обеспечить, установив в 
            данном множестве так называемый барьер. Под барьером понимается 
            любой элемент, который удовлетворяет условию поиска. Тем самым будет 
            ограничено изменение индекса.</P>
            <DIV id=mark_39 class=lecture_mark></DIV>
            <P id=id_40>Выход из цикла, в котором теперь остается только условие 
            поиска, может произойти либо на найденном элементе, либо на барьере. 
            Существует два способа установки барьера: дополнительным элементом 
            или вместо крайнего элемента массива.</P>
            <DIV id=mark_40 class=lecture_mark></DIV>
            <DIV class=example><PRE>//описание функции последовательного поиска с барьером
int LinearSearchWithBarrier(int *x, int k, int key){
    x = (int *)realloc(x,(k+1)*sizeof(int));
    x[k] = key;
    int i = 0;
    while ( x[i] != key )
        i++;
    return i &lt; k ? i : -1;
}
</PRE></DIV>
            <P id=id_42>Заметим, что поиск с барьером работает быстрее, но 
            временная сложность алгоритма остается такой же <SPAN 
            class=texample>O(n)</SPAN>, где <SPAN class=texample>n</SPAN> – 
            количество элементов множества. Гораздо больший интерес представляют 
            методы, не только работающие быстро, но и реализующие алгоритмы с 
            меньшей сложностью.</P>
            <DIV id=mark_42 class=lecture_mark></DIV><A name=sect3></A>
            <H3>Бинарный (двоичный) поиск</H3>
            <P id=id_45><B>Бинарный (двоичный, дихотомический) поиск</B> – это 
            поиск заданного элемента на упорядоченном множестве, осуществляемый 
            путем неоднократного деления этого множества на две части таким 
            образом, что искомый элемент попадает в одну из этих частей. Поиск 
            заканчивается при совпадении искомого элемента с элементом, который 
            является границей между частями множества или при отсутствии 
            искомого элемента.</P>
            <DIV id=mark_45 class=lecture_mark></DIV>
            <P id=id_46>Бинарный поиск применяется к отсортированным множествам 
            и заключается в последовательном разбиении множества пополам и 
            поиска элемента только в одной половине на каждой итерации.</P>
            <DIV id=mark_46 class=lecture_mark></DIV>
            <P id=id_47>Таким образом, идея этого метода заключается в 
            следующем. Поиск нужного значения среди элементов упорядоченного 
            массива (по возрастанию или по убыванию) начинается с определения 
            значения центрального элемента этого массива. Значение данного 
            элемента сравнивается с искомым значением и в зависимости от 
            результатов сравнения предпринимаются определенные действия. Если 
            искомое и центральное значения оказываются равны, то поиск 
            завершается успешно. Если искомое значение меньше центрального или 
            больше, то формируется массив, состоящий из элементов, находящихся 
            слева или справа от центрального соответственно. Затем поиск 
            повторяется в новом массиве (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/37/staldata_37.html#image.37.1">рис. 
            37.1</A>).</P>
            <DIV id=mark_47 class=lecture_mark></DIV>
            <P id=id_48><SPAN class=xml_em_italic>Алгоритм бинарного 
            поиска</SPAN></P>
            <DIV id=mark_48 class=lecture_mark></DIV>
            <P id=id_49>Шаг 1. Определить номер среднего элемента массива <SPAN 
            class=texample>middle=(high+low)/2</SPAN>.</P>
            <DIV id=mark_49 class=lecture_mark></DIV>
            <P id=id_51>Шаг 2. Если значение среднего элемента массива равно 
            искомому, то возвращаем значение, равное номеру искомого элемента, и 
            алгоритм завершает работу.</P>
            <DIV id=mark_51 class=lecture_mark></DIV>
            <P id=id_52>Шаг 3. Если искомое значение больше значения среднего 
            элемента, то возьмем в качестве массива все элементы справа от 
            среднего, иначе возьмем в качестве массива все элементы слева от 
            среднего (в зависимости от характера упорядоченности). Перейдем к 
            Шагу 1.</P>
            <DIV id=mark_52 class=lecture_mark></DIV>
            <P id=id_53>В массиве может встречаться несколько элементов со 
            значениями, равными ключу. Данный алгоритм находит первый совпавший 
            с ключом элемент, который в порядке следования в массиве может быть 
            ни первым, ни последним среди равных ключу. Например, в массиве 
            чисел 1, 5, 5, 5, 5, 5, 5, 7, 8 с ключом <SPAN 
            class=texample>key</SPAN>=5 совпадет элемент с порядковым номером 4, 
            который не относится ни к первому, ни к последнему.</P>
            <DIV id=mark_53 class=lecture_mark></DIV>
            <P id=id_55>Существуют две модификации рассматриваемого алгоритма 
            для поиска первого и последнего вхождения. Все зависит от того, как 
            выбирается средний элемент: округлением в меньшую или большую 
            сторону. В первом случае средний элемент относится к левой части 
            массива, а во втором – к правой.</P>
            <DIV id=mark_55 class=lecture_mark></DIV>
            <P id=id_56 align=left><A name=image.37.1></A>
            <DIV><IMG alt="Демонстрация алгоритма бинарного поиска" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/37_01.png" 
            width=595 height=173></DIV><BR><B>Рис. 37.1.</B>&nbsp; Демонстрация 
            алгоритма бинарного поиска
            <P></P>
            <DIV id=mark_56 class=lecture_mark></DIV>
            <DIV class=example><PRE>//описание функции бинарного поиска
int BinarySearch(int *x, int k, int key){
  bool found = false;
  int high = k - 1, low = 0;
  int middle = (high + low) / 2;
  while ( !found &amp;&amp; high &gt;= low ){
    if (key == x[middle])
      found = true;
    else if (key &lt; x[middle])
      high = middle - 1;
    else 
      low = middle + 1;
      middle = (high + low) / 2;
  } 
  return found ? middle : -1 ;
}
</PRE></DIV>
            <P id=id_58>В процессе работы алгоритма бинарного поиска размер 
            фрагмента, где этот поиск должен продолжаться, каждый раз 
            уменьшается примерно в два раза. Это обеспечивает сложность 
            алгоритма пропорциональную <SPAN class=texample>O(log n)</SPAN>, где 
            <SPAN class=texample>n</SPAN> – количество элементов множества.</P>
            <DIV id=mark_58 class=lecture_mark></DIV>
            <P id=id_61>Время выполнения алгоритма бинарного поиска: если 
            функция имеет вещественный аргумент, найти решение с точностью до 
            <SPAN class=texample>&#949;</SPAN> можно за время <IMG 
            style="POSITION: relative; DISPLAY: inline; TOP: 7px" 
            alt=\log\frac{1}{\varepsilon} 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/787dc7af5092577596d79dd2efe1bf64.png" 
            width=40 height=25>, а если аргумент дискретен, то поиск решения 
            займет <SPAN class=texample>1 + log n</SPAN> времени.</P>
            <DIV id=mark_61 class=lecture_mark></DIV>
            <P id=id_65>Достоинством данного алгоритма является относительная 
            быстрота выполнения поиска, по сравнению с алгоритмом 
            последовательного поиска. Недостаток заключается в том, что бинарный 
            поиск может применяться только на упорядоченном множестве.</P>
            <DIV id=mark_65 class=lecture_mark></DIV><A name=sect4></A>
            <H3>Ключевые термины</H3>
            <P id=id_66><B>Бинарный (двоичный, дихотомический) поиск</B> – это 
            поиск заданного элемента на упорядоченном множестве, осуществляемый 
            путем неоднократного деления этого множества на две части таким 
            образом, что искомый элемент попадает в одну из этих частей.</P>
            <DIV id=mark_66 class=lecture_mark></DIV>
            <P id=id_67><B>Ключ поиска</B> – это поле записи, по значению 
            которого происходит поиск</P>
            <DIV id=mark_67 class=lecture_mark></DIV>
            <P id=id_68><B>Поиск</B> – это процесс нахождения конкретной 
            информации в ранее созданном множестве данных. </P>
            <DIV id=mark_68 class=lecture_mark></DIV>
            <P id=id_69><B>Поиск с барьером</B> – это модификация алгоритма 
            последовательного поиска, ускоряющая процесс путем определения 
            граничного элемента.</P>
            <DIV id=mark_69 class=lecture_mark></DIV>
            <P id=id_70><B>Последовательный (линейный) поиск</B> – это 
            простейший вид поиска заданного элемента на некотором множестве, 
            осуществляемый путем последовательного сравнения очередного 
            рассматриваемого значения с искомым до тех пор, пока эти значения не 
            совпадут.</P>
            <DIV id=mark_70 class=lecture_mark></DIV><A name=sect5></A>
            <H3>Краткие итоги</H3>
            <OL id=id_71>
              <LI>Одним из важнейших действий со структурированной информацией 
              является поиск.
              <LI>Существует множество различных алгоритмов поиска, которые 
              принципиально зависят от способа организации данных. У каждого 
              алгоритма поиска есть свои преимущества и недостатки.
              <LI>Последовательный (линейный) поиск является простейшим видом 
              поиска заданного элемента на некотором множестве, осуществляемым 
              путем последовательного сравнения очередного рассматриваемого 
              значения с искомым до тех пор, пока эти значения не совпадут.
              <LI>Существует модификация алгоритма последовательного поиска, 
              которая ускоряет поиск путем установки в рассматриваемом множестве 
              барьера. 
              <LI>Бинарный (двоичный, дихотомический) поиск является поиском 
              заданного элемента на упорядоченном множестве, осуществляемым 
              путем неоднократного деления этого множества на две части таким 
              образом, что искомый элемент попадает в одну из этих частей. 
              Бинарный поиск применяется к отсортированным множествам.
              <LI>Преимуществом бинарного поиска является более низкая 
              трудоемкость по сравнению с бинарным поиском. Недостаток бинарного 
              поиска состоит в том, что он применим только на отсортированных 
              множествах.</LI></OL>
            <DIV id=mark_71 class=lecture_mark></DIV><A name=sect6></A>
            <H3>Лабораторная работа 37. Алгоритмы поиска в линейных 
            структурах</H3>
            <P id=id_78><B>Цель работы:</B> изучить основные алгоритмы поиска в 
            линейных структурах и научиться решать задачи поиска в линейных 
            структурах на основе алгоритмов последовательного и бинарного 
            поиска.</P>
            <DIV id=mark_78 class=lecture_mark></DIV>
            <P id=id_79>При выполнении лабораторной работы для каждого задания 
            требуется написать программу на языке С++, которая получает на 
            данные из входного файла, выполняет их обработку в соответствии с 
            требованиями задания и выводит результат в выходной файл. Для 
            обработки данных необходимо реализовать функции алгоритмов 
            последовательного и бинарного поиска в линейных структурах. 
            Ограничениями на входные данные является допустимый диапазон 
            значений используемых числовых типов в языке С++.</P>
            <DIV id=mark_79 class=lecture_mark></DIV>
            <P id=id_80><B>Теоретические сведения.</B></P>
            <DIV id=mark_80 class=lecture_mark></DIV>
            <P id=id_81>Ознакомьтесь с материалом лекции 37.</P>
            <DIV id=mark_81 class=lecture_mark></DIV>
            <P id=id_82><B>Задания к лабораторной работе.</B></P>
            <DIV id=mark_82 class=lecture_mark></DIV>
            <P id=id_83>Выполните приведенные ниже задания.</P>
            <DIV id=mark_83 class=lecture_mark></DIV>
            <OL id=id_84>
              <LI>На основании приведенных в лекции 37 функций реализуйте 
              алгоритмы последовательного и бинарного поиска.
              <LI>В связи с визитом Императора Палпатина было решено обновить 
              состав дроидов в ангаре 32. Из-за кризиса было решено новых 
              дроидов не закупать, но выкинуть пару старых. Как известно, 
              Палпатин не переносит дроидов с маленькими серийными номерами, так 
              что все, что требуется – найти среди них двух, у которых серийные 
              номера наименьшие. 
              <P id=id_87><SPAN class=xml_em_italic>Формат входного 
              файла</SPAN></P>
              <DIV id=mark_87 class=lecture_mark></DIV>
              <P id=id_88>Первая строка входного файла содержит целое число 
              <SPAN class=texample>N</SPAN> – количество дроидов. <SPAN 
              class=texample>(2 <IMG style="POSITION: relative; TOP: 2px" 
              border=0 alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/le.gif" 
              width=8 height=18> N <IMG style="POSITION: relative; TOP: 2px" 
              border=0 alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/le.gif" 
              width=8 height=18> 1000)</SPAN>, вторая строка – <SPAN 
              class=texample>N</SPAN> целых чисел, по модулю не превышающих 
              <SPAN class=texample>2·10<SUP>9</SUP></SPAN> – номера дроидов.</P>
              <DIV id=mark_88 class=lecture_mark></DIV>
              <P id=id_93><SPAN class=xml_em_italic>Формат выходного 
              файла</SPAN></P>
              <DIV id=mark_93 class=lecture_mark></DIV>
              <P id=id_94>Выведите два числа: первым – последний по величине из 
              номеров дроидов (такого следует утилизировать в первую очередь), а 
              вторым – предпоследний.</P>
              <DIV id=mark_94 class=lecture_mark></DIV>
              <P id=id_95>Пример входного файла</P>
              <DIV id=mark_95 class=lecture_mark></DIV>
              <DIV class=example><PRE>5
49 100 23 -100 157
</PRE></DIV>
              <P id=id_97>Пример выходного файла</P>
              <DIV id=mark_97 class=lecture_mark></DIV>
              <DIV class=example><PRE>-100 23
</PRE></DIV>
              <P id=id_99>Пример входного файла</P>
              <DIV id=mark_99 class=lecture_mark></DIV>
              <DIV class=example><PRE>4
99 1 5 1
</PRE></DIV>
              <P id=id_101>Пример выходного файла</P>
              <DIV id=mark_101 class=lecture_mark></DIV>
              <DIV class=example><PRE>1 1
</PRE></DIV>
              <LI>Некто загадал число от 1 до <SPAN class=texample>N</SPAN>. За 
              какое наименьшее количество вопросов (на которые он отвечает "да" 
              или "нет") можно угадать задуманное число? 
              <P id=id_105><SPAN class=xml_em_italic>Формат входных 
              данных</SPAN></P>
              <DIV id=mark_105 class=lecture_mark></DIV>
              <P id=id_106>Вводится одно число <SPAN class=texample>N (1 &lt; N 
              &lt; 10001)</SPAN>.</P>
              <DIV id=mark_106 class=lecture_mark></DIV>
              <P id=id_108><SPAN class=xml_em_italic>Формат выходных 
              данных</SPAN></P>
              <DIV id=mark_108 class=lecture_mark></DIV>
              <P id=id_109>Выведите наименьшее количество вопросов, которого 
              гарантированно хватит, чтобы угадать задуманное число.</P>
              <DIV id=mark_109 class=lecture_mark></DIV>
              <P id=id_110><SPAN class=xml_em_italic>Пример входного 
              файла</SPAN></P>
              <DIV id=mark_110 class=lecture_mark></DIV>
              <DIV class=example><PRE>6
</PRE></DIV>
              <P id=id_112><SPAN class=xml_em_italic>Пример выходного 
              файла</SPAN></P>
              <DIV id=mark_112 class=lecture_mark></DIV>
              <DIV class=example><PRE>3
</PRE></DIV>
              <LI>Задана матрица <SPAN class=texample>K</SPAN>, содержащая <SPAN 
              class=texample>n</SPAN> строк и <SPAN class=texample>m</SPAN> 
              столбцов. Седловой точкой этой матрицы назовем элемент, который 
              одновременно является минимумом в своей строке и максимумом в 
              своем столбце. Найдите количество седловых точек заданной матрицы. 

              <P id=id_118><SPAN class=xml_em_italic>Формат входного 
              файла</SPAN></P>
              <DIV id=mark_118 class=lecture_mark></DIV>
              <P id=id_119>Первая строка входного файла содержит целые числа 
              <SPAN class=texample>n</SPAN> и <SPAN class=texample>m (1 <IMG 
              style="POSITION: relative; TOP: 2px" border=0 alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/le.gif" 
              width=8 height=18> n, m <IMG style="POSITION: relative; TOP: 2px" 
              border=0 alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/le.gif" 
              width=8 height=18> 750)</SPAN>. Далее следуют <SPAN 
              class=texample>n</SPAN> строк по <SPAN class=texample>m</SPAN> 
              чисел в каждой. <SPAN class=texample>j</SPAN>-ое число <SPAN 
              class=texample>i</SPAN>-ой строки равно <SPAN 
              class=texample>k<SUB>ij</SUB></SPAN>. Все <SPAN 
              class=texample>k<SUB>ij</SUB></SPAN> по модулю не превосходят 
              1000. </P>
              <DIV id=mark_119 class=lecture_mark></DIV>
              <P id=id_128><SPAN class=xml_em_italic>Формат выходного 
              файла</SPAN></P>
              <DIV id=mark_128 class=lecture_mark></DIV>
              <P id=id_129>В выходной файл выведите ответ на задачу.</P>
              <DIV id=mark_129 class=lecture_mark></DIV>
              <P id=id_130><SPAN class=xml_em_italic>Пример входного 
              файла</SPAN></P>
              <DIV id=mark_130 class=lecture_mark></DIV>
              <DIV class=example><PRE>2 2
0 0
0 0
</PRE></DIV>
              <P id=id_132><SPAN class=xml_em_italic>Пример выходного 
              файла</SPAN></P>
              <DIV id=mark_132 class=lecture_mark></DIV>
              <DIV class=example><PRE>4
</PRE></DIV>
              <P id=id_134><SPAN class=xml_em_italic>Пример входного 
              файла</SPAN></P>
              <DIV id=mark_134 class=lecture_mark></DIV>
              <DIV class=example><PRE>2 2
1 2
3 4
</PRE></DIV>
              <P id=id_136>Пример выходного файла</P>
              <DIV id=mark_136 class=lecture_mark></DIV>
              <DIV class=example><PRE>1
</PRE></DIV>
              <LI>Спортсмен Василий участвовал в соревнованиях по хоккейболу и 
              получил в личном зачете серебряную медаль. Известно, что 
              участники, получившие одинаковое количество очков, награждаются 
              одинаковыми наградами. Известно, что были разыграны золотые 
              серебряные и бронзовые медали. В задаче не спрашиваются правила 
              хоккейбола. Необходимо только определить сколько очков набрал 
              Василий. Для решения данной задачи <SPAN 
              class=xml_em_italic>массив лучше не использовать</SPAN>. 
              <P id=id_139><SPAN class=xml_em_italic>Формат входного 
              файла</SPAN></P>
              <DIV id=mark_139 class=lecture_mark></DIV>
              <P id=id_140>На первой строке дано число <SPAN class=texample>N (2 
              <IMG style="POSITION: relative; TOP: 2px" border=0 alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/le.gif" 
              width=8 height=18> N <IMG style="POSITION: relative; TOP: 2px" 
              border=0 alt="" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/le.gif" 
              width=8 height=18> 1000)</SPAN> количество спортсменов, 
              участвовавших в соревнованиях, на второй <SPAN 
              class=texample>N</SPAN> целых чисел – результаты через пробел.</P>
              <DIV id=mark_140 class=lecture_mark></DIV>
              <P id=id_143><SPAN class=xml_em_italic>Формат выходного 
              файла</SPAN></P>
              <DIV id=mark_143 class=lecture_mark></DIV>
              <P id=id_144>Требуется вывести одно число – результат Василия.</P>
              <DIV id=mark_144 class=lecture_mark></DIV>
              <P id=id_145><SPAN class=xml_em_italic>Пример входного 
              файла</SPAN></P>
              <DIV id=mark_145 class=lecture_mark></DIV>
              <DIV class=example><PRE>5
4 3 3 1 2
</PRE></DIV>
              <P id=id_147><SPAN class=xml_em_italic>Пример выходного 
              файла</SPAN></P>
              <DIV id=mark_147 class=lecture_mark></DIV>
              <DIV class=example><PRE>3
</PRE></DIV>
              <P id=id_149><SPAN class=xml_em_italic>Пример входного 
              файла</SPAN></P>
              <DIV id=mark_149 class=lecture_mark></DIV>
              <DIV class=example><PRE>8
1 2 5 3 5 1 1 6
</PRE></DIV>
              <P id=id_151><SPAN class=xml_em_italic>Пример выходного 
              файла</SPAN></P>
              <DIV id=mark_151 class=lecture_mark></DIV>
              <DIV class=example><PRE>5
</PRE></DIV></LI></OL>
            <DIV id=mark_84 class=lecture_mark></DIV>
            <P id=id_153>Указания к выполнению работы.</P>
            <DIV id=mark_153 class=lecture_mark></DIV>
            <P id=id_154>Каждое задание необходимо решить в соответствии с 
            изученным алгоритмами последовательного и бинарного поиска в 
            линейных структурах, реализовав программный код на языке С++. 
            Рекомендуется воспользоваться материалами лекции 37, где подробно 
            рассматриваются описание используемых в работе алгоритмов, примеры 
            их реализации на языке С++. Программу для решения каждого задания 
            необходимо разработать методом процедурной абстракции, используя 
            рекурсивные функции. Этапы сопроводить комментариями в коде. В 
            отчете следует отразить разработку и обоснование математической 
            модели решения задачи. Результаты тестирования программ необходимо 
            провести в соответствии приведенными примерами входных и выходных 
            файлов к задачам (как дополнение допустимы и собственные примеры 
            тестовых данных).</P>
            <DIV id=mark_154 class=lecture_mark></DIV>
            <P id=id_155>Следует реализовать каждое задание в соответствии с 
            приведенными этапами:</P>
            <DIV id=mark_155 class=lecture_mark></DIV>
            <UL id=id_156>
              <LI>изучить словесную постановку задачи, выделив при этом все виды 
              данных;
              <LI>сформулировать математическую постановку задачи;
              <LI>выбрать метод решения задачи, если это необходимо;
              <LI>разработать графическую схему алгоритма;
              <LI>записать разработанный алгоритм на языке С++;
              <LI>разработать контрольный тест к программе;
              <LI>отладить программу;
              <LI>представить отчет по работе.</LI></UL>
            <DIV id=mark_156 class=lecture_mark></DIV>
            <P id=id_165><B>Требования к отчету.</B></P>
            <DIV id=mark_165 class=lecture_mark></DIV>
            <P id=id_166>Отчет по лабораторной работе должен соответствовать 
            следующей структуре.</P>
            <DIV id=mark_166 class=lecture_mark></DIV>
            <UL id=id_167>
              <LI>Титульный лист.
              <LI>Словесная постановка задачи. В этом подразделе проводится 
              полное описание задачи. Описывается суть задачи, анализ входящих в 
              нее физических величин, область их допустимых значений, единицы их 
              измерения, возможные ограничения, анализ условий при которых 
              задача имеет решение (не имеет решения), анализ ожидаемых 
              результатов.
              <LI>Математическая модель. В этом подразделе вводятся 
              математические описания физических величин и математическое 
              описание их взаимодействий. Цель подраздела – представить решаемую 
              задачу в математической формулировке.
              <LI>Алгоритм решения задачи. В подразделе описывается разработка 
              структуры алгоритма, обосновывается абстракция данных, задача 
              разбивается на подзадачи. Схема алгоритма выполняется по ЕСПД 
              (ГОСТ 19.003-80 и ГОСТ 19.002-80).
              <LI>Листинг программы. Подраздел должен содержать текст программы 
              на языке программирования С++, реализованный в среде MS Visual 
              Studio 2010.
              <LI>Контрольный тест. Подраздел содержит наборы исходных данных и 
              полученные в ходе выполнения программы результаты.
              <LI>Выводы по лабораторной работе. 
              <LI>Ответы на контрольные вопросы.</LI></UL>
            <DIV id=mark_167 class=lecture_mark></DIV>
            <P id=id_176><B>Контрольные вопросы</B></P>
            <DIV id=mark_176 class=lecture_mark></DIV>
            <OL id=id_177>
              <LI>Чем можно объяснить многообразие алгоритмов поиска в линейных 
              структурах?
              <LI>В чем преимущества поиска с барьером по сравнению с 
              последовательным поиском?
              <LI>Нахождение какого по порядку элемента в линейном множестве 
              (первого, последнего) гарантирует алгоритм прямого поиска? Как в 
              этом случае должен быть выполнен просмотр?
              <LI>Нахождение какого по порядку элемента в линейном множестве 
              (первого, последнего) гарантирует алгоритм бинарного поиска? Ответ 
              обоснуйте.
              <LI>Как трудоемкость алгоритма бинарного поиска на дискретном 
              множестве зависит от мощности множества?
              <LI>Почему время выполнения алгоритма бинарного поиска на 
              вещественном множестве не зависит от количества элементов?</LI></OL>
            <DIV id=mark_177 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript 
src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/urchin.js">
</SCRIPT>

<SCRIPT 
type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
