<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0069)http://www.intuit.ru/department/algorithms/staldata/2/staldata_2.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/printable.css">
<META name=GENERATOR content="MSHTML 9.00.8080.16413"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="COLOR: #000000; FONT-WEIGHT: bold">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD>
    <TD><!-- content -->
      <TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD class=head>Структуры и алгоритмы компьютерной обработки 
        данных</TD></TR>
        <TR>
          <TD height=4><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>2. Лекция: Подставляемые (встраиваемые) 
            функции. Перегрузка функций: версия для печати и PDA</SPAN> 
            <BR><SPAN class=rtxt>В лекции рассматриваются понятия, объявление и 
            использование в программах подставляемых и перегруженных функций в 
            С++, механизмы выполнения подстановки и перегрузки функций, 
            рекомендации по повышению эффективности программ за счет перегрузки 
            или подстановки функций. </SPAN></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3></H3>
            <P id=id_1><B>Цель лекции:</B> изучить подставляемые (встраиваемые) 
            функции и перегрузки функций, научиться разрабатывать программы с 
            использованием перегрузки функций на языке C++.</P>
            <DIV id=mark_1 class=lecture_mark></DIV><A name=sect2></A>
            <H3>Подставляемые функции</H3>
            <P id=id_2>Вызов функции, передача в нее значений, возврат значения 
            – эти операции занимают довольно много процессорного времени. Обычно 
            при определении функции компилятор резервирует в памяти только один 
            блок ячеек для сохранения ее операторов. После вызова функции 
            управление программой передается этим операторам, а по возвращении 
            из функции выполнение программы возобновляется со строки, следующей 
            после вызова функции. </P>
            <DIV id=mark_2 class=lecture_mark></DIV>
            <P id=id_3>При неоднократных вызовах каждый раз программа будет 
            отрабатывать один и тот же набор команд, не создавая копий для 
            каждого вызова в отдельности.</P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <P id=id_4>Каждый переход к области памяти, содержащей операторы 
            функции, замедляет выполнение программы. Если функция занимает 
            небольшой объем, то можно получить выигрыш во времени при 
            многократных вызовах, дав компилятору команду встроить код функции 
            непосредственно в программу по месту вызова. Такие функции 
            называется <SPAN class=xml_em_italic>подставляемым</SPAN>и. В этом 
            случае, говоря об эффективности, прежде всего, подразумевается 
            скорость выполнения программы. </P>
            <DIV id=mark_4 class=lecture_mark></DIV>
            <P id=id_5><B>Подставляемые или встраиваемые (inline) функции</B> – 
            это функции, код которых вставляется компилятором непосредственно на 
            место вызова, вместо передачи управления единственному экземпляру 
            функции.</P>
            <DIV id=mark_5 class=lecture_mark></DIV>
            <P id=id_6>Если функция является подставляемой, компилятор не 
            создает данную функцию в памяти, а копирует ее строки 
            непосредственно в код программы по месту вызова. Это равносильно 
            вписыванию в программе соответствующих блоков вместо вызовов 
            функций. Таким образом, спецификатор <SPAN 
            class=texample>inline</SPAN> определяет для функции так называемое 
            <SPAN class=xml_em_italic>внутреннее связывание</SPAN>, которое 
            заключается в том, что компилятор вместо вызова функции подставляет 
            команды ее кода. Подставляемые функции используют, если тело функции 
            состоит из нескольких операторов.</P>
            <DIV id=mark_6 class=lecture_mark></DIV>
            <P id=id_8>Этот подход позволяет увеличить скорость выполнения 
            программы, так как из программы исключаются команды микропроцессора, 
            требующиеся для передачи аргументов и вызова функции.</P>
            <DIV id=mark_8 class=lecture_mark></DIV>
            <P id=id_9>Например:</P>
            <DIV id=mark_9 class=lecture_mark></DIV>
            <DIV class=example><PRE>/*функция возвращает расстояние от точки с координатами(x1,y1) до точки с координатами (x2,y2)*/
inline float Line(float x1,float y1,float x2, float y2) {
  return sqrt(pow(x1-x2,2)+pow(y1-y2,2)); 
}
</PRE></DIV>
            <P id=id_11>Однако следует обратить внимание, что использование 
            подставляемых функций не всегда приводит к положительному эффекту. 
            Если такая функция вызывается в программном коде несколько раз, то 
            во время компиляции в программу будет вставлено столько же копий 
            этой функции, сколько ее вызовов. Произойдет значительное увеличение 
            размера программного кода, в результате чего ожидаемого повышения 
            эффективности выполнения программы по времени может и не 
            произойти.</P>
            <DIV id=mark_11 class=lecture_mark></DIV>
            <P id=id_12><SPAN class=xml_em_italic>Пример 1</SPAN>.</P>
            <DIV id=mark_12 class=lecture_mark></DIV>
            <DIV class=example><PRE>#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
inline int Cube(int x);
int _tmain(int argc, _TCHAR* argv[]){
  int x=2;
  float y=3;
  double z=4;
  cout&lt;&lt;Cube(x)&lt;&lt;endl;
  cout&lt;&lt;Cube(y)&lt;&lt;endl;
  cout&lt;&lt;Cube(z)&lt;&lt;endl;
  system("pause");
  return 0;
}
inline int Cube(int x) { 
  return x*x*x; 
}
</PRE></DIV>
            <P id=id_14>Перечислим причины, по которым функция со спецификатором 
            inline будет трактоваться как обычная не подставляемая функция:</P>
            <DIV id=mark_14 class=lecture_mark></DIV>
            <UL id=id_15>
              <LI>подставляемая функция является рекурсивной;
              <LI>функции, у которых вызов размещается до ее определения;
              <LI>функции, которые вызываются более одного раза в выражении;
              <LI>функции, содержащие циклы, переключатели и операторы 
переходов;
              <LI>функции, которые имеют слишком большой размер, чтобы сделать 
              подстановку.</LI></UL>
            <DIV id=mark_15 class=lecture_mark></DIV>
            <P id=id_21>Ограничения на выполнение подстановки в основном зависят 
            от реализации. Если же для функции со спецификатором <SPAN 
            class=texample>inline</SPAN> компилятор не может выполнить 
            подстановку из-за контекста, в который помещено обращение к ней, то 
            функция считается статической и выдается предупреждающее сообщение. 
            </P>
            <DIV id=mark_21 class=lecture_mark></DIV>
            <P id=id_23>Еще одной из особенностей подставляемых функций является 
            невозможность их изменения без перекомпиляции всех частей программы, 
            в которых эти функции вызываются.</P>
            <DIV id=mark_23 class=lecture_mark></DIV><A name=sect3></A>
            <H3>Перегрузка функции</H3>
            <P id=id_24>При определении функций в программах необходимо 
            указывать тип возвращаемого функцией значения, а также количество 
            параметров и тип каждого из них. Если на языке С++ была написана 
            функция с именем <SPAN class=texample>add_values</SPAN>, которая 
            работала с двумя целыми значениями, а в программе было необходимо 
            использовать подобную функцию для передачи трех целых значений, то 
            тогда следовало бы создать функцию с другим именем. Например, <SPAN 
            class=texample>add_two_values</SPAN> и <SPAN 
            class=texample>add_three_values</SPAN>. Аналогично, если необходимо 
            использовать подобную функцию для работы со значениями типа <SPAN 
            class=texample>float</SPAN>, то нужна еще одна функция с еще одним 
            именем. Чтобы избежать дублирования функции, C++ позволяет 
            определять несколько функций с одним и тем же именем. В процессе 
            компиляции C++ принимает во внимание количество аргументов, 
            используемых каждой функцией, и затем вызывает именно требуемую 
            функцию. Предоставление компилятору выбора среди нескольких функций 
            называется перегрузкой. </P>
            <DIV id=mark_24 class=lecture_mark></DIV>
            <P id=id_29><B>Перегрузка функций</B> – это создание нескольких 
            функций с одним именем, но с разными параметрами. Под разными 
            параметрами понимают, что должно быть разным <SPAN 
            class=xml_em_italic>количество аргументов</SPAN> функции и/или их 
            <SPAN class=xml_em_italic>тип</SPAN>. То есть перегрузка функций 
            позволяет определять несколько функций с одним и тем же именем и 
            типом возвращаемого значения. </P>
            <DIV id=mark_29 class=lecture_mark></DIV>
            <P id=id_30>Перегрузка функций также называется <SPAN 
            class=xml_em_italic>полиморфизмом функций</SPAN>. "Поли" означает 
            много, "морфе" – форма, то есть полиморфическая функция – это 
            функция, отличающаяся многообразием форм.</P>
            <DIV id=mark_30 class=lecture_mark></DIV>
            <P id=id_31>Под полиморфизмом функции понимают существование в 
            программе нескольких перегруженных версий функции, имеющих разные 
            значения. Изменяя количество или тип параметров, можно присвоить 
            двум или нескольким функциям одно и тоже имя. При этом никакой 
            путаницы не будет, поскольку нужная функция определяется по 
            совпадению используемых параметров. Это позволяет создавать функцию, 
            которая сможет работать с целочисленными, вещественными значениями 
            или значениями других типов без необходимости создавать отдельные 
            имена для каждой функции. </P>
            <DIV id=mark_31 class=lecture_mark></DIV>
            <P id=id_32>Таким образом, благодаря использованию перегруженных 
            функций, не следует беспокоиться о вызове в программе нужной 
            функции, отвечающей типу передаваемых переменных. При вызове 
            перегруженной функции компилятор автоматически определит, какой 
            именно вариант функции следует использовать.</P>
            <DIV id=mark_32 class=lecture_mark></DIV>
            <P id=id_33>Например, следующая программа перегружает функцию с 
            именем <SPAN class=texample>add_values</SPAN>. Первое определение 
            функции складывает два значения типа <SPAN 
            class=texample>int</SPAN>. Второе определение функции складывает три 
            значения типа <SPAN class=texample>int</SPAN>. В процессе компиляции 
            C++ корректно определяет функцию, которую необходимо 
            использовать:</P>
            <DIV id=mark_33 class=lecture_mark></DIV>
            <DIV class=example><PRE>#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
int add_values(int a,int b);
int add_values (int a, int b, int c);
int _tmain(int argc, _TCHAR* argv[]){
  cout &lt;&lt; "200+801=" &lt;&lt; add_values(200,801) &lt;&lt; "\n";
  cout &lt;&lt; "100+201+700=" &lt;&lt; add_values(100,201,700) &lt;&lt; "\n";
  system("pause");
  return 0;
}

int add_values(int a,int b) { 
  return(a + b); 
}

int add_values (int a, int b, int c) { 
  return(a + b + c); 
}
</PRE></DIV>
            <P id=id_38>Таким образом, программа определяет две функции с 
            именами <SPAN class=texample>add_values</SPAN>. Первая функция 
            складывает два значения, в то время как вторая складывает три 
            значения одного типа <SPAN class=texample>int</SPAN>. Компилятор 
            языка С++ определяет, какую функцию следует использовать, 
            основываясь на предлагаемых программой параметрах. </P>
            <DIV id=mark_38 class=lecture_mark></DIV><A name=sect4></A>
            <H4>Использование перегрузки функции</H4>
            <P id=id_41>Одним из наиболее общих случаев использования перегрузки 
            является применение функции для получения определенного результата, 
            исходя из различных параметров. Например, предположим, что в 
            программе есть функция с именем <SPAN 
            class=texample>day_of_week</SPAN>, которая возвращает текущий день 
            недели (0 для воскресенья, 1 для понедельника, ... , 6 для субботы). 
            Программа могла бы перегрузить эту функцию таким образом, чтобы она 
            верно возвращала день недели, если ей передан юлианский день в 
            качестве параметра, или если ей переданы день, месяц и год.</P>
            <DIV id=mark_41 class=lecture_mark></DIV>
            <DIV class=example><PRE>int day_of_week(int julian_day) { 
  // операторы 
}

int day_of_week(int month, int day, int year) { 
  // операторы 
}
</PRE></DIV>
            <P id=id_44>При использовании перегруженных функций часто 
            допускается ряд ошибок. Например, если функции отличаются только 
            типом возвращаемого значения, но не типами аргументов, такие функции 
            не могут иметь одинаковое имя. Также недопустим следующий вариант 
            перегрузки:</P>
            <DIV id=mark_44 class=lecture_mark></DIV>
            <DIV class=example><PRE>int имя_функции(int имя_аргумента);
int имя_функции(int имя_аргумента);
/*недопустимая перегрузка имени: аргументы имеют одинаковое количество и одинаковый тип*/
</PRE></DIV><A name=sect5></A>
            <H4>Преимущества перегрузки функции:</H4>
            <UL id=id_46>
              <LI>перегрузка функций улучшает удобочитаемость программ;
              <LI>перегрузка функций C++ позволяет программам определять 
              несколько функций с одним и тем же именем;
              <LI>перегруженные функции возвращают значения одинакового типа, но 
              могут отличаться количеством и типом параметров;
              <LI>перегрузка функций упрощает задачу программистов, требуя, 
              чтобы они помнили только одно имя функции, но тогда они должны 
              знать, какая комбинация параметров соответствует какой 
              функции.</LI></UL>
            <DIV id=mark_46 class=lecture_mark></DIV>
            <P id=id_51><SPAN class=xml_em_italic>Пример 2.</SPAN></P>
            <DIV id=mark_51 class=lecture_mark></DIV>
            <DIV class=example><PRE>/*Перегруженные функции имеют одинаковые имена, но разные списки параметров и возвращаемые значения*/
#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
int average(int first_number, int second_number, int third_number);
int average(int first_number, int second_number);

int _tmain(int argc, _TCHAR* argv[]){// главная функция
  int number_A = 5, number_B = 3, number_C = 10;
  cout &lt;&lt; "Целочисленное среднее чисел " &lt;&lt; number_A &lt;&lt; " и ";
  cout &lt;&lt; number_B &lt;&lt; " равно ";
  cout &lt;&lt; average(number_A, number_B) &lt;&lt; ".\n\n";
  cout &lt;&lt; "Целочисленное среднее чисел " &lt;&lt; number_A &lt;&lt; ", ";
  cout &lt;&lt; number_B &lt;&lt; " и " &lt;&lt; number_C &lt;&lt; " равно ";
  cout &lt;&lt; average(number_A, number_B, number_C) &lt;&lt; ".\n";
  system("PAUSE");
  return 0;
}// конец главной функции

/*функция для вычисления целочисленного среднего значения 3-х целых чисел*/
int average(int first_number, int second_number, int third_number ) {
  return((first_number + second_number + third_number)/3);
} // конец функции

/*функция для вычисления целочисленного среднего значения 2-х целых чисел*/
int average( int first_number, int second_number ) {
  return((first_number + second_number)/2);
} // конец функции
</PRE></DIV>
            <P id=id_53><SPAN class=xml_em_italic>Пример 3.</SPAN></P>
            <DIV id=mark_53 class=lecture_mark></DIV>
            <DIV class=example><PRE>/*Перегруженные функции имеют одинаковые имена и типы возвращаемых значений, но разные типы параметров*/
#include "stdafx.h"
#include &lt;iostream&gt;
using namespace std;
#include&lt;stdio.h&gt;
float average(int first_number, int second_number, 
              int third_number );
float average(float first_number, float second_number, 
              float third_number);

int _tmain(int argc, _TCHAR* argv[]){
  int A = 5, B = 3, C = 10;
  float A1 = 5.1, B1 = 3.4, C1 = 10.5;
  printf("Среднее значение 3-х целых чисел = %f\n", 
          average(A,B,C)/3.0);
  printf("Среднее значение 3-х вещественных чисел = %f\n",
          average(A1,B1,C1)/3.0);
  system("pause");
  return 0;
}

/*функция для вычисления среднего значения 3-х целых чисел*/
float average(int first_number, int second_number, 
              int third_number ) {
  return ((first_number + second_number + third_number));
}

/*функция для вычисления среднего значения 3-х веществен-ных чисел*/
float average(float first_number, float second_number, 
              float third_number) {
  return ((first_number + second_number + third_number));
}
</PRE></DIV><A name=sect6></A>
            <H3>Ключевые термины</H3>
            <P id=id_55><B>Внутреннее связывание</B> – это подстановка 
            компилятором вместо вызова функции команд ее кода.</P>
            <DIV id=mark_55 class=lecture_mark></DIV>
            <P id=id_56><B>Перегрузка функций</B> – это создание нескольких 
            функций с одним именем, но с разными параметрами.</P>
            <DIV id=mark_56 class=lecture_mark></DIV>
            <P id=id_57><B>Подставляемые или встраиваемые (inline) функции</B> – 
            это функции, код которых вставляется компилятором непосредственно на 
            место вызова, вместо передачи управления единственному экземпляру 
            функции.</P>
            <DIV id=mark_57 class=lecture_mark></DIV>
            <P id=id_58><B>Полиморфизм функций</B> – это перегрузка функций.</P>
            <DIV id=mark_58 class=lecture_mark></DIV><A name=sect7></A>
            <H3>Краткие итоги</H3>
            <OL id=id_59>
              <LI>Механизм многократных вызовов функции в программном коде 
              сопряжен с временными затратами.
              <LI>Для сокращения времени на многократные вызовы одной и той же 
              функции используются подставляемые функции.
              <LI>Ограничения на выполнение подстановки в основном зависят от 
              реализации.
              <LI>В С++ реализован полиморфизм функций, заключающийся в 
              объявлении функций с одинаковыми именами, но разными параметрами.
              <LI>Перегруженные функции могут различаться количеством и типом 
              параметров, а также выполняемыми действиями.
              <LI>При использовании перегруженных функций следует избегать 
              ошибок при объявлении функций.
              <LI>Преимущества использования перегруженных функций связаны с 
              удобством работы с программным кодом и разработкой функций 
              пользователя.</LI></OL>
            <DIV id=mark_59 class=lecture_mark></DIV><A name=sect8></A>
            <H3>Лабораторная работа 2. Подставляемые (встраиваемые) функции. 
            Перегрузка функций.</H3>
            <P id=id_67><B>Цель работы:</B> изучить подставляемые (встраиваемые) 
            функции и перегрузки функций, научиться разрабатывать программы с 
            использованием перегрузки функций на языке C++.</P>
            <DIV id=mark_67 class=lecture_mark></DIV>
            <P id=id_68>При выполнении лабораторной работы для каждого задания 
            требуется написать программу на языке С++, которая получает на входе 
            числовые данные, выполняет их обработку в соответствии с 
            требованиями задания и выводит результат на экран. Ввод данных 
            осуществляется с клавиатуры с учетом требований к входным данным, 
            содержащихся в постановке задачи (ввод данных сопровождайте 
            диалогом). Ограничениями на входные данные является допустимый 
            диапазон значений используемых числовых типов в языке С++.</P>
            <DIV id=mark_68 class=lecture_mark></DIV>
            <P id=id_69><B>Теоретические сведения.</B></P>
            <DIV id=mark_69 class=lecture_mark></DIV>
            <P id=id_70>Ознакомьтесь с материалом лекции 2.</P>
            <DIV id=mark_70 class=lecture_mark></DIV>
            <P id=id_71><B>Задания к лабораторной работе.</B></P>
            <DIV id=mark_71 class=lecture_mark></DIV>
            <P id=id_72>Выполните приведенные ниже задания.</P>
            <DIV id=mark_72 class=lecture_mark></DIV>
            <OL id=id_73>
              <LI>Составьте программу для решения задачи. Определите значение 
              <IMG style="POSITION: relative; DISPLAY: inline; TOP: 7px" 
              alt="x=\max\left(a,\max\left(\frac{a}{2},\cos b\right)\right)\cdot\max(2a-b,b)" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/5ac4cd5d1943906f07bbec58d887b886.png" 
              width=341 height=25>, где <IMG 
              style="POSITION: relative; DISPLAY: inline; TOP: 6px" 
              alt="max(x, y)" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/0cf004c3bda6beca1377401c02093e0a.png" 
              width=81 height=22> есть максимальное из чисел <IMG 
              style="POSITION: relative; DISPLAY: inline; TOP: 3px" alt="x, y" 
              src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/2f3305ea7f9e1bb3c80410f9aa8a3d47.png" 
              width=32 height=14>. Разработайте функции нахождения максимального 
              из двух целых и вещественных чисел.
              <LI>Составьте программу для решения задачи. Найдите периметр 
              треугольника, заданного координатами своих вершин (считать, что 
              треугольник существует). Разработайте функции нахождения 
              расстояния между двумя точками, заданными своими координатами. 
              Предусмотрите только случаи двумерного и трехмерного пространств.
              <LI>Составьте программу для решения задачи. Выясните, что больше: 
              среднее арифметическое или среднее геометрическое трех 
              положительных чисел. Разработайте перегруженные функции нахождения 
              среднего арифметического и среднего геометрического трех целых и 
              вещественных чисел.
              <LI>Составьте программу, которая в зависимости от входных данных 
              переводит часы и минуты в минуты или минуты – в часы и минуты. 
              Используйте перегруженные функции. Например, при вводе 134 мин 
              будет выдано значение 2 час 14 мин, а при вводе 2 час 14 мин – 
              значение 134 мин.</LI></OL>
            <DIV id=mark_73 class=lecture_mark></DIV>
            <P id=id_81><B>Указания к выполнению работы.</B></P>
            <DIV id=mark_81 class=lecture_mark></DIV>
            <P id=id_82>Каждое задание необходимо решить в соответствии с 
            изученными методами обработки числовых данных в языке С++. Программу 
            для решения каждого задания необходимо разработать методом 
            процедурной абстракции, используя перегруженные функции. Этапы 
            сопроводить комментариями в коде.</P>
            <DIV id=mark_82 class=lecture_mark></DIV>
            <P id=id_83>Следует реализовать каждое задание в соответствии с 
            приведенными этапами:</P>
            <DIV id=mark_83 class=lecture_mark></DIV>
            <UL id=id_84>
              <LI>изучить словесную постановку задачи, выделив при этом все виды 
              данных;
              <LI>сформулировать математическую постановку задачи;
              <LI>выбрать метод решения задачи, если это необходимо;
              <LI>разработать графическую схему алгоритма;
              <LI>записать разработанный алгоритм на языке С++;
              <LI>разработать контрольный тест к программе;
              <LI>отладить программу;
              <LI>представить отчет по работе.</LI></UL>
            <DIV id=mark_84 class=lecture_mark></DIV>
            <P id=id_93><B>Требования к отчету.</B></P>
            <DIV id=mark_93 class=lecture_mark></DIV>
            <P id=id_94>Отчет по лабораторной работе должен соответствовать 
            следующей структуре.</P>
            <DIV id=mark_94 class=lecture_mark></DIV>
            <UL id=id_95>
              <LI>Титульный лист.
              <LI>Словесная постановка задачи. В этом подразделе проводится 
              полное описание задачи. Описывается суть задачи, анализ входящих в 
              нее физических величин, область их допустимых значений, единицы их 
              измерения, возможные ограничения, анализ условий при которых 
              задача имеет решение (не имеет решения), анализ ожидаемых 
              результатов.
              <LI>Математическая модель. В этом подразделе вводятся 
              математические описания физических величин и математическое 
              описание их взаимодействий. Цель подраздела – представить решаемую 
              задачу в математической формулировке.
              <LI>Алгоритм решения задачи. В подразделе описывается разработка 
              структуры алгоритма, обосновывается абстракция данных, задача 
              разбивается на подзадачи. Схема алгоритма выполняется по ЕСПД 
              (ГОСТ 19.003-80 и ГОСТ 19.002-80).
              <LI>Листинг программы. Подраздел должен содержать текст программы 
              на языке программирования С++, реализованный в среде MS Visual 
              Studio 2010.
              <LI>Контрольный тест. Подраздел содержит наборы исходных данных и 
              полученные в ходе выполнения программы результаты.
              <LI>Выводы по лабораторной работе. 
              <LI>Ответы на контрольные вопросы.</LI></UL>
            <DIV id=mark_95 class=lecture_mark></DIV>
            <P id=id_104><B>Контрольные вопросы</B></P>
            <DIV id=mark_104 class=lecture_mark></DIV>
            <OL id=id_105>
              <LI>Чем отличается механизм вызова встраиваемой и обычной 
              пользовательских функций?
              <LI>На каком этапе выполнения программы происходит встраивание 
              кода подставляемой функции?
              <LI>Почему не рекомендуется встраивать функции с большим кодом?
              <LI>Как будет выполняться программа, если размер кода 
              подставляемой функции превосходит допустимый свободный размер 
              памяти?
              <LI>С какой целью в программировании реализован полиморфизм 
              функций?
              <LI>Каким образом компилятор определяет, какую из перегруженных 
              функций необходимо вызвать в программном коде?
              <LI>Могут ли перегруженные функции возвращать результат одного 
              типа? Ответ обоснуйте. </LI></OL>
            <DIV id=mark_105 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript 
src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/urchin.js">
</SCRIPT>

<SCRIPT 
type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
