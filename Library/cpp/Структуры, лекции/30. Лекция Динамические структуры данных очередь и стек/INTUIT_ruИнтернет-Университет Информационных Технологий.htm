<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0071)http://www.intuit.ru/department/algorithms/staldata/30/staldata_30.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/printable.css">
<META name=GENERATOR content="MSHTML 9.00.8080.16413"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="COLOR: #000000; FONT-WEIGHT: bold">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD>
    <TD><!-- content -->
      <TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD class=head>Структуры и алгоритмы компьютерной обработки 
        данных</TD></TR>
        <TR>
          <TD height=4><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>30. Лекция: Динамические структуры данных: 
            очередь и стек: версия для печати и PDA</SPAN> <BR><SPAN 
            class=rtxt>В лекции рассматриваются определения стека и очереди как 
            частных случаев линейных списков, структура, способы объявления 
            стеков и очередей, основные операции над их элементами, приводятся 
            примеры решения задач с использованием стеков и очередей. 
        </SPAN></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3></H3>
            <P id=id_1><B>Цель лекции:</B> изучить понятия, объявления, 
            особенности доступа к данным и работы с памятью в стеках и очередях, 
            научиться решать задачи с использованием стеков и очередей в языке 
            C++. </P>
            <DIV id=mark_1 class=lecture_mark></DIV>
            <P id=id_2>Стек и очередь – это частные случаи линейного списка.</P>
            <DIV id=mark_2 class=lecture_mark></DIV><A name=sect2></A>
            <H3>Стеки</H3>
            <P id=id_3>В списках доступ к элементам происходит посредством 
            адресации, при этом доступ к отдельным элементам не ограничен. Но 
            существуют также и такие списковые структуры данных, в которых 
            имеются ограничения доступа к элементам. Одним из представителей 
            таких списковых структур является стековый список или просто 
            стек.</P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <P id=id_4><B>Стек</B> (англ. <SPAN class=xml_em_italic>stack</SPAN> 
            – стопка) – это структура данных, в которой новый элемент всегда 
            записывается в ее начало (вершину) и очередной читаемый элемент 
            также всегда выбирается из ее начала (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/30/staldata_30.html#image.30.1">рис. 
            30.1</A>). В стеках используется метод доступа к элементам <SPAN 
            class=xml_em_italic>LIFO</SPAN> (<SPAN class=xml_em_italic>Last 
            Input – First Output</SPAN>, "последним пришел – первым вышел"). 
            Чаще всего принцип работы стека сравнивают со стопкой тарелок: чтобы 
            взять вторую сверху, нужно сначала взять верхнюю.</P>
            <DIV id=mark_4 class=lecture_mark></DIV>
            <P id=id_5>Стек – это список, у которого доступен один элемент (одна 
            позиция). Этот элемент называется <SPAN class=xml_em_italic>вершиной 
            стека</SPAN>. Взять элемент можно только из вершины стека, добавить 
            элемент можно только в вершину стека. Например, если записаны в стек 
            числа 1, 2, 3, то при последующем извлечении получим 3,2,1.</P>
            <DIV id=mark_5 class=lecture_mark></DIV>
            <P id=id_6 align=left><A name=image.30.1></A>
            <DIV><IMG alt="Стек и его организация" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/30_01.png" 
            width=490 height=291></DIV><BR><B>Рис. 30.1.</B>&nbsp; Стек и его 
            организация
            <P></P>
            <DIV id=mark_6 class=lecture_mark></DIV>
            <P id=id_7>Описание стека выглядит следующим образом:</P>
            <DIV id=mark_7 class=lecture_mark></DIV>
            <DIV class=example><PRE>struct имя_типа {
                 информационное поле;
                 адресное поле;
                };
</PRE></DIV>
            <P id=id_9>где <SPAN class=texample>информационное поле</SPAN> – это 
            поле любого ранее объявленного или стандартного типа;</P>
            <DIV id=mark_9 class=lecture_mark></DIV>
            <P id=id_11><SPAN class=texample>адресное поле</SPAN> – это 
            указатель на объект того же типа, что и определяемая структура, в 
            него записывается адрес следующего элемента стека.</P>
            <DIV id=mark_11 class=lecture_mark></DIV>
            <P id=id_13>Например:</P>
            <DIV id=mark_13 class=lecture_mark></DIV>
            <DIV class=example><PRE>struct list { 
             type  pole1;
             list *pole2; 
            } stack;
</PRE></DIV>
            <P id=id_15>Стек как динамическую структуру данных легко 
            организовать на основе линейного списка. Поскольку работа всегда 
            идет с заголовком стека, то есть не требуется осуществлять просмотр 
            элементов, удаление и вставку элементов в середину или конец списка, 
            то достаточно использовать экономичный по памяти линейный 
            однонаправленный список. Для такого списка достаточно хранить 
            указатель вершины стека, который указывает на первый элемент списка. 
            Если стек пуст, то списка не существует, и указатель принимает 
            значение <SPAN class=texample>NULL</SPAN>.</P>
            <DIV id=mark_15 class=lecture_mark></DIV>
            <P id=id_17>Описание элементов стека аналогично описанию элементов 
            линейного однонаправленного списка. Поэтому объявим стек через 
            объявление линейного однонаправленного списка:</P>
            <DIV id=mark_17 class=lecture_mark></DIV>
            <DIV class=example><PRE>struct Stack {
              Single_List *Top;//вершина стека
             };
. . . . . . . . . . 
Stack *Top_Stack;//указатель на вершину стека
</PRE></DIV>
            <P id=id_19>Основные операции, производимые со стеком:</P>
            <DIV id=mark_19 class=lecture_mark></DIV>
            <UL id=id_20>
              <LI>создание стека;
              <LI>печать (просмотр) стека;
              <LI>добавление элемента в вершину стека;
              <LI>извлечение элемента из вершины стека;
              <LI>проверка пустоты стека;
              <LI>очистка стека. </LI></UL>
            <DIV id=mark_20 class=lecture_mark></DIV>
            <P id=id_27>Реализацию этих операций рассмотрим в виде 
            соответствующих функций, которые, в свою очередь, используют функции 
            операций с линейным однонаправленным списком. Обратим внимание, что 
            в функции создания стека используется функция добавления элемента в 
            вершину стека.</P>
            <DIV id=mark_27 class=lecture_mark></DIV>
            <DIV class=example><PRE>//создание стека
void Make_Stack(int n, Stack* Top_Stack){
  if (n &gt; 0) {
    int tmp;//вспомогательная переменная
    cout &lt;&lt; "Введите значение ";
    cin &gt;&gt; tmp; //вводим значение информационного поля
    Push_Stack(tmp, Top_Stack);
    Make_Stack(n-1,Top_Stack);
  }
}

//печать стека
void Print_Stack(Stack* Top_Stack){
  Print_Single_List(Top_Stack-&gt;Top);  
}

//добавление элемента в вершину стека
void Push_Stack(int NewElem, Stack* Top_Stack){
  Top_Stack-&gt;Top =Insert_Item_Single_List(Top_Stack-&gt;Top,1,NewElem);
}

//извлечение элемента из вершины стека
int Pop_Stack(Stack* Top_Stack){
  int NewElem = NULL;
  if (Top_Stack-&gt;Top != NULL) {
    NewElem = Top_Stack-&gt;Top-&gt;Data;
    Top_Stack-&gt;Top = Delete_Item_Single_List(Top_Stack-&gt;Top,0); 
    //удаляем вершину
  }
  return NewElem;
}

//проверка пустоты стека
bool Empty_Stack(Stack* Top_Stack){
  return Empty_Single_List(Top_Stack-&gt;Top);  
}

//очистка стека
void Clear_Stack(Stack* Top_Stack){
  Delete_Single_List(Top_Stack-&gt;Top);  
}
</PRE></DIV>
            <P id=id_29><SPAN class=xml_em_italic>Пример 1</SPAN>. Дана строка 
            символов. Проверьте правильность расстановки в ней круглых 
            скобок.</P>
            <DIV id=mark_29 class=lecture_mark></DIV>
            <P id=id_30>В решении данной задачи будем использовать стек. 
            Приведем главную функцию и функцию для проверки правильности 
            расстановки круглых скобок.</P>
            <DIV id=mark_30 class=lecture_mark></DIV>
            <DIV class=example><PRE>//главная функция
int _tmain(int argc, _TCHAR* argv[]){
  char text[255]; 
  printf("Введите текст, содержащий \"(\" и \")\" \n"); 
  gets(text); 
  Check_Brackets (text);
  system("pause");
  return 0;
}

//функция проверки правильности расстановки скобок
void Check_Brackets (char *text){
  int i; 
  int flag=1;
  Stack *Top_Stack;
  Top_Stack = new Stack();
  for(i=0;i&lt;strlen(text); i++) {
    if(text[i]==')' ) { 
      if(Empty_Stack(Top_Stack)) {
      //Попытка удалить нулевой элемент стека 
        flag=0; 
        break; 
      } 
    if(Top_Stack-&gt;Top-&gt;Data == '(') 
        Pop_Stack(Top_Stack); 
    else {
        flag=0; 
        break; 
       }
    }
    if(text[i]=='(') 
    Push_Stack(text[i],Top_Stack); 
  }
  if(flag!=0 &amp;&amp; Empty_Stack(Top_Stack)) 
    printf("Верно!"); 
  else printf("Неверно!"); 
  Clear_Stack(Top_Stack); 
  printf("\n"); 
}
</PRE></DIV><A name=sect3></A>
            <H3>Очереди</H3>
            <P id=id_32><B>Очередь</B> – это структура данных, представляющая 
            собой последовательность элементов, образованная в порядке их 
            поступления. Каждый новый элемент размещается в конце очереди; 
            элемент, стоящий в начале очереди, выбирается из нее первым. В 
            очереди используется принцип доступа к элементам <SPAN 
            class=xml_em_italic>FIFO</SPAN> (<SPAN class=xml_em_italic>First 
            Input – First Output</SPAN>, "первый пришёл – первый вышел") (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/30/staldata_30.html#image.30.2">рис. 
            30.2</A>). В очереди доступны два элемента (две позиции): <SPAN 
            class=xml_em_italic>начало очереди</SPAN> и <SPAN 
            class=xml_em_italic>конец очереди</SPAN>. Поместить элемент можно 
            только в конец очереди, а взять элемент только из ее начала. 
            Примером может служить обыкновенная очередь в магазине.</P>
            <DIV id=mark_32 class=lecture_mark></DIV>
            <P id=id_33 align=left><A name=image.30.2></A>
            <DIV><IMG alt="Очередь и ее организация" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/30_02.png" 
            width=579 height=316></DIV><BR><B>Рис. 30.2.</B>&nbsp; Очередь и ее 
            организация
            <P></P>
            <DIV id=mark_33 class=lecture_mark></DIV>
            <P id=id_34>Описание очереди выглядит следующим образом:</P>
            <DIV id=mark_34 class=lecture_mark></DIV>
            <DIV class=example><PRE>struct имя_типа {
                 информационное поле;
                 адресное поле1;
                 адресное поле2;
                };
</PRE></DIV>
            <P id=id_36>где <SPAN class=texample>информационное поле</SPAN> – 
            это поле любого, ранее объявленного или стандартного, типа;</P>
            <DIV id=mark_36 class=lecture_mark></DIV>
            <P id=id_38><SPAN class=texample>адресное поле1</SPAN>, <SPAN 
            class=texample>адресное поле2</SPAN> – это указатели на объекты того 
            же типа, что и определяемая структура, в них записываются адреса 
            первого и следующего элементов очереди.</P>
            <DIV id=mark_38 class=lecture_mark></DIV>
            <P id=id_41>Например:</P>
            <DIV id=mark_41 class=lecture_mark></DIV>
            <P id=id_42><SPAN class=xml_em_italic>1 способ:</SPAN> адресное поле 
            ссылается на объявляемую структуру.</P>
            <DIV id=mark_42 class=lecture_mark></DIV>
            <DIV class=example><PRE>struct list2 {
              type  pole1;
              list2 *pole1, *pole2; 
             }
</PRE></DIV>
            <P id=id_44><SPAN class=xml_em_italic>2 способ:</SPAN> адресное поле 
            ссылается на ранее объявленную структуру.</P>
            <DIV id=mark_44 class=lecture_mark></DIV>
            <DIV class=example><PRE>struct list1 { 
              type  pole1;
              list1  *pole2; 
             }
struct ch3 { 
            list1 *beg, *next ; 
           } 
</PRE></DIV>
            <P id=id_46>Очередь как динамическую структуру данных легко 
            организовать на основе линейного списка. Поскольку работа идет с 
            обоими концами очереди, то предпочтительно будет использовать 
            линейный двунаправленный список. Хотя для работы с таким списком 
            достаточно иметь один указатель на любой элемент списка, здесь 
            целесообразно хранить два указателя – один на начало списка (откуда 
            извлекаем элементы) и один на конец списка (куда добавляем 
            элементы). Если очередь пуста, то списка не существует, и указатели 
            принимают значение <SPAN class=texample>NULL</SPAN>.</P>
            <DIV id=mark_46 class=lecture_mark></DIV>
            <P id=id_48>Описание элементов очереди аналогично описанию элементов 
            линейного двунаправленного списка. Поэтому объявим очередь через 
            объявление линейного двунаправленного списка:</P>
            <DIV id=mark_48 class=lecture_mark></DIV>
            <DIV class=example><PRE>struct Queue {
              Double_List *Begin;//начало очереди
              Double_List *End; //конец очереди
             };
. . . . . . . . . . 
Queue *My_Queue;//указатель на очередь
</PRE></DIV>
            <P id=id_50>Основные операции, производимые с очередью:</P>
            <DIV id=mark_50 class=lecture_mark></DIV>
            <UL id=id_51>
              <LI>создание очереди;
              <LI>печать (просмотр) очереди;
              <LI>добавление элемента в конец очереди;
              <LI>извлечение элемента из начала очереди;
              <LI>проверка пустоты очереди;
              <LI>очистка очереди. </LI></UL>
            <DIV id=mark_51 class=lecture_mark></DIV>
            <P id=id_58>Реализацию этих операций приведем в виде соответствующих 
            функций, которые, в свою очередь, используют функции операций с 
            линейным двунаправленным списком.</P>
            <DIV id=mark_58 class=lecture_mark></DIV>
            <DIV class=example><PRE>//создание очереди
void Make_Queue(int n, Queue* End_Queue){
  Make_Double_List(n,&amp;(End_Queue-&gt;Begin),NULL);
  Double_List *ptr; //вспомогательный указатель
  ptr = End_Queue-&gt;Begin;
  while (ptr-&gt;Next != NULL)
    ptr = ptr-&gt;Next;
  End_Queue-&gt;End = ptr;
}

//печать очереди
void Print_Queue(Queue* Begin_Queue){
  Print_Double_List(Begin_Queue-&gt;Begin);
}

//добавление элемента в конец очереди
void Add_Item_Queue(int NewElem, Queue* End_Queue){
  End_Queue-&gt;End = Insert_Item_Double_List(End_Queue-&gt;End,
     0, NewElem)-&gt;Next;
}

//извлечение элемента из начала очереди
int Extract_Item_Queue(Queue* Begin_Queue){
  int NewElem = NULL;
  if (Begin_Queue-&gt;Begin != NULL) {
   NewElem = Begin_Queue-&gt;Begin-&gt;Data;
   Begin_Queue-&gt;Begin=Delete_Item_Double_List(Begin_Queue-&gt;Begin,0);
   //удаляем вершину
  }
  return NewElem;
}

//проверка пустоты очереди
bool Empty_Queue(Queue* Begin_Queue){
  return Empty_Double_List(Begin_Queue-&gt;Begin);  
}

//очистка очереди
void Clear_Queue(Queue* Begin_Queue){
  return Delete_Double_List(Begin_Queue-&gt;Begin);  
}
</PRE></DIV>
            <P id=id_60><SPAN class=xml_em_italic>Пример 2</SPAN>. Дана 
            последовательность ненулевых целых чисел. Признаком конца 
            последовательности является число 0. Найдите среди них первый 
            наибольший отрицательный элемент. Если такого элемента нет, то 
            выведите сообщение об этом.</P>
            <DIV id=mark_60 class=lecture_mark></DIV>
            <P id=id_61>В данной задаче будем использовать основные операции для 
            работы с очередью, рассмотренные ранее. Приведем главную функцию и 
            функцию для реализации поиска первого наибольшего отрицательного 
            элемента.</P>
            <DIV id=mark_61 class=lecture_mark></DIV>
            <DIV class=example><PRE>//главная функция
int _tmain(int argc, _TCHAR* argv[]){
  int n;
  Queue *My_Queue;
  My_Queue = new Queue();
  Make_Queue(1,My_Queue);
  while (My_Queue-&gt;End-&gt;Data != 0){
    cout &lt;&lt; "Введите значение ";
    cin &gt;&gt; n;
    Add_Item_Queue(n,My_Queue);
  }
  cout &lt;&lt; "\nОчередь: \n";
  Print_Queue(My_Queue); 
  Find_Max_Negative_Element(My_Queue);
  system("pause");
  return 0;
}

//функция поиска первого наибольшего отрицательного элемента
void Find_Max_Negative_Element(Queue* Begin_Queue){
  int tmp;
  int max=Extract_Item_Queue(Begin_Queue);
  while (Begin_Queue-&gt;Begin-&gt;Data != 0) {
    tmp = Extract_Item_Queue(Begin_Queue);
    if (max &gt; 0 || tmp &lt; 0 &amp;&amp; abs(tmp) &lt; abs(max)) 
      max = tmp;
  }
  if (max &gt; 0) printf("Элементов нет!");
  else printf("Есть такой элемент: %d", max);
}
</PRE></DIV><A name=sect4></A>
            <H3>Ключевые термины</H3>
            <P id=id_63><B>FIFO (First Input – First Output)</B> – это метод 
            доступа к элементам очереди по принципу , "первый пришёл – первый 
            вышел".</P>
            <DIV id=mark_63 class=lecture_mark></DIV>
            <P id=id_64><B>LIFO (Last Input – First Output)</B> – это метод 
            доступа к элементам стека по принципу "последним пришел – первым 
            вышел"</P>
            <DIV id=mark_64 class=lecture_mark></DIV>
            <P id=id_65><B>Вершина стека</B> – это доступный элемент стека.</P>
            <DIV id=mark_65 class=lecture_mark></DIV>
            <P id=id_66><B>Конец очереди</B> – это позиция доступного для 
            вставки в очередь элемента.</P>
            <DIV id=mark_66 class=lecture_mark></DIV>
            <P id=id_67><B>Начало очереди</B> – это позиция доступного для 
            извлечения из очереди элемента.</P>
            <DIV id=mark_67 class=lecture_mark></DIV>
            <P id=id_68><B>Очередь</B> – это структура данных, представляющая 
            собой последовательность элементов, образованная в порядке их 
            поступления.</P>
            <DIV id=mark_68 class=lecture_mark></DIV>
            <P id=id_69><B>Стек</B> – это структура данных, в которой новый 
            элемент всегда записывается в ее начало (вершину) и очередной 
            читаемый элемент также всегда выбирается из ее начала.</P>
            <DIV id=mark_69 class=lecture_mark></DIV><A name=sect5></A>
            <H3>Краткие итоги</H3>
            <OL id=id_70>
              <LI>Стек и очередь – это частные случаи линейного списка.
              <LI>Стек является списком, у которого доступен один элемент, 
              называемый вершиной стека. Поместить или извлечь элемент можно 
              только из вершины списка.
              <LI>Стек и очередь как динамические структуры данных можно 
              организовать на основе линейного списка.
              <LI>Основными операциями со стеком являются: создание стека; 
              печать (просмотр) стека; добавление элемента в вершину стека; 
              извлечение элемента из вершины стека; проверка пустоты стека; 
              удаление стека. 
              <LI>Очередь является списком, у которого доступны два элемента: 
              начало и конец очереди. Поместить элемент можно только в конец 
              очереди, а взять элемент только из ее начала.
              <LI>Основными операциями с очередью являются: создание очереди; 
              печать (просмотр) очереди; добавление элемента в конец очереди; 
              извлечение элемента из начала очереди; проверка пустоты очереди; 
              удаление очереди.
              <LI>Стек и очередь более экономно расходуют адресное пространство 
              по сравнению с однонаправленными и двунаправленными 
            списками.</LI></OL>
            <DIV id=mark_70 class=lecture_mark></DIV><A name=sect6></A>
            <H3>Лабораторная работа 30. Динамические структуры данных: очередь и 
            стек</H3>
            <P id=id_78><B>Цель работы:</B> изучить понятия, объявления, 
            особенности доступа к данным и работы с памятью в стеках и очередях, 
            научиться решать задачи с использованием стеков и очередей в языке 
            C++.</P>
            <DIV id=mark_78 class=lecture_mark></DIV>
            <P id=id_79>При выполнении лабораторной работы для каждого задания 
            требуется написать программу на языке С++, в которой выполнено 
            формирование очереди или стека в соответствии с постановкой задачи, 
            ввод данных элементов очереди или стека с учетом типа 
            информационного поля, их обработка и вывод на экран в указанном 
            формате. Для хранения данных динамических структур следует 
            использовать ресурсы динамической памяти. Ввод данных осуществляется 
            с клавиатуры с учетом требований к входным данным, содержащихся в 
            постановке задачи. Ограничениями на входные данные являются 
            максимальный размер строковых данных, диапазоны числовых типов полей 
            структуры и допустимый размер области динамической памяти в языке 
            С++.</P>
            <DIV id=mark_79 class=lecture_mark></DIV>
            <P id=id_80><B>Теоретические сведения.</B></P>
            <DIV id=mark_80 class=lecture_mark></DIV>
            <P id=id_81>Ознакомьтесь с материалом лекции 30.</P>
            <DIV id=mark_81 class=lecture_mark></DIV>
            <P id=id_82><B>Задания к лабораторной работе.</B></P>
            <DIV id=mark_82 class=lecture_mark></DIV>
            <P id=id_83>Выполните приведенные ниже задания.</P>
            <DIV id=mark_83 class=lecture_mark></DIV>
            <OL id=id_84>
              <LI>Опишите стек с целочисленным информационным полем. Заполните 
              его длинами строк, считанных из файла. Распечатайте на экране 
              содержимое стека. Укажите номер и длину последней самой короткой 
              строки файла.
              <LI>Разработайте программу, с помощью которой можно определить 
              наибольший допустимый размер очереди с вещественным информационным 
              полем. Найдите этот размер (число элементов в очереди).
              <LI>Опишите очередь с вещественным информационным полем, и 
              заполните ее элементами с клавиатуры. Выполните циклический сдвиг 
              элементов в очереди так, чтобы в ее начале был расположен 
              наибольший элемент.
              <LI>Разработайте программу, с помощью которой можно определить 
              наибольший допустимый размер стека с вещественным информационным 
              полем. Найдите этот размер (число элементов в стеке). Сравните с 
              наибольшим допустимым размером очереди с аналогичным 
              информационным полем.</LI></OL>
            <DIV id=mark_84 class=lecture_mark></DIV>
            <P id=id_89><B>Указания к выполнению работы.</B></P>
            <DIV id=mark_89 class=lecture_mark></DIV>
            <P id=id_90>Каждое задание необходимо решить в соответствии с 
            изученными методами формирования, вывода и обработки данных очередей 
            и стеков в языке С++. Обработку очередей или стеков следует 
            выполнить на основе базовых алгоритмов: поиск, вставка элемента, 
            удаление элемента, удаление всей динамической структуры. При 
            объявлении списков выполните комментирование используемых полей. 
            Задачи 2 и 4 носят исследовательский характер, поэтому при 
            составлении отчета к ним следует подробно описать предлагаемый метод 
            оценки максимального размера очереди или стека. Программу для 
            решения каждого задания необходимо разработать методом процедурной 
            абстракции, оформив комментарии к коду.</P>
            <DIV id=mark_90 class=lecture_mark></DIV>
            <P id=id_91>Следует реализовать каждое задание в соответствии с 
            приведенными этапами:</P>
            <DIV id=mark_91 class=lecture_mark></DIV>
            <UL id=id_92>
              <LI>изучить словесную постановку задачи, выделив при этом все виды 
              данных;
              <LI>сформулировать математическую постановку задачи;
              <LI>выбрать метод решения задачи, если это необходимо;
              <LI>разработать графическую схему алгоритма;
              <LI>записать разработанный алгоритм на языке С++;
              <LI>разработать контрольный тест к программе;
              <LI>отладить программу;
              <LI>представить отчет по работе.</LI></UL>
            <DIV id=mark_92 class=lecture_mark></DIV>
            <P id=id_101><B>Требования к отчету.</B></P>
            <DIV id=mark_101 class=lecture_mark></DIV>
            <P id=id_102>Отчет по лабораторной работе должен соответствовать 
            следующей структуре.</P>
            <DIV id=mark_102 class=lecture_mark></DIV>
            <UL id=id_103>
              <LI>Титульный лист.
              <LI>Словесная постановка задачи. В этом подразделе проводится 
              полное описание задачи. Описывается суть задачи, анализ входящих в 
              нее физических величин, область их допустимых значений, единицы их 
              измерения, возможные ограничения, анализ условий при которых 
              задача имеет решение (не имеет решения), анализ ожидаемых 
              результатов.
              <LI>Математическая модель. В этом подразделе вводятся 
              математические описания физических величин и математическое 
              описание их взаимодействий. Цель подраздела – представить решаемую 
              задачу в математической формулировке.
              <LI>Алгоритм решения задачи. В подразделе описывается разработка 
              структуры алгоритма, обосновывается абстракция данных, задача 
              разбивается на подзадачи. Схема алгоритма выполняется по ЕСПД 
              (ГОСТ 19.003-80 и ГОСТ 19.002-80).
              <LI>Листинг программы. Подраздел должен содержать текст программы 
              на языке программирования С++, реализованный в среде MS Visual 
              Studio 2010.
              <LI>Контрольный тест. Подраздел содержит наборы исходных данных и 
              полученные в ходе выполнения программы результаты.
              <LI>Выводы по лабораторной работе. 
              <LI>Ответы на контрольные вопросы.</LI></UL>
            <DIV id=mark_103 class=lecture_mark></DIV>
            <P id=id_112><B>Контрольные вопросы</B></P>
            <DIV id=mark_112 class=lecture_mark></DIV>
            <OL id=id_113>
              <LI>В чем преимущества и недостатки организации структур в виде 
              стека?
              <LI>В чем преимущества и недостатки организации структур в виде 
              очереди?
              <LI>Для моделирования каких реальных задач удобно использовать 
              стек? А для каких очередь?
              <LI>Какое значение хранит указатель на стек?
              <LI>Какое значение хранит указатель на очередь?
              <LI>Какие существуют ограничения на тип информационного поля стеки 
              и очереди?
              <LI>С какой целью в программах выполняется проверка на пустоту 
              стека и очереди?
              <LI>При работе со стеком или очередью доступны позиции 
              ограниченного числа элементов. Возможна ли ситуация записи новых 
              элементов стека или очереди на уже занятые собственными элементами 
              участки памяти (запись себя поверх себя)? Ответ обоснуйте.
              <LI>С какой целью в программах выполняется удаление стека и 
              очереди по окончании работы с ними? Как изменится работа 
              программы, если операцию удаления не выполнять?</LI></OL>
            <DIV id=mark_113 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript 
src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/urchin.js">
</SCRIPT>

<SCRIPT 
type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
