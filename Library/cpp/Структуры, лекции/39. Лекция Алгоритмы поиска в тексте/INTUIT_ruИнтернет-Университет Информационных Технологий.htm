<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0071)http://www.intuit.ru/department/algorithms/staldata/39/staldata_39.html -->
<HTML><HEAD><TITLE>INTUIT.ru::Интернет-Университет Информационных Технологий</TITLE>
<META content="text/html; charset=windows-1251" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/printable.css">
<META name=GENERATOR content="MSHTML 9.00.8080.16413"></HEAD>
<BODY leftMargin=6 topMargin=6 marginwidth="6" marginheight="6">
<DIV align=left><SPAN style="COLOR: #000000; FONT-WEIGHT: bold">&nbsp;&nbsp; 
<SPAN style="FONT-SIZE: 12pt">Интернет-Университет Информационных 
Технологий</SPAN> </SPAN></DIV>&nbsp;&nbsp; <SPAN 
style="COLOR: #330066; TEXT-DECORATION: underline" 
align="rright">http://www.INTUIT.ru</SPAN> 
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR>
    <TD class=orang height=1 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD height=8 colSpan=3><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=8></TD></TR>
  <TR vAlign=top>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD>
    <TD><!-- content -->
      <TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
        <TBODY>
        <TR>
          <TD class=head>Структуры и алгоритмы компьютерной обработки 
        данных</TD></TR>
        <TR>
          <TD height=4><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=4></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><SPAN class=headsub>39. Лекция: Алгоритмы поиска в тексте: 
            версия для печати и PDA</SPAN> <BR><SPAN class=rtxt>В лекции 
            рассматриваются основные понятия и алгоритмы, используемые в задачах 
            поиска в тексте и приводятся примеры реализации основных алгоритмов 
            поиска в тексте. </SPAN></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD class=orang height=1><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=1></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR>
        <TR>
          <TD><A name=sect1></A>
            <H3></H3>
            <P id=id_1><B>Цель лекции:</B> изучить основные алгоритмы поиска в 
            тексте и научиться решать задачи поиска в тексте на основе 
            алгоритмов прямого поиска; Кнута, Морриса и Пратта; Боуера и 
            Мура.</P>
            <DIV id=mark_1 class=lecture_mark></DIV>
            <P id=id_2>Работа в текстовом редакторе, поисковые запросы в базе 
            данных, задачи в биоинформатике, лексический анализ программ требуют 
            эффективных алгоритмов работы с текстом. Задачи поиска слова в 
            тексте используются в криптографии, различных разделах физики, 
            сжатии данных, распознавании речи и других сферах человеческой 
            деятельности.</P>
            <DIV id=mark_2 class=lecture_mark></DIV>
            <P id=id_3>Введем ряд определений, которые будут использоваться 
            далее в изложении материала.</P>
            <DIV id=mark_3 class=lecture_mark></DIV>
            <P id=id_4><B>Алфавит</B> – конечное множество символов.</P>
            <DIV id=mark_4 class=lecture_mark></DIV>
            <P id=id_5><B>Строка (слово)</B> – это последовательность символов 
            из некоторого алфавита. <SPAN class=xml_em_italic>Длина 
            строки</SPAN> – количество символов в строке.</P>
            <DIV id=mark_5 class=lecture_mark></DIV>
            <P id=id_6>Строку будем обозначать символами алфавита, например 
            <SPAN class=texample>X=x[1]x[2]...x[n]</SPAN> – строка длинной <SPAN 
            class=texample>n</SPAN>, где <SPAN class=texample>x[i]</SPAN> – 
            <SPAN class=texample>i</SPAN>-ый символ строки <SPAN 
            class=texample>Х</SPAN>, принадлежащий алфавиту. Строка, не 
            содержащая ни одного символа, называется <SPAN 
            class=xml_em_italic>пустой</SPAN>.</P>
            <DIV id=mark_6 class=lecture_mark></DIV>
            <P id=id_12>Строка <SPAN class=texample>X</SPAN> называется 
            <B>подстрокой</B> строки <SPAN class=texample>Y</SPAN>, если 
            найдутся такие строки <SPAN class=texample>Z<SUB>1</SUB></SPAN> и 
            <SPAN class=texample>Z<SUB>2</SUB></SPAN>, что <SPAN 
            class=texample>Y=Z<SUB>1</SUB>XZ<SUB>2</SUB></SPAN>. При этом <SPAN 
            class=texample>Z<SUB>1</SUB></SPAN> называют <SPAN 
            class=xml_em_italic>левым</SPAN>, а <SPAN 
            class=texample>Z<SUB>2</SUB></SPAN> – <SPAN 
            class=xml_em_italic>правым крылом подстроки</SPAN>. Подстрокой может 
            быть и сама строка. Иногда при этом строку <SPAN 
            class=texample>X</SPAN> называют вхождением в строку <SPAN 
            class=texample>Y</SPAN>. Например, строки <SPAN 
            class=texample>hrf</SPAN> и <SPAN class=texample>fhr</SPAN> является 
            подстроками строки <SPAN class=texample>abhrfhr</SPAN>.</P>
            <DIV id=mark_12 class=lecture_mark></DIV>
            <P id=id_25>Подстрока <SPAN class=texample>X</SPAN> называется 
            <B>префиксом</B> строки <SPAN class=texample>Y</SPAN>, если есть 
            такая подстрока <SPAN class=texample>Z</SPAN>, что <SPAN 
            class=texample>Y=XZ</SPAN>. Причем сама строка является префиксом 
            для себя самой (так как найдется нулевая строка <SPAN 
            class=texample>L</SPAN>, что <SPAN class=texample>X=XL</SPAN>). 
            Например, подстрока <SPAN class=texample>ab</SPAN> является 
            префиксом строки <SPAN class=texample>abcfa</SPAN>.</P>
            <DIV id=mark_25 class=lecture_mark></DIV>
            <P id=id_34>Подстрока <SPAN class=texample>X</SPAN> называется 
            <B>суффиксом</B> строки <SPAN class=texample>Y</SPAN>, если есть 
            такая подстрока <SPAN class=texample>Z</SPAN>, что <SPAN 
            class=texample>Y=ZX</SPAN>. Аналогично, строка является суффиксом 
            себя самой. Например, подстрока <SPAN class=texample>bfg</SPAN> 
            является суффиксом строки <SPAN class=texample>vsenfbfg</SPAN>.</P>
            <DIV id=mark_34 class=lecture_mark></DIV>
            <P id=id_41>Поставим задачу поиска подстроки в строке. Пусть задана 
            строка, состоящая из некоторого количества символов. Проверим, 
            входит ли заданная подстрока в данную строку. Если входит, то найдем 
            номер, начиная с какого символа строки, то есть, определим первое 
            вхождение заданной подстроки в исходной строке.</P>
            <DIV id=mark_41 class=lecture_mark></DIV>
            <P id=id_42>Рассмотрим несколько известных алгоритмов поиска 
            подстроки в строке более подробно.</P>
            <DIV id=mark_42 class=lecture_mark></DIV><A name=sect2></A>
            <H3>Прямой поиск</H3>
            <P id=id_43>Данный алгоритм еще называется алгоритмом 
            последовательного поиска, он является самым простым и очевидным.</P>
            <DIV id=mark_43 class=lecture_mark></DIV>
            <P id=id_44>Основная идея алгоритма прямым поиском заключается в 
            посимвольном сравнении строки с подстрокой. В начальный момент 
            происходит сравнение первого символа строки с первым символом 
            подстроки, второго символа строки со вторым символом подстроки и т. 
            д. Если произошло совпадение всех символов, то фиксируется факт 
            нахождения подстроки. В противном случае производится сдвиг 
            подстроки на одну позицию вправо и повторяется посимвольное 
            сравнение, то есть сравнивается второй символ строки с первым 
            символом подстроки, третий символ строки со вторым символом 
            подстроки и т. д. (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/39/staldata_39.html#image.39.1">рис. 
            39.1</A>) Символы, которые сравниваются, на рисунке выделены жирным. 
            Рассматриваемые сдвиги подстроки повторяются до тех пор, пока конец 
            подстроки не достиг конца строки или не произошло полное совпадение 
            символов подстроки со строкой, то есть найдется подстрока.</P>
            <DIV id=mark_44 class=lecture_mark></DIV>
            <P id=id_45 align=left><A name=image.39.1></A>
            <DIV><IMG alt="Демонстрация алгоритма прямого поиска" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/39_01.png" 
            width=570 height=381></DIV><BR><B>Рис. 39.1.</B>&nbsp; Демонстрация 
            алгоритма прямого поиска
            <P></P>
            <DIV id=mark_45 class=lecture_mark></DIV>
            <DIV class=example><PRE>//Описание функции прямого поиска подстроки в строке
int DirectSearch(char *string, char *substring){
  int sl, ssl;
  int res = -1;
  sl = strlen(string);
  ssl = strlen(substring);
  if ( sl == 0 ) 
    cout &lt;&lt; "Неверно задана строка\n"; 
  else if ( ssl == 0 ) 
    cout &lt;&lt; "Неверно задана подстрока\n"; 
  else
    for (int i = 0; i &lt; sl - ssl + 1; i++)
      for (int j = 0; j &lt; ssl; j++)
        if ( substring[j] != string[i+j] )
          break;
        else if ( j == ssl - 1 ){
          res = i;
          break;
        }
  return res;
}
</PRE></DIV>
            <P id=id_47>Данный алгоритм является малозатратным и не нуждается в 
            предварительной обработке и в дополнительном пространстве. 
            Большинство сравнений алгоритма прямого поиска являются лишними. 
            Поэтому в худшем случае алгоритм будет малоэффективен, так как его 
            сложность будет пропорциональна <SPAN 
            class=texample>O((n-m+1)·m)</SPAN>, где <SPAN 
            class=texample>n</SPAN> и <SPAN class=texample>m</SPAN> – длины 
            строки и подстроки соответственно.</P>
            <DIV id=mark_47 class=lecture_mark></DIV><A name=sect3></A>
            <H3>Алгоритм Кнута, Морриса и Пратта</H3>
            <P id=id_51>Алгоритм был открыт Д. Кнутом и В. Праттом и, независимо 
            от них, Д. Моррисом. Результаты своей работы они совместно 
            опубликовали в 1977 году. Алгоритм Кнута, Морриса и Пратта 
            (КМП-алгоритм) является алгоритмом, который фактически требуюет 
            только <SPAN class=texample>O(n)</SPAN> сравнений даже в самом 
            худшем случае. Рассматриваемый алгоритм основывается на том, что 
            после частичного совпадения начальной части подстроки с 
            соответствующими символами строки фактически известна пройденная 
            часть строки и можно, вычислить некоторые сведения, с помощью 
            которых затем быстро продвинуться по строке.</P>
            <DIV id=mark_51 class=lecture_mark></DIV>
            <P id=id_53>Основным отличием алгоритма Кнута, Морриса и Пратта от 
            алгоритма прямого поиска заключается в том, что сдвиг подстроки 
            выполняется не на один символ на каждом шаге алгоритма, а на 
            некоторое переменное количество символов. Следовательно, перед тем 
            как осуществлять очередной сдвиг, необходимо определить величину 
            сдвига. Для повышения эффективности алгоритма необходимо, чтобы 
            сдвиг на каждом шаге был бы как можно большим (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/39/staldata_39.html#image.39.2">рис. 
            39.2</A>). На рисунке символы, подвергшиеся сравнению, выделены 
            жирным шрифтом.</P>
            <DIV id=mark_53 class=lecture_mark></DIV>
            <P id=id_54>Если для произвольной подстроки определить все ее 
            начала, одновременно являющиеся ее концами, и выбрать из них самую 
            длинную (не считая, конечно, саму строку), то такую процедуру 
            принято называть префикс-функцией. В реализации алгоритма Кнута, 
            Морриса и Пратта используется предобработка искомой подстроки, 
            которая заключается в создании префикс-функции на ее основе. При 
            этом используется следующая идея: если префикс (он же суффикс) 
            строки длинной <SPAN class=texample>i</SPAN> длиннее одного символа, 
            то он одновременно и префикс подстроки длинной <SPAN 
            class=texample>i-1</SPAN>. Таким образом, проверяем префикс 
            предыдущей подстроки, если же тот не подходит, то префикс ее 
            префикса, и т.д. Действуя так, находим наибольший искомый 
            префикс.</P>
            <DIV id=mark_54 class=lecture_mark></DIV>
            <P id=id_57 align=left><A name=image.39.2></A>
            <DIV><IMG alt="Демонстрация алгоритма Кнута, Морриса и Пратта" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/39_02.png" 
            width=569 height=250></DIV><BR><B>Рис. 39.2.</B>&nbsp; Демонстрация 
            алгоритма Кнута, Морриса и Пратта
            <P></P>
            <DIV id=mark_57 class=lecture_mark></DIV>
            <DIV class=example><PRE>//описание функции алгоритма Кнута, Морриса и Пратта
int KMPSearch(char *string, char *substring){
  int  sl, ssl;
  int res = -1;
  sl = strlen(string);
  ssl = strlen(substring);
  if ( sl == 0 ) 
    cout &lt;&lt; "Неверно задана строка\n"; 
  else if ( ssl == 0 ) 
    cout &lt;&lt; "Неверно задана подстрока\n"; 
  else {
    int  i, j = 0, k = -1;
    int  *d;
    d = new int[1000];
    d[0] = -1;
    while ( j &lt; ssl - 1 ) {
      while ( k &gt;= 0 &amp;&amp; substring[j] != substring[k] ) 
        k = d[k];
      j++;
      k++;
      if ( substring[j] == substring[k] )
        d[j] = d[k];
      else 
        d[j] = k;
    }
    i = 0;
    j = 0;
    while ( j &lt; ssl &amp;&amp; i &lt; sl ){
      while ( j &gt;= 0 &amp;&amp; string[i] != substring[j] )
        j = d[j];
      i++;
      j++;
    }
    delete [] d;
    res =  j == ssl ? i - ssl : -1;
  }
  return res;
}
</PRE></DIV>
            <P id=id_59>Точный анализ рассматриваемого алгоритма весьма сложен. 
            Д. Кнут, Д. Моррис и В. Пратт доказывают, что для данного алгоритма 
            требуется порядка <SPAN class=texample>O(m+n)</SPAN> сравнений 
            символов (где <SPAN class=texample>n</SPAN> и <SPAN 
            class=texample>m</SPAN> – длины строки и подстроки соответственно), 
            что значительно лучше, чем при прямом поиске.</P>
            <DIV id=mark_59 class=lecture_mark></DIV><A name=sect4></A>
            <H3>Алгоритм Бойера и Мура</H3>
            <P id=id_63>Алгоритм Бойера и Мура считается наиболее быстрым среди 
            алгоритмов, предназначенных для поиска подстроки в строке. Он был 
            разработан Р. Бойером и Д. Муром в 1977 году. Преимущество этого 
            алгоритма в том, что необходимо сделать некоторые предварительные 
            вычисления над подстрокой, чтобы сравнение подстроки с исходной 
            строкой осуществлять не во всех позициях – часть проверок 
            пропускаются как заведомо не дающие результата.</P>
            <DIV id=mark_63 class=lecture_mark></DIV>
            <P id=id_64>Существует множество вариаций алгоритма Бойера и Мура, 
            рассмотрим простейший из них, который состоит из следующих шагов. 
            Первоначально строится таблица смещений для искомой подстроки. Далее 
            идет совмещение начала строки и подстроки и начинается проверка с 
            последнего символа подстроки. Если последний символ подстроки и 
            соответствующий ему при наложении символ строки не совпадают, 
            подстрока сдвигается относительно строки на величину, полученную из 
            таблицы смещений, и снова проводится сравнение, начиная с последнего 
            символа подстроки. Если же символы совпадают, производится сравнение 
            предпоследнего символа подстроки и т.д. Если все символы подстроки 
            совпали с наложенными символами строки, значит, найдена подстрока и 
            поиск окончен. Если же какой-то (не последний) символ подстроки не 
            совпадает с соответствующим символом строки, далее производим сдвиг 
            подстроки на один символ вправо и снова начинаем проверку с 
            последнего символа. Весь алгоритм выполняется до тех пор, пока либо 
            не будет найдено вхождение искомой подстроки, либо не будет 
            достигнут конец строки (<A 
            href="http://www.intuit.ru/department/algorithms/staldata/39/staldata_39.html#image.39.3">рис. 
            39.3</A>). На рисунке символы, подвергшиеся сравнению, выделены 
            жирным шрифтом.</P>
            <DIV id=mark_64 class=lecture_mark></DIV>
            <P id=id_65>Величина сдвига в случае несовпадения последнего символа 
            вычисляется, исходя из следующего: сдвиг подстроки должен быть 
            минимальным, таким, чтобы не пропустить вхождение подстроки в 
            строке. Если данный символ строки встречается в подстроке, то 
            смещаем подстроку таким образом, чтобы символ строки совпал с самым 
            правым вхождением этого символа в подстроке. Если же подстрока 
            вообще не содержит этого символа, то сдвигаем подстроку на величину, 
            равную ее длине, так что первый символ подстроки накладывается на 
            следующий за проверявшимся символом строки.</P>
            <DIV id=mark_65 class=lecture_mark></DIV>
            <P id=id_66>Величина смещения для каждого символа подстроки зависит 
            только от порядка символов в подстроке, поэтому смещения удобно 
            вычислить заранее и хранить в виде одномерного массива, где каждому 
            символу алфавита соответствует смещение относительно последнего 
            символа подстроки.</P>
            <DIV id=mark_66 class=lecture_mark></DIV>
            <P id=id_67 align=left><A name=image.39.3></A>
            <DIV><IMG alt="Демонстрация алгоритма Бойера и Мура" 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/39_03.png" 
            width=569 height=223></DIV><BR><B>Рис. 39.3.</B>&nbsp; Демонстрация 
            алгоритма Бойера и Мура
            <P></P>
            <DIV id=mark_67 class=lecture_mark></DIV>
            <DIV class=example><PRE>//описание функции алгоритма Бойера и Мура
int BMSearch(char *string, char *substring){
  int  sl, ssl;
  int res = -1;
  sl = strlen(string);
  ssl = strlen(substring);
  if ( sl == 0 ) 
    cout &lt;&lt; "Неверно задана строка\n"; 
  else if ( ssl == 0 ) 
    cout &lt;&lt; "Неверно задана подстрока\n"; 
  else {
    int  i, Pos;
    int  BMT[256];
    for ( i = 0; i &lt; 256; i ++ )
      BMT[i] = ssl;
    for ( i = ssl-1; i &gt;= 0; i-- )
      if ( BMT[(short)(substring[i])] == ssl ) 
        BMT[(short)(substring[i])] = ssl - i - 1;
    Pos = ssl - 1;
    while ( Pos &lt; sl )
      if ( substring[ssl - 1] != string[Pos] )
        Pos = Pos + BMT[(short)(string[Pos])];
      else 
        for ( i = ssl - 2; i &gt;= 0; i-- ){
          if ( substring[i] != string[Pos - ssl + i + 1] ) {
            Pos += BMT[(short)(string[Pos - ssl + i + 1])] - 1;
            break;
          }
          else
            if ( i == 0 )
              return Pos - ssl + 1;
          cout &lt;&lt; "\t" &lt;&lt; i &lt;&lt; endl;
        }
  }
  return res;
}
</PRE></DIV>
            <P id=id_69>Алгоритм Бойера и Мура на хороших данных очень быстр, а 
            вероятность появления плохих данных крайне мала. Поэтому он 
            оптимален в большинстве случаев, когда нет возможности провести 
            предварительную обработку текста, в котором проводится поиск. Таким 
            образом, данный алгоритм является наиболее эффективным в обычных 
            ситуациях, а его быстродействие повышается при увеличении подстроки 
            или алфавита. В наихудшем случае трудоемкость рассматриваемого 
            алгоритма <SPAN class=texample>O(m+n)</SPAN>.</P>
            <DIV id=mark_69 class=lecture_mark></DIV>
            <P id=id_71>Существуют попытки совместить присущую алгоритму Кнута, 
            Морриса и Пратта эффективность в "плохих" случаях и скорость 
            алгоритма Бойера и Мура в "хороших" – например, турбо-алгоритм, 
            обратный алгоритм Колусси и другие.</P>
            <DIV id=mark_71 class=lecture_mark></DIV>
            <P id=id_72>Каждый алгоритм поиска позволяет эффективно действовать 
            лишь для своего класса задач, об этом еще говорят различные 
            узконаправленные улучшения. Алгоритм поиска подстроки в строке 
            следует выбирать только после точной постановки задачи, которые 
            должна выполнять программа.</P>
            <DIV id=mark_72 class=lecture_mark></DIV><A name=sect5></A>
            <H3>Ключевые термины</H3>
            <P id=id_73><B>Алгоритм Бойера и Мура</B> – это алгоритм поиска 
            подстроки в строке, при котором первоначально строится таблица 
            смещений для искомой подстроки, проверка начинается с последнего 
            символа подстроки после совмещения начала строки и подстроки.</P>
            <DIV id=mark_73 class=lecture_mark></DIV>
            <P id=id_74><B>Алгоритм Кнута, Морриса и Пратта</B> – это алгоритм 
            поиска подстроки в строке, при котором сдвиг подстроки выполняется 
            на некоторое переменное количество символов.</P>
            <DIV id=mark_74 class=lecture_mark></DIV>
            <P id=id_75><B>Алгоритм прямого поиска</B> – это алгоритм поиска 
            подстроки в строке, при котором происходит посимвольное сравнение 
            строки с подстрокой.</P>
            <DIV id=mark_75 class=lecture_mark></DIV>
            <P id=id_76><B>Алфавит</B> – конечное множество символов</P>
            <DIV id=mark_76 class=lecture_mark></DIV>
            <P id=id_77><B>Длина строки</B> – количество символов в строке</P>
            <DIV id=mark_77 class=lecture_mark></DIV>
            <P id=id_78><B>Подстрока</B> – это последовательность подряд идущих 
            символов в строке.</P>
            <DIV id=mark_78 class=lecture_mark></DIV>
            <P id=id_79><B>Префикс</B> – это подстрока, начинающаяся с первого 
            символа строки.</P>
            <DIV id=mark_79 class=lecture_mark></DIV>
            <P id=id_80><B>Строка</B> – это последовательность символов.</P>
            <DIV id=mark_80 class=lecture_mark></DIV>
            <P id=id_81><B>Суффикс</B> – это подстрока, заканчивающаяся на 
            последний символ строки.</P>
            <DIV id=mark_81 class=lecture_mark></DIV><A name=sect6></A>
            <H3>Краткие итоги</H3>
            <OL id=id_82>
              <LI>Задачи поиска слова в тексте используются в криптографии, 
              различных разделах физики, сжатии данных, распознавании речи и 
              других сферах человеческой деятельности.
              <LI>Основная идея алгоритма прямым поиском заключается в 
              посимвольном сравнении строки с подстрокой.
              <LI>Алгоритм прямого поиска является малозатратным и не нуждается 
              в предварительной обработке и в дополнительном пространстве.
              <LI>Алгоритм Кнута, Морриса и Пратта основывается на том, что 
              после частичного совпадения начальной части подстроки с 
              соответствующими символами строки можно, вычислить сведения, с 
              помощью которых быстро продвинуться по строке.
              <LI>Трудоемкость алгоритма Кнута, Морриса и Пратта лучше, чем 
              трудоемкость алгоритма прямого поиска.
              <LI>Особенность алгоритма Бойера и Мура заключается в 
              предварительных вычислениях над подстрокой с целью сравнения 
              подстроки с исходной строкой, осуществляемой не во всех позициях.
              <LI>Алгоритм Бойера и Мура оптимален в большинстве случаев, когда 
              нет возможности провести предварительную обработку текста, в 
              котором проводится поиск.</LI></OL>
            <DIV id=mark_82 class=lecture_mark></DIV><A name=sect7></A>
            <H3>Лабораторная работа 39. Алгоритмы поиска в тексте</H3>
            <P id=id_90><B>Цель работы:</B> изучить основные алгоритмы поиска в 
            тексте и научиться решать задачи поиска в тексте на основе 
            алгоритмов прямого поиска; Кнута, Морриса и Пратта; Боуера и 
            Мура.</P>
            <DIV id=mark_90 class=lecture_mark></DIV>
            <P id=id_91>При выполнении лабораторной работы для каждого задания 
            требуется написать программу на языке С++, которая получает на 
            данные из входного файла, выполняет их обработку в соответствии с 
            требованиями задания и выводит результат в выходной файл. Для 
            обработки данных необходимо реализовать функции алгоритмов 
            Кнута-Морриса-Пратта и Боуера-Мура для поиска в тексте. 
            Ограничениями на входные данные является максимальный размер 
            строковых данных, допустимый диапазон значений используемых числовых 
            типов в языке С++.</P>
            <DIV id=mark_91 class=lecture_mark></DIV>
            <P id=id_92><B>Теоретические сведения.</B></P>
            <DIV id=mark_92 class=lecture_mark></DIV>
            <P id=id_93>Ознакомьтесь с материалом лекции 39.</P>
            <DIV id=mark_93 class=lecture_mark></DIV>
            <P id=id_94><B>Задания к лабораторной работе.</B></P>
            <DIV id=mark_94 class=lecture_mark></DIV>
            <P id=id_95>Выполните приведенные ниже задания.</P>
            <DIV id=mark_95 class=lecture_mark></DIV>
            <OL id=id_96>
              <LI>На основании приведенных в лекции 39 функций реализуйте 
              алгоритмы поиска подстроки в строке.
              <LI>Строка <SPAN class=texample>S</SPAN> была записана много раз 
              подряд, после чего из получившейся строки взяли подстроку и 
              передали как входные данные. Необходимо определить минимально 
              возможную длину исходной строки <SPAN class=texample>S</SPAN>. 
              <P id=id_101><SPAN class=xml_em_italic>Формат входных 
              данных</SPAN></P>
              <DIV id=mark_101 class=lecture_mark></DIV>
              <P id=id_102>В первой и единственной строке входного файла 
              записана строка, которая содержит только латинские буквы, длина 
              строки не превышает 50000 символов.</P>
              <DIV id=mark_102 class=lecture_mark></DIV>
              <P id=id_103><SPAN class=xml_em_italic>Формат выходных 
              данных</SPAN></P>
              <DIV id=mark_103 class=lecture_mark></DIV>
              <P id=id_104>В выходной файл нужно вывести одно число – ответ на 
              задачу.</P>
              <DIV id=mark_104 class=lecture_mark></DIV>
              <P id=id_105><SPAN class=xml_em_italic>Пример входного файла 
              input.txt</SPAN></P>
              <DIV id=mark_105 class=lecture_mark></DIV>
              <DIV class=example><PRE>abababa
</PRE></DIV>
              <P id=id_107><SPAN class=xml_em_italic>Пример выходного файла 
              output.txt</SPAN></P>
              <DIV id=mark_107 class=lecture_mark></DIV>
              <DIV class=example><PRE>2
</PRE></DIV>
              <LI>Даны две строки <SPAN class=texample>a</SPAN> и <SPAN 
              class=texample>b</SPAN>. Требуется найти максимальную длину 
              префикса строки <SPAN class=texample>a</SPAN>, который входит как 
              подстрока в строку <SPAN class=texample>b</SPAN>. При этом 
              считать, что пустая строка является подстрокой любой строки. 
              <P id=id_114><SPAN class=xml_em_italic>Формат входных 
              данных</SPAN></P>
              <DIV id=mark_114 class=lecture_mark></DIV>
              <P id=id_115>В первой строке входного файла содержится строка 
              <SPAN class=texample>a</SPAN>, во второй – строка <SPAN 
              class=texample>b</SPAN>. Элементами строк <SPAN 
              class=texample>a</SPAN> и <SPAN class=texample>b</SPAN> являются 
              произвольные символы с кодами ASCII больше 32. Длина каждой строки 
              от 1 до 30000. </P>
              <DIV id=mark_115 class=lecture_mark></DIV>
              <P id=id_120><SPAN class=xml_em_italic>Формат выходных 
              данных</SPAN></P>
              <DIV id=mark_120 class=lecture_mark></DIV>
              <P id=id_121>В выходной файл вывести искомую длину префикса строки 
              <SPAN class=texample>a</SPAN>, т.е. целое число от 0 до длины 
              строки <SPAN class=texample>a</SPAN>.</P>
              <DIV id=mark_121 class=lecture_mark></DIV>
              <P id=id_124><SPAN class=xml_em_italic>Пример входного файла 
              input.txt</SPAN></P>
              <DIV id=mark_124 class=lecture_mark></DIV>
              <DIV class=example><PRE>abcdefghijklmnopqrstuvwxyz
Abcd?aBcd!abCd.abcD!?
</PRE></DIV>
              <P id=id_126><SPAN class=xml_em_italic>Пример выходного файла 
              output.txt</SPAN></P>
              <DIV id=mark_126 class=lecture_mark></DIV>
              <DIV class=example><PRE>3
</PRE></DIV>
              <LI>Назовем строку палиндромом, если она одинаково читается слева 
              направо и справа налево. Примеры палиндромов: "abcba", "55", "q", 
              "xyzzyx". Требуется для заданной строки найти максимальную по 
              длине ее подстроку, являющуюся палиндромом. 
              <P id=id_129><SPAN class=xml_em_italic>Формат входных 
              данных</SPAN></P>
              <DIV id=mark_129 class=lecture_mark></DIV>
              <P id=id_130>Во входном файле содержится единственная строка, 
              состоящая из строчных букв латинского алфавита и цифр. Длина 
              строки не превосходит 2000.</P>
              <DIV id=mark_130 class=lecture_mark></DIV>
              <P id=id_131><SPAN class=xml_em_italic>Формат выходных 
              данных</SPAN></P>
              <DIV id=mark_131 class=lecture_mark></DIV>
              <P id=id_132>В выходной файл выведите одно целое число - 
              максимальную длину подстроки, являющейся палиндромом.</P>
              <DIV id=mark_132 class=lecture_mark></DIV>
              <P id=id_133><SPAN class=xml_em_italic>Пример входного файла 
              input.txt</SPAN></P>
              <DIV id=mark_133 class=lecture_mark></DIV>
              <DIV class=example><PRE>a123bc9e9c321
</PRE></DIV>
              <P id=id_135><SPAN class=xml_em_italic>Пример выходного файла 
              output.txt</SPAN></P>
              <DIV id=mark_135 class=lecture_mark></DIV>
              <DIV class=example><PRE>5
</PRE></DIV></LI></OL>
            <DIV id=mark_96 class=lecture_mark></DIV>
            <P id=id_137><B>Указания к выполнению работы.</B></P>
            <DIV id=mark_137 class=lecture_mark></DIV>
            <P id=id_138>Каждое задание необходимо решить в соответствии с 
            изученным алгоритмами Кнута-Морриса-Пратта и Боуера-Мура для поиска 
            в тексте, реализовав программный код на языке С++. Рекомендуется 
            воспользоваться материалами лекции 38, где подробно рассматриваются 
            описание используемых в работе алгоритмов, примеры их реализации на 
            языке С++. Программу для решения каждого задания необходимо 
            разработать методом процедурной абстракции, используя функции. Этапы 
            решения сопроводить комментариями в коде. В отчете следует отразить 
            разработку и обоснование математической модели решения задачи. 
            Результаты тестирования программ необходимо провести в соответствии 
            приведенными примерами входных и выходных файлов к задачам (как 
            дополнение допустимы и собственные примеры тестовых данных).</P>
            <DIV id=mark_138 class=lecture_mark></DIV>
            <P id=id_139>Следует реализовать каждое задание в соответствии с 
            приведенными этапами:</P>
            <DIV id=mark_139 class=lecture_mark></DIV>
            <UL id=id_140>
              <LI>изучить словесную постановку задачи, выделив при этом все виды 
              данных;
              <LI>сформулировать математическую постановку задачи;
              <LI>выбрать метод решения задачи, если это необходимо;
              <LI>разработать графическую схему алгоритма;
              <LI>записать разработанный алгоритм на языке С++;
              <LI>разработать контрольный тест к программе;
              <LI>отладить программу;
              <LI>представить отчет по работе.</LI></UL>
            <DIV id=mark_140 class=lecture_mark></DIV>
            <P id=id_149><B>Требования к отчету.</B></P>
            <DIV id=mark_149 class=lecture_mark></DIV>
            <P id=id_150>Отчет по лабораторной работе должен соответствовать 
            следующей структуре.</P>
            <DIV id=mark_150 class=lecture_mark></DIV>
            <UL id=id_151>
              <LI>Титульный лист.
              <LI>Словесная постановка задачи. В этом подразделе проводится 
              полное описание задачи. Описывается суть задачи, анализ входящих в 
              нее физических величин, область их допустимых значений, единицы их 
              измерения, возможные ограничения, анализ условий при которых 
              задача имеет решение (не имеет решения), анализ ожидаемых 
              результатов.
              <LI>Математическая модель. В этом подразделе вводятся 
              математические описания физических величин и математическое 
              описание их взаимодействий. Цель подраздела – представить решаемую 
              задачу в математической формулировке.
              <LI>Алгоритм решения задачи. В подразделе описывается разработка 
              структуры алгоритма, обосновывается абстракция данных, задача 
              разбивается на подзадачи. Схема алгоритма выполняется по ЕСПД 
              (ГОСТ 19.003-80 и ГОСТ 19.002-80).
              <LI>Листинг программы. Подраздел должен содержать текст программы 
              на языке программирования С++, реализованный в среде MS Visual 
              Studio 2010.
              <LI>Контрольный тест. Подраздел содержит наборы исходных данных и 
              полученные в ходе выполнения программы результаты.
              <LI>Выводы по лабораторной работе. 
              <LI>Ответы на контрольные вопросы.</LI></UL>
            <DIV id=mark_151 class=lecture_mark></DIV>
            <P id=id_160><B>Контрольные вопросы</B></P>
            <DIV id=mark_160 class=lecture_mark></DIV>
            <OL id=id_161>
              <LI>Приведите пример входных данных для реализации эффективного 
              метода прямого поиска подстроки в строке.
              <LI>Приведите пример строки, для которой поиск подстроки "aaabaaa" 
              будет более эффективным, если делать его методом Кнута, Морриса и 
              Пратта, чем, если делать его методом Бойера и Мура. И наоборот. 
              <LI>Объясните, как влияет размер таблицы кодов в алгоритме Бойера 
              и Мура на скорость поиска.
              <LI>За счет чего в алгоритме Бойера и Мура поиск оптимален в 
              большинстве случаев?
              <LI>Поясните влияние префикс-функции в алгоритме Кнута, Морриса и 
              Пратта на организацию поиска подстроки в строке.</LI></OL>
            <DIV id=mark_161 class=lecture_mark></DIV></TD></TR>
        <TR>
          <TD height=8><IMG 
            src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
            width=1 height=8></TD></TR></TBODY></TABLE><!-- /content --></TD>
    <TD><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=8 height=1></TD></TR></TBODY></TABLE><!-- /bottom -->
<TABLE border=0 cellSpacing=0 cellPadding=0 width="100%">
  <TBODY>
  <TR>
    <TD class=orang height=1><IMG 
      src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/empty.gif" 
      width=1 height=1></TD></TR>
  <TR>
    <TD class=ltxt align=center>© INTUIT.ru, 2003-2010. Все права 
  защищены.</TD></TR></TBODY></TABLE><!-- /bottom -->
<SCRIPT type=text/javascript 
src="INTUIT_ruИнтернет-Университет%20Информационных%20Технологий_files/urchin.js">
</SCRIPT>

<SCRIPT 
type=text/javascript>
_uacct = "UA-3475067-1";
urchinTracker();
</SCRIPT>
</BODY></HTML>
